<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Graphical minimap and location GPS, item-location-NPC database searching, speedwalking, UI and much more, created by Quow-->
<muclient>
  <plugin name="CowBar" author="Quow" id="bfe35205f026786ea1d56e3b" language="Lua" purpose="Minimap, UI &amp; More!" date_written="2016-08-27" date_modified="2020-05-09" save_state="y" requires="4.84" version="4.30">
  </plugin>
  <script>
    <![CDATA[

-- *******************************************************************************
-- *****          Minimap, Map-Tracker and Custom UI made by Quow            *****
-- *******************************************************************************

-- STOP!

-- *********************************************
-- ***** DO NOT EDIT ANYTHING IN THIS FILE! ****
-- *********************************************

-- Unless you are an advanced user looking to specifically edit parts of the plugin code, please do not edit anything past this point
-- All user-configurable data should be done from within the menus and commands this plugin provides in Mushclient
-- You should not need to edit anything below this point - you can resize the windows, and set other options, in-client 
-- Check "help minimap".  Right-click the windows for other options.  Left-click drag to move windows around.  Drag the bottom/side edges of windows to resize them.

-- *********************************************
-- ***** DO NOT EDIT ANYTHING IN THIS FILE! ****
-- *********************************************

-- Are you a Windows 10 user?  Did you put your MUSHclient in your main C: drive, perhaps in Program Files?
-- Then Windows 10 is probably hiding all your files for you, any file changes will be getting re-directed to here;
-- C:\Users\<your username>\AppData\Local\VirtualStore\Program Files (x86)\MUSHclient\
-- Windows 10 treats Program Files folders a bit like the main Windows folder - better to make a MUSHclient folder on desktop/documents/other drive

-- Do you want to make commands stay in the command-line after entering them?  Check this option in MUSHclient;
-- File->World Properties->Input->Commands, right-hand side, tick "Auto-repeat Command"

-- *********************************************************************************************************
-- *********************************************************************************************************
-- ******************************              Start of Code Below              ****************************
-- *********************************************************************************************************
-- *********************************************************************************************************

-- Require JSON, we use it a few times!
require "json"

-- Escape a string safely for SQL queries
function EscapeSQL(s)
  if s then
    return string.gsub (s, "'", "''")
  else
    return ""
  end
end

-- Get core variables from DB user file
sCoreGetCache = {}
function GetSQLVariable(sVariableName)
  -- Do we have this value cached?
  if (sCoreGetCache[sVariableName] ~= nil) then
    return sCoreGetCache[sVariableName]
  end
  -- Try to load it fresh from the database
  for row in dbUserData:nrows("SELECT option_value FROM core_options WHERE option_id='" .. sVariableName .. "'") do
    sCoreGetCache[sVariableName] = row.option_value
    return row.option_value
  end
  -- Try to backup from old mush-state for a few versions/indefinitely
  if (GetVariable(sVariableName) ~= nil) then
    local sTempValue = GetVariable(sVariableName)
    return sTempValue
  end
  -- Fallback for future nil
  return nil
end
-- Set single core variable into DB user file
function SetSQLVariable(sVariableName, sVariableData)
  assert(dbUserData:execute("INSERT OR REPLACE INTO core_options (option_id, option_value) VALUES ('" .. EscapeSQL(sVariableName) .. "', '" .. EscapeSQL(sVariableData) .. "')"))
  return " "
end
-- Save all core variables into DB user file
function SetAllSQLVariables()
  local sSaveSQL = "INSERT OR REPLACE INTO core_options (option_id, option_value) VALUES "
  -- Save window positional data
  for sSaveThisWin, _ in pairs(WINDATA) do
    local mwi = _G["mw_" .. sSaveThisWin .. "_movewindow_info"]
      if (mwi) then
      sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. sSaveThisWin .. "_windowx") .. "', '" .. EscapeSQL(mwi.window_left) .. "'),"
      sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. sSaveThisWin .. "_windowy") .. "', '" .. EscapeSQL(mwi.window_top) .. "'),"
      sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. sSaveThisWin .. "_windowmode") .. "', '" .. EscapeSQL(mwi.window_mode) .. "'),"
      sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. sSaveThisWin .. "_windowflags") .. "', '" .. EscapeSQL(mwi.window_flags) .. "'),"
      if WindowInfo(sSaveThisWin, 10) then
        sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. sSaveThisWin .. "_windowx") .. "', '" .. EscapeSQL(WindowInfo(sSaveThisWin, 10)) .. "'),"
      end
      if WindowInfo(sSaveThisWin, 11) then
        sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. sSaveThisWin .. "_windowy") .. "', '" .. EscapeSQL(WindowInfo(sSaveThisWin, 11)) .. "'),"
      end
    end
  end
  sSaveSQL = string.sub(sSaveSQL, 0, -2)
  assert(dbUserData:execute(sSaveSQL))
  sSaveSQL = "INSERT OR REPLACE INTO core_options (option_id, option_value) VALUES "
  -- Core variables
  sSaveSQL = sSaveSQL .. "('iCurrentCombatStatSet', '" .. tostring(iCurrentCombatStatSet) .. "'),"
  sSaveSQL = sSaveSQL .. "('iCurrentChannelChoice', '" .. tostring(iCurrentChannelChoice) .. "'),"
  sSaveSQL = sSaveSQL .. "('bOptimisedCombatTriggers', '" .. tostring(bOptimisedCombatTriggers) .. "'),"
  sSaveSQL = sSaveSQL .. "('iThemeLayoutLocked', '" .. tostring(iThemeLayoutLocked) .. "'),"
  sSaveSQL = sSaveSQL .. "('bLockMargins', '" .. tostring(bLockMargins) .. "'),"
  sSaveSQL = sSaveSQL .. "('iCurMap', '" .. tostring(iCurMap) .. "'),"
  sSaveSQL = sSaveSQL .. "('iMyX', '" .. tostring(iMyX) .. "'),"
  sSaveSQL = sSaveSQL .. "('iMyY', '" .. tostring(iMyY) .. "'),"
  sSaveSQL = sSaveSQL .. "('bHideOnTerrain', '" .. tostring(bHideOnTerrain) .. "'),"
  sSaveSQL = sSaveSQL .. "('bReBroadcastData', '" .. tostring(bReBroadcastData) .. "'),"
  sSaveSQL = sSaveSQL .. "('bAutoShowHideAscii', '" .. tostring(bAutoShowHideAscii) .. "'),"
  sSaveSQL = sSaveSQL .. "('bTerrainsTracking', '" .. tostring(bTerrainsTracking) .. "'),"
  sSaveSQL = sSaveSQL .. "('bAsciiMapOmitted', '" .. tostring(bAsciiMapOmitted) .. "'),"
  sSaveSQL = sSaveSQL .. "('bHotspotsPrioritiseRedraw', '" .. tostring(bHotspotsPrioritiseRedraw) .. "'),"
  sSaveSQL = sSaveSQL .. "('bHotspotsChatWindow', '" .. tostring(bHotspotsChatWindow) .. "'),"
  sSaveSQL = sSaveSQL .. "('bMDTParsingEnabled', '" .. tostring(bMDTParsingEnabled) .. "'),"
  sSaveSQL = sSaveSQL .. "('iMDTDefaultValue', '" .. tostring(iMDTDefaultValue) .. "'),"
  sSaveSQL = sSaveSQL .. "('iMDTMinimumScore', '" .. tostring(iMDTMinimumScore) .. "'),"
  sSaveSQL = sSaveSQL .. "('bMDTShowEmptyRoomCount', '" .. tostring(bMDTShowEmptyRoomCount) .. "'),"
  sSaveSQL = sSaveSQL .. "('bMDTReverseSortOrder', '" .. tostring(bMDTReverseSortOrder) .. "'),"
  sSaveSQL = sSaveSQL .. "('bMDTForceWordWrap', '" .. tostring(bMDTForceWordWrap) .. "'),"
  sSaveSQL = sSaveSQL .. "('bDrawOrbs', '" .. tostring(bDrawOrbs) .. "'),"
  sSaveSQL = sSaveSQL .. "('bPredictiveMoves', '" .. tostring(bPredictiveMoves) .. "'),"
  sSaveSQL = sSaveSQL .. "('bDrawSkeletonMode', '" .. tostring(bDrawSkeletonMode) .. "'),"
  sSaveSQL = sSaveSQL .. "('bShowGhost', '" .. tostring(bShowGhost) .. "'),"
  sSaveSQL = sSaveSQL .. "('bCreatingActualNewRooms', '" .. tostring(bCreatingActualNewRooms) .. "'),"
  sSaveSQL = sSaveSQL .. "('iOldMap', '" .. tostring(iOldMap) .. "'),"
  sSaveSQL = sSaveSQL .. "('iOldMX', '" .. tostring(iOldMX) .. "'),"
  sSaveSQL = sSaveSQL .. "('iOldMY', '" .. tostring(iOldMY) .. "'),"
  sSaveSQL = sSaveSQL .. "('TACR', '" .. EscapeSQL(tostring(TACR)) .. "'),"
  sSaveSQL = sSaveSQL .. "('bSoloShieldsWindow', '" .. tostring(bSoloShieldsWindow) .. "'),"
  sSaveSQL = sSaveSQL .. "('bSelfShieldChats', '" .. tostring(bSelfShieldChats) .. "'),"
  sSaveSQL = sSaveSQL .. "('bGroupShieldChats', '" .. tostring(bGroupShieldChats) .. "'),"
  sSaveSQL = sSaveSQL .. "('bShowItemValues', '" .. tostring(bShowItemValues) .. "'),"
  sSaveSQL = sSaveSQL .. "('bRapMyWrap', '" .. tostring(bRapMyWrap) .. "'),"
  sSaveSQL = sSaveSQL .. "('bRequestRoomMap', '" .. tostring(bRequestRoomMap) .. "'),"
  sSaveSQL = sSaveSQL .. "('bRequestWrittenMap', '" .. tostring(bRequestWrittenMap) .. "'),"
  sSaveSQL = sSaveSQL .. "('bRequestCharVitals', '" .. tostring(bRequestCharVitals) .. "'),"
  sSaveSQL = sSaveSQL .. "('bScreenreader', '" .. tostring(bScreenreader) .. "'),"
  sSaveSQL = sSaveSQL .. "('sCurrentRoomID', '" .. EscapeSQL(sCurrentRoomID) .. "'),"
  sSaveSQL = sSaveSQL .. "('sClickedRoomID', '" .. EscapeSQL(sClickedRoomID) .. "'),"
  sSaveSQL = sSaveSQL .. "('sLastDir', '" .. EscapeSQL(sLastDir) .. "'),"
  sSaveSQL = sSaveSQL .. "('iMinimapBrightness', '" .. tostring(iMinimapBrightness) .. "'),"
  sSaveSQL = sSaveSQL .. "('iUseZoom', '" .. tostring(iUseZoom) .. "'),"
  sSaveSQL = sSaveSQL .. "('TCBL', '" .. EscapeSQL(tostring(TCBL)) .. "'),"
  sSaveSQL = sSaveSQL .. "('iVitalsFormat', '" .. tostring(iVitalsFormat) .. "'),"
  sSaveSQL = sSaveSQL .. "('bVitalsGradients', '" .. tostring(bVitalsGradients) .. "'),"
  sSaveSQL = sSaveSQL .. "('iMapDotColour', '" .. tostring(iMapDotColour) .. "'),"
  sSaveSQL = sSaveSQL .. "('bCentreCrosshair', '" .. tostring(bCentreCrosshair) .. "'),"
  sSaveSQL = sSaveSQL .. "('bShowDiscDate', '" .. tostring(bShowDiscDate) .. "'),"
  sSaveSQL = sSaveSQL .. "('sMyPlayerName', '" .. EscapeSQL(tostring(sMyPlayerName)) .. "'),"
  sSaveSQL = sSaveSQL .. "('bShowDiscDate', '" .. tostring(bShowDiscDate) .. "'),"
  sSaveSQL = sSaveSQL .. "('bShowCommsTabs', '" .. tostring(bShowCommsTabs) .. "'),"
  sSaveSQL = sSaveSQL .. "('bShowAlignment', '" .. tostring(bShowAlignment) .. "'),"
  sSaveSQL = sSaveSQL .. "('bShowHPNotifications', '" .. tostring(bShowHPNotifications) .. "'),"
  sSaveSQL = sSaveSQL .. "('bShowGPNotifications', '" .. tostring(bShowGPNotifications) .. "'),"
  sSaveSQL = sSaveSQL .. "('bShowXPNotifications', '" .. tostring(bShowXPNotifications) .. "'),"
  sSaveSQL = sSaveSQL .. "('iSearchResultLimit', '" .. tostring(iSearchResultLimit) .. "'),"
  sSaveSQL = sSaveSQL .. "('iXPNotificationLimit', '" .. tostring(iXPNotificationLimit) .. "'),"
  sSaveSQL = sSaveSQL .. "('iXPGraphScaling', '" .. tostring(iXPGraphScaling) .. "'),"
  sSaveSQL = sSaveSQL .. "('bPlayGPNotification', '" .. tostring(bPlayGPNotification) .. "'),"
  sSaveSQL = sSaveSQL .. "('sGPNotificationFile', '" .. EscapeSQL(tostring(sGPNotificationFile)) .. "'),"
  sSaveSQL = sSaveSQL .. "('bPlayHPNotification', '" .. tostring(bPlayHPNotification) .. "'),"
  sSaveSQL = sSaveSQL .. "('sHPNotificationFile', '" .. EscapeSQL(tostring(sHPNotificationFile)) .. "'),"
  sSaveSQL = sSaveSQL .. "('sTheme', '" .. EscapeSQL(tostring(sTheme)) .. "'),"
  sSaveSQL = sSaveSQL .. "('sBackgroundImage', '" .. EscapeSQL(tostring(sBackgroundImage)) .. "'),"
  sSaveSQL = string.sub(sSaveSQL, 0, -2)
  assert(dbUserData:execute(sSaveSQL))
  sSaveSQL = "INSERT OR REPLACE INTO core_options (option_id, option_value) VALUES "
  sSaveSQL = sSaveSQL .. "('WINDATA', '" .. EscapeSQL(json.encode(WINDATA)) .. "'),"
  sSaveSQL = sSaveSQL .. "('iWinZOrders', '" .. EscapeSQL(json.encode(iWinZOrders)) .. "'),"
  sSaveSQL = sSaveSQL .. "('winThemeData', '" .. EscapeSQL(json.encode(winThemeData)) .. "'),"
  sSaveSQL = sSaveSQL .. "('SCREENMARGINS', '" .. EscapeSQL(json.encode(SCREENMARGINS)) .. "'),"
  sSaveSQL = sSaveSQL .. "('CUSTOMCOWS', '" .. EscapeSQL(json.encode(CUSTOMCOWS)) .. "'),"
  sSaveSQL = sSaveSQL .. "('MODULES', '" .. EscapeSQL(json.encode(MODULES)) .. "'),"
  sSaveSQL = sSaveSQL .. "('sCOLOUR', '" .. EscapeSQL(json.encode(sCOLOUR)) .. "')," 
  sSaveSQL = sSaveSQL .. "('WINDOWFONTS', '" .. EscapeSQL(json.encode(objWindowFonts)) .. "'),"
  sSaveSQL = sSaveSQL .. "('sMDTCategories', '" .. EscapeSQL(json.encode(sMDTCategories)) .. "'),"
  sSaveSQL = sSaveSQL .. "('objChatFilters', '" .. EscapeSQL(json.encode(objChatFilters)) .. "'),"
  sSaveSQL = sSaveSQL .. "('objChatTabs', '" .. EscapeSQL(json.encode(objChatTabs)) .. "'),"
  sSaveSQL = sSaveSQL .. "('iEnlargedCommsData', '" .. EscapeSQL(json.encode(iEnlargedCommsData)) .. "'),"
  sSaveSQL = sSaveSQL .. "('sSoundPlayShields', '" .. EscapeSQL(json.encode(sSoundPlayShields)) .. "'),"
  sSaveSQL = sSaveSQL .. "('bSoundPlayShields', '" .. EscapeSQL(json.encode(bSoundPlayShields)) .. "'),"
  sSaveSQL = string.sub(sSaveSQL, 0, -2)
  assert(dbUserData:execute(sSaveSQL))
  return ""
end


-- Convert quantity of minutes to textual description with hours
function MinutesToTimeString(iMinutesIn)
  if (iMinutesIn == 0) then
    return "0 mins"
  elseif (iMinutesIn == 1) then
    return "1 min"
  elseif (iMinutesIn < 61) then
    return iMinutesIn .. " mins"
  else
    local iHours = math.floor(iMinutesIn / 60)
    iMinutesIn = iMinutesIn - (iHours * 60)
    return iHours .. "h " .. iMinutesIn .. "m"
  end
end

function QuowBookmarkCompare(a, b)
  return string.lower(a[2]) < string.lower(b[2])
end

-- Comma-separate long numbers
function NumberCommaString(iQuantity)
  local sFormatted = iQuantity
  while true do  
    sFormatted, iK = string.gsub(sFormatted, "^(-?%d+)(%d%d%d)", '%1,%2')
    if (iK == 0) then
      break
    end
  end
  return sFormatted
end

function QuowExplode(div,str) 
  if (div=='') then return false end
  local pos,arr = 0,{}
  -- for each divider found
  for st,sp in function() return string.find(str,div,pos,true) end do
    table.insert(arr,string.sub(str,pos,st-1)) -- Attach chars left of current divider
    pos = sp + 1 -- Jump past current divider
  end
  table.insert(arr,string.sub(str,pos)) -- Attach chars right of last divider
  return arr
end
QuowSplit = utils.split


-- You do NOT need to set the map path any more!
sQuowMapPath = ""
if (GetVariable("sQuowMapPath") ~= nil) then
  sQuowMapPath = GetVariable("sQuowMapPath")
end
-- You do NOT need to set the map path any more!


-- TEMPORARY emergency colours for error messages, before we've loaded the database up for user-colours
sCOLOUR = {["black"] = "black", ["offblack"] = "#090909", ["silver"] = "silver", ["orange"] = "darkorange", ["cyan"] = "cyan", ["white"] = "white", ["green"] = "yellowgreen", ["red"] = "#BC0000", ["grey"] = "gray", ["date"] = "black", ["xp"] = "forestgreen",}
iCOLOUR = {}
for sColourKey, sColourString in pairs(sCOLOUR) do
  iCOLOUR[sColourKey] = ColourNameToRGB(sColourString)
end

-- Grab Mushclient version to check for feature capabilities
iMushclientVersion = GetInfo(72)
if (string.sub(iMushclientVersion, -4) == "-pre") then
  iMushclientVersion = string.sub(iMushclientVersion, 1, -5)
end
iMushclientVersion = tonumber(iMushclientVersion)

-- *******************************************************
-- * Check for automatic \maps\ path in plugin location: *
-- *******************************************************
if (sQuowMapPath == "") then
  sQuowMapPath = ".\\quow_plugins\\maps\\"
  --sQuowMapPath = (GetPluginInfo(sMinimapID, 20)) .. "maps\\"
end
Note("")
ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar Notice:")
ColourNote(sCOLOUR.silver, "", "Plugin loading.  Your \\maps\\ folder is being looked for in this location:")
ColourTell(sCOLOUR.silver, "", "\"")
ColourTell(sCOLOUR.cyan, "", sQuowMapPath)
ColourNote(sCOLOUR.silver, "", "\"")
ColourNote(sCOLOUR.silver, "", "Ensure this is where your maps folder is, if not please correct and reload the plugin!")
Note("")


-- **************************************************
-- * Check if the user has triggers enabled or not: *
-- **************************************************
if (GetCurrentValue("enable_triggers") ~= 1) then
  SetOption ("enable_triggers", 1)
  Note("")
  ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar Notice:")
  ColourNote(sCOLOUR.orange, "", "Your triggers in MUSHclient were disabled.")
  ColourNote(sCOLOUR.silver, "", "Triggers are needed for many features of the plugin to operate.")
  ColourNote(sCOLOUR.silver, "", "The plugin has enabled triggers in your MUSHclient world settings for you, you do not need to do anything!")
  Note("")
end


-- *************************************************
-- * Check if the user has aliases enabled or not: *
-- *************************************************
if (GetCurrentValue("enable_aliases") ~= 1) then
  SetOption ("enable_aliases", 1)
  Note("")
  ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar Notice:")
  ColourNote(sCOLOUR.orange, "", "Your aliases in MUSHclient were disabled.")
  ColourNote(sCOLOUR.silver, "", "Aliases are needed to use the 'minimap' command, or 'help minimap', added by the plugin.")
  ColourNote(sCOLOUR.silver, "", "The plugin has enabled aliases in your MUSHclient world settings for you, you do not need to do anything!")
  Note("")
end


-- ************************************************
-- * Check if the user has timers enabled or not: *
-- ************************************************
if (GetCurrentValue("enable_timers") ~= 1) then
  SetOption ("enable_timers", 1)
  Note("")
  ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar Notice:")
  ColourNote(sCOLOUR.orange, "", "Your timers in MUSHclient were disabled.")
  ColourNote(sCOLOUR.silver, "", "Timers are needed for the XP/hour rate and graphs, GP regen prediction, Disc game date auto updating, and other features.")
  ColourNote(sCOLOUR.silver, "", "The plugin has enabled timers in your MUSHclient world settings for you, you do not need to do anything!")
  Note("")
end

-- **************************************************
-- *  Check if the user has Mushclient 4.99/5.00    *
-- **************************************************
if (iMushclientVersion == 4.99 or iMushclientVersion == 5) then
  Note("")
  ColourNote(sCOLOUR.red, "", "===== Quow's Cow Bar Fatal Error =====")
  ColourNote(sCOLOUR.orange, "", "You are running MUSHclient 4.99 or 5.00!")
  ColourNote(sCOLOUR.silver, "", "MUSHclient 4.99 and 5.00 have a fatal bug in some of their core functions, which prevents Quow's Cow Bar from working!")
  ColourNote(sCOLOUR.silver, "", "Any other version from 4.84 up to 5.03+ should work fine.  Please download a different version from:")
  ColourNote(sCOLOUR.cyan, "", "http://www.gammon.com.au/files/mushclient/?M=D")
  ColourNote(sCOLOUR.red, "", "===== Quow's Cow Bar Fatal Error =====")
  Note("")
end

-- Check if user has the old Xp/HP notices plugin, disable it and tell them to use newer options
if (GetPluginInfo("bff25308e015986ba3b56e2c", 17) ~= nil and GetPluginInfo("bff25308e015986ba3b56e2c", 17) == true) then
  Note("")
  ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar Notice:")
  ColourNote(sCOLOUR.silver, "", "You have the very old and defunct plugin 'Quow XP HP Notices' installed and enabled.")
  ColourNote(sCOLOUR.silver, "", "Quow's Cow Bar has improved options built in that replace this plugin;")
  ColourNote(sCOLOUR.silver, "", "Right click the XP window and select 'Show XP Gain Notification Texts'")
  ColourNote(sCOLOUR.silver, "", "Right click the HP/GP/Burden bar window and select 'Show GP/HP Gain Notification Texts'")
  ColourNote(sCOLOUR.silver, "", "Finally, uninstall/remove the old 'Quow XP HP Notices' plugin!")
  Note("")
end


-- Check if user has the old Xp/HP notices plugin, disable it and tell them to use newer options
if (GetPluginInfo("bff25308e015986fb1a56e3e", 17) ~= nil and GetPluginInfo("bff25308e015986fb1a56e3e", 17) == true) then
  Note("")
  EnablePlugin ("bff25308e015986fb1a56e3e", false)
  ColourNote(sCOLOUR.red, "", "Quow's Cow Bar Notice:")
  ColourNote(sCOLOUR.silver, "", "You have the old standalone 'Quow MapDoorText Parser' installed and enabled.")
  ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar v3.90+ has it's own updated, improved, and integrated version of the old standalone MapDoorText plugin.")
  ColourNote(sCOLOUR.silver, "", "Enable the 'Written-Map Module' from the Disable/Enable Modules sub-menu of the main minimap window.")
  ColourNote(sCOLOUR.silver, "", "Right click the written map window to add, edit, and remove trigger texts, colours, scores etc.")
  ColourNote(sCOLOUR.silver, "", "Finally, uninstall and remove the old 'Quow MapDoorText Parser' plugin!")
  ColourNote(sCOLOUR.red, "", "The old MapDoorText plugin has now been automatically DISABLED!")
  ColourNote(sCOLOUR.silver, "", "If you had any custom edits to it, you need to bring them over to the CowBar through the menus!")
  Note("")
end

-- "Ongoing" version, used for running developments, database updates for the user, etc.
sPluginFullVersion = tostring(GetPluginInfo("bfe35205f026786ea1d56e3b", 19)) -- .. "_a"

-- Prepare plugin variables
sMinimapID = GetPluginID()
winMinimap = sMinimapID .. "minimap"
winMapRender = sMinimapID .. "rendermap"
winInfoMinimap = ""
winMDT = sMinimapID .. "mdt"
winInfoMDT = ""
winBars = sMinimapID .. "bars"
winInfoBars = ""
winStats = sMinimapID .. "stats"
winInfoStats = ""
winXP = sMinimapID .. "xp"
winInfoXP = ""
winShields = sMinimapID .. "shields"
winInfoShields = ""
winComms = sMinimapID .. "comms"
winInfoComms = ""
winAscii = sMinimapID .. "ascii"
winInfoAscii = ""
winHotspots = sMinimapID .. "hotspots"
winInfoHotspots = ""

-- Window key array for loops
objWindows = {
  [winMinimap] = {["sShort"] = "Minimap", ["iNum"] = "1"},
  [winMDT] = {["sShort"] = "MDT", ["iNum"] = "2"},
  [winBars] = {["sShort"] = "Bar", ["iNum"] = "3"},
  [winStats] = {["sShort"] = "Stats", ["iNum"] = "4"},
  [winXP] = {["sShort"] = "XP", ["iNum"] = "5"},
  [winShields] = {["sShort"] = "Shields", ["iNum"] = "6"},
  [winComms] = {["sShort"] = "Comms", ["iNum"] = "7"},
  [winAscii] = {["sShort"] = "Ascii", ["iNum"] = "8"},
  [winHotspots] = {["sShort"] = "Hotspots", ["iNum"] = "9"},
}

-- Default user options - default settings
sUSER_OPTIONS = {
  -- Pick these colours
  ["col_special_prep"] = "#00FF7F",
  ["col_special_fail"] = "#FF6347",
  ["col_special_out_fail"] = "#FF6347",
  ["col_special_out_success"] = "#32CD32",
  ["col_melee_out_fail"] = "#F0E68C",
  ["col_melee_out_success"] = "yellowgreen",
  ["col_melee_out_kill"] = "#D6FFFF",
  ["col_special_inc_fail"] = "#DAA520",
  ["col_special_inc_success"] = "#FF4500",
  ["col_melee_inc_fail"] = "#7A7A57",
  ["col_melee_inc_success"] = "maroon",
  ["col_melee_inc_kill"] = "red",
  ["col_special_third_fail"] = "#3C4669",
  ["col_special_third_success"] = "#3C4420",
  ["col_melee_third_fail"] = "#3C4669",
  ["col_melee_third_success"] = "#3C4420",
  ["col_melee_third_kill"] = "#C7C9C9",
  -- Omit these
  ["omit_special_prep"] = "n",
  ["omit_special_fail"] = "n",
  ["omit_special_out_fail"] = "n",
  ["omit_special_out_success"] = "n",
  ["omit_melee_out_fail"] = "n",
  ["omit_melee_out_success"] = "n",
  ["omit_melee_out_kill"] = "n",
  ["omit_special_inc_fail"] = "n",
  ["omit_special_inc_success"] = "n",
  ["omit_melee_inc_fail"] = "n",
  ["omit_melee_inc_success"] = "n",
  ["omit_melee_inc_kill"] = "n",
  ["omit_special_third_fail"] = "n",
  ["omit_special_third_success"] = "n",
  ["omit_melee_third_fail"] = "n",
  ["omit_melee_third_success"] = "n",
  ["omit_melee_third_kill"] = "n",
  -- Don't colour there
  ["nocol_special_prep"] = 17,
  ["nocol_special_fail"] = 17,
  ["nocol_special_out_fail"] = 17,
  ["nocol_special_out_success"] = 17,
  ["nocol_melee_out_fail"] = 17,
  ["nocol_melee_out_success"] = 17,
  ["nocol_melee_out_kill"] = 17,
  ["nocol_special_inc_fail"] = 17,
  ["nocol_special_inc_success"] = 17,
  ["nocol_melee_inc_fail"] = 17,
  ["nocol_melee_inc_success"] = 17,
  ["nocol_melee_inc_kill"] = 17,
  ["nocol_special_third_fail"] = 17,
  ["nocol_special_third_success"] = 17,
  ["nocol_melee_third_fail"] = 17,
  ["nocol_melee_third_success"] = 17,
  ["nocol_melee_third_kill"] = 17,
  -- Last version run by this user
  ["last_version_run"] = sPluginFullVersion,
  -- For vitals bars
  ["vitals_hp_a"] = 36864,    -- Full HP green  - #009000
  ["vitals_hp_b"] = 56797,    -- Half HP yellow - #DDDD00
  ["vitals_hp_c"] = 255,      -- Low HP red     - #FF0000
  ["vitals_gp_a"] = 15597568, -- Full GP blue   - #0000EE
  ["vitals_gp_b"] = 10027076, -- Half GP blue   - #440099
  ["vitals_gp_c"] = 6684774,  -- Low GP purple  - #660066
  ["vitals_b_a"] = 36864,     -- Burden empty green - #009000
  ["vitals_b_b"] = 56797,     -- Burden half yellow - #DDDD00
  ["vitals_b_c"] = 255,       -- Burden full red - #FF0000
}
iTotalUserOptions = 0
for sKey, sData in pairs(sUSER_OPTIONS) do
  iTotalUserOptions = iTotalUserOptions + 1
end

-- For shield events
sShieldCatTypes = {"self","group"}
sShieldSubTypes = {"tpa","eff","ccc","bug","ms"}
for _, sCatType in ipairs(sShieldCatTypes) do
  for __ , sSubType in ipairs(sShieldSubTypes) do
    sUSER_OPTIONS["nocol_" .. sCatType .. "_" .. sSubType] = 0
    sUSER_OPTIONS["col_" .. sCatType .. "_" .. sSubType] = "darkorange"
  end
end


-- XP Data
iXPGraphPlots = {}
iXPTotalPlots = {}
iXPPerHour = 0
iXPTotalMinutePrevious = nil
iXPTotalMinuteCurrent = nil
iXPHighestPlot = 0
iXPPastHour = 0
iXPTotalRecordedIncoming = 0
iXPMinutesRecordedTotal = 0

-- Misc global variables
bLastRoomFailGMCP = true
sOldRoomID = ""
sThisRoomType = ""
iThisRoomTerrain = ""
bCreatingRooms = false
bIgnoreExits = true
sQuowLocationsByRoomID = {}

sItemDBItems = {}
sItemDBShopItems = {}
sNPCs = {}
sItemDBNPCItems = {}

sQuowExitsByID = {}
sQuowExitsByExit = {}
sQuowUserBookmarks = {}
sSortedBookmarks = {}
sSortedBookmarkRoomID = {}
iQuowCombatStats = {}
iQuowSetNameID = {}
-- Hotspots, none by default
sHotspotData = {}
-- MDT data
sMDTData = {}
iTotalMDT = 0
-- Handle this hotspot - either make new triggers or room-ID-tags as needed
iQuowHotspotRoomIDLeave = {}
iQuowHotspotRoomIDEnter = {}
sHotspotSortedOrder = {}
-- Temp combat set
iEmergencyCombatStatSet = 0

-- Check folder location and database file
sDatabaseFile = sQuowMapPath .. "_quowmap_database.db"

iDBAttempts = 0
iDBStatus = DatabaseOpen("dbMap", sDatabaseFile, 1)

-- *************************************************
-- * Check on, load, import, create databases etc. *
-- *************************************************
while (iDBStatus ~= 0 and iDBAttempts < 2) do
  DatabaseClose("dbMap")
  iDBAttempts = iDBAttempts + 1
  ColourNote(sCOLOUR.red, "", "Quow's Cow Bar Fatal Error:")
  ColourNote(sCOLOUR.orange, "", "Unable to find/load the room database file '_quowmap_database.db' in:")
  ColourNote(sCOLOUR.cyan, "", sQuowMapPath)
  ColourNote(sCOLOUR.orange, "", "Please navigate to and select the folder in the popup window!")
  sNewMapPath = utils.directorypicker("Fatal Error!\nCannot find Quow's Cow Bar database!\nPlease locate your \\maps\\ folder:", "")
  if (sNewMapPath ~= nil) then
    sQuowMapPath = sNewMapPath .. "\\"
  end
  sDatabaseFile = sQuowMapPath .. "_quowmap_database.db"
  iDBStatus = DatabaseOpen("dbMap", sDatabaseFile, 1)
end
if (iDBAttempts > 0) then
  Note("")
  ColourNote(sCOLOUR.red, "", "Quow's Cow Bar Notice:")
  ColourNote(sCOLOUR.orange, "", "Your \\maps\\ folder has been successfully set to this location:")
  ColourNote(sCOLOUR.cyan, "", sQuowMapPath)
end

-- Debug mode MOSTLY just for Quow - for example to help building the NPC/item database, or certain tests.
-- Do not recommend you to use this unless you've checked what else through the code this affects and are ok with it all!
bDebugMode = false
if (GetVariable("bDebugMode") == "true") then
  bDebugMode = true
end
-- Close the map database - help check it exists etc.
DatabaseClose("dbMap")
local TSA = true
if (GetVariable("TSA") == "false") then
  TSA = false
end
if (iDBStatus ~= 0) then
  Note("")
  ColourNote(sCOLOUR.red, "", "===== Quow's Cow Bar Fatal Error =====")
  ColourNote(sCOLOUR.orange, "", "Unable to find/load the room database file '_quowmap_database.db' in your \\maps\\ folder!")
  ColourNote(sCOLOUR.silver, "", "Please ensure you have downloaded the full Minimap.zip file, and extracted ALL the contents to a folder.")
  ColourNote(sCOLOUR.silver, "", "Ensure it contains a \\maps\\ folder containing 63 .png files, 5 .wav files, and IMPORTANTLY the _quowmap_database.db database file!")
  ColourNote(sCOLOUR.silver, "", "The plugin is now exiting and will not run.")
  ColourNote(sCOLOUR.red, "", "Reinstall the Cow Bar plugin once you have corrected this.")
  ColourNote(sCOLOUR.red, "", "===== Quow's Cow Bar Fatal Error =====")
  Note("")
  -- Os.exit is not available in Mushclient, so this is a sneaky way to force-crash the plugin and exit it with errors.
  os.exit()
else
  dbMap = assert(sqlite3.open(sDatabaseFile))
  for row in dbMap:nrows("SELECT room_id, map_id, xpos, ypos, room_short, room_type FROM rooms") do
    sQuowLocationsByRoomID[row.room_id] = {row.map_id, row.xpos, row.ypos, row.room_short, row.room_type}
    sQuowExitsByID[row.room_id] = {}
    sQuowExitsByExit[row.room_id] = {}
  end
  for row in dbMap:nrows("SELECT room_id, connect_id, exit FROM room_exits") do
    if (sQuowExitsByID[row.room_id] ~= nil and sQuowExitsByID[row.connect_id] ~= nil) then
      sQuowExitsByID[row.room_id][row.connect_id] = row.exit
      sQuowExitsByExit[row.room_id][row.exit] = row.connect_id
    end
  end
  -- Raw item data
  for row in dbMap:nrows("SELECT item_name, description, appraise_text, weight, dollar_value, searchable, special_find_note FROM items") do
    sItemDBItems[row.item_name] = {
      ["description"] = row.description,
      ["appraise_text"] = row.appraise_text,
      ["weight"] = row.weight,
      ["dollar_value"] = row.dollar_value,
      ["searchable"] = row.searchable,
      ["special_find_note"] = row.special_find_note,
    }
  end
  -- Shop sale items
  for row in dbMap:nrows("SELECT room_id, item_name, sale_price FROM shop_items") do
    if (sItemDBShopItems[row.room_id] == nil) then
      sItemDBShopItems[row.room_id] = {}
    end
    sItemDBShopItems[row.room_id][row.item_name] = row.sale_price
  end
  -- NPC raw data
  for row in dbMap:nrows("SELECT npc_id, map_id, npc_name, room_id FROM npc_info") do
    sNPCs[row.npc_id] = {["map_id"] = row.map_id, ["npc_name"] = row.npc_name, ["roomid"] = row.room_id}
  end
  -- NPC items
  for row in dbMap:nrows("SELECT npc_id, item_name, sale_price FROM npc_items") do
    if (sItemDBNPCItems[row.npc_id] == nil) then
      sItemDBNPCItems[row.npc_id] = {}
    end
    sItemDBNPCItems[row.npc_id][row.item_name] = row.sale_price
  end
  dbUserData = assert(sqlite3.open(sQuowMapPath .. "_quowmap_userdata.db"))
  -- Replacement for MUSHclient's get and set variable systems
  sSQL = "CREATE TABLE IF NOT EXISTS core_options (option_id TEXT NOT NULL,option_value TEXT NOT NULL,PRIMARY KEY (option_id))"
  assert(dbUserData:execute(sSQL))
  -- Cache all the core data up-front
  for row in dbUserData:nrows("SELECT option_id, option_value FROM core_options") do
    sCoreGetCache[row.option_id] = row.option_value
  end
  -- User options (colours for combat messages etc.
  sSQL = "CREATE TABLE IF NOT EXISTS user_options (option_id TEXT NOT NULL,option_value TEXT NOT NULL,PRIMARY KEY (option_id))"
  assert(dbUserData:execute(sSQL))
  local iTotalOptionsFound = 0
  local bOptionsFound = {}
  for row in dbUserData:nrows("SELECT option_id, option_value FROM user_options") do
    sUSER_OPTIONS[row.option_id] = row.option_value
    bOptionsFound[row.option_id] = true
    iTotalOptionsFound = iTotalOptionsFound + 1
  end

  -- Hotspots user table
  sSQL = [[CREATE TABLE IF NOT EXISTS user_hotspots (
hotspot_id INTEGER NOT NULL,
hotspot_name TEXT NOT NULL DEFAULT '',
colour INT NOT NULL DEFAULT '12632256',
trigger_type INT NOT NULL DEFAULT '0',
roomid_reset TEXT NOT NULL DEFAULT '',
trigger_reset TEXT NOT NULL DEFAULT '',
time_seen INTEGER NOT NULL DEFAULT '0',
timeafter_notify INTEGER NOT NULL DEFAULT '0',
notified INTEGER NOT NULL DEFAULT '0',
PRIMARY KEY (hotspot_id)
)]]
  assert(dbUserData:execute(sSQL))
  for row in dbUserData:nrows("SELECT hotspot_id, hotspot_name, colour, trigger_type, roomid_reset, trigger_reset, time_seen, timeafter_notify, notified FROM user_hotspots") do
    sHotspotData[row.hotspot_id] = {["hotspot_name"] = row.hotspot_name, ["colour"] = row.colour, ["trigger_type"] = row.trigger_type, ["roomid_reset"] = row.roomid_reset, ["trigger_reset"] = row.trigger_reset, ["time_seen"] = row.time_seen, ["timeafter_notify"] = row.timeafter_notify, ["notified"] = row.notified}
  end
  -- Insert any missing user options into the table
  if (iTotalOptionsFound < iTotalUserOptions) then
    sSQL = "INSERT INTO user_options (option_id, option_value) VALUES "
    for sOptionKey, sOptionValue in pairs(sUSER_OPTIONS) do
      if (bOptionsFound[sOptionKey] == nil) then
        sSQL = sSQL .. "('" .. sOptionKey .. "', '" .. EscapeSQL(sOptionValue) .. "'),"
      end
    end
    sSQL = string.sub(sSQL, 1, -2)
    assert(dbUserData:execute(sSQL))
  end

  -- MDT user table
  sSQL = [[CREATE TABLE IF NOT EXISTS user_mdt (
mdt_id INTEGER NOT NULL,
match_text TEXT NOT NULL DEFAULT '',
category TEXT NOT NULL DEFAULT '',
colour INT NOT NULL DEFAULT '12632256',
score INT NOT NULL DEFAULT '1',
matchtype INT NOT NULL DEFAULT '0',
map_region INT NOT NULL DEFAULT '0',
PRIMARY KEY (mdt_id)
)]]
  assert(dbUserData:execute(sSQL))
  iTotalMDT = 0
  for row in dbUserData:nrows("SELECT mdt_id, match_text, category, colour, score, matchtype, map_region FROM user_mdt") do
    iTotalMDT = iTotalMDT + 1
    sMDTData[row.mdt_id] = {["match_text"] = row.match_text, ["category"] = row.category, ["colour"] = row.colour, ["score"] = row.score, ["matchtype"] = row.matchtype, ["map_region"] = row.map_region}
    -- Convert to a regex object in advance, if needed
    if (row.matchtype == 1) then
      sMDTData[row.mdt_id]["regex"] = rex.new(row.match_text)
    end
  end

  -- User bookmarks
  sSQL = "CREATE TABLE IF NOT EXISTS bookmarks (room_id TEXT NOT NULL,note TEXT NOT NULL,PRIMARY KEY (room_id))"
  assert(dbUserData:execute(sSQL))
  for row in dbUserData:nrows("SELECT room_id, note FROM bookmarks") do
    if (sQuowLocationsByRoomID[row.room_id] ~= nil) then
      if (row.note == "") then
        row.note = sQuowLocationsByRoomID[row.room_id][4]
      end
      sQuowUserBookmarks[row.room_id] = row.note
      table.insert(sSortedBookmarks, {row.room_id, row.note})
    end
  end
  table.sort(sSortedBookmarks, QuowBookmarkCompare)

  -- Create the database table if this is a first run
  sSQL = [[CREATE TABLE IF NOT EXISTS combat_stats (
set_id INTEGER NOT NULL,
set_name TEXT NOT NULL DEFAULT '',
gp_regen INTEGER NOT NULL DEFAULT '3',
rounds_total INTEGER NOT NULL DEFAULT '0',
kills_total INTEGER NOT NULL DEFAULT '0',
deaths_total INTEGER NOT NULL DEFAULT '0',
special_out_prepared INTEGER NOT NULL DEFAULT '0',
special_out_failprepared INTEGER NOT NULL DEFAULT '0',
hits_out_total INTEGER NOT NULL DEFAULT '0',
hits_out_landed INTEGER NOT NULL DEFAULT '0',
hits_out_zonefail INTEGER NOT NULL DEFAULT '0',
hits_out_defended INTEGER NOT NULL DEFAULT '0',
special_out_landed INTEGER NOT NULL DEFAULT '0',
special_out_defended INTEGER NOT NULL DEFAULT '0',
hits_out_defended_dodged INTEGER NOT NULL DEFAULT '0',
hits_out_defended_dodged_barely INTEGER NOT NULL DEFAULT '0',
hits_out_defended_dodged_normal INTEGER NOT NULL DEFAULT '0',
hits_out_defended_dodged_deftly INTEGER NOT NULL DEFAULT '0',
hits_out_defended_dodged_somehow INTEGER NOT NULL DEFAULT '0',
hits_out_defended_parried INTEGER NOT NULL DEFAULT '0',
hits_out_defended_parried_barely INTEGER NOT NULL DEFAULT '0',
hits_out_defended_parried_normal INTEGER NOT NULL DEFAULT '0',
hits_out_defended_parried_deftly INTEGER NOT NULL DEFAULT '0',
hits_out_defended_blocked INTEGER NOT NULL DEFAULT '0',
hits_out_defended_blocked_barely INTEGER NOT NULL DEFAULT '0',
hits_out_defended_blocked_normal INTEGER NOT NULL DEFAULT '0',
hits_out_defended_blocked_deftly INTEGER NOT NULL DEFAULT '0',
hits_out_armoured INTEGER NOT NULL DEFAULT '0',
hits_out_tpa INTEGER NOT NULL DEFAULT '0',
hits_out_bugs INTEGER NOT NULL DEFAULT '0',
hits_out_major INTEGER NOT NULL DEFAULT '0',
hits_out_ccc INTEGER NOT NULL DEFAULT '0',
hits_out_eff INTEGER NOT NULL DEFAULT '0',
hits_inc_total INTEGER NOT NULL DEFAULT '0',
hits_inc_landed INTEGER NOT NULL DEFAULT '0',
hits_inc_zonefail INTEGER NOT NULL DEFAULT '0',
special_inc_landed INTEGER NOT NULL DEFAULT '0',
special_inc_defended INTEGER NOT NULL DEFAULT '0',
hits_inc_defended INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_dodged INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_dodged_barely INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_dodged_normal INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_dodged_deftly INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_dodged_somehow INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_parried INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_parried_barely INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_parried_normal INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_parried_deftly INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_blocked INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_blocked_barely INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_blocked_normal INTEGER NOT NULL DEFAULT '0',
hits_inc_defended_blocked_deftly INTEGER NOT NULL DEFAULT '0',
hits_inc_armoured INTEGER NOT NULL DEFAULT '0',
hits_inc_tpa INTEGER NOT NULL DEFAULT '0',
hits_inc_bugs INTEGER NOT NULL DEFAULT '0',
hits_inc_major INTEGER NOT NULL DEFAULT '0',
hits_inc_ccc INTEGER NOT NULL DEFAULT '0',
hits_inc_eff INTEGER NOT NULL DEFAULT '0',
PRIMARY KEY (set_id)
)]]
  assert(dbUserData:execute(sSQL))
  -- Now load in all the sets and stats
  for row in dbUserData:nrows("SELECT * FROM combat_stats") do
    iQuowCombatStats[row.set_id] = {}
    for sStatName, sStatValue in pairs(row) do
      if (sStatName ~= "set_id") then
        if (sStatName ~= "set_name") then
          iQuowCombatStats[row.set_id][sStatName] = tonumber(sStatValue)
        else
          iQuowCombatStats[row.set_id][sStatName] = sStatValue
          iQuowSetNameID[sStatValue] = row.set_id
        end
      end
    end
    if (iEmergencyCombatStatSet == 0) then
      iEmergencyCombatStatSet = row.set_id
    end
  end

  -- Do necessary database updates when detecting a version upgrade
  if (sUSER_OPTIONS["last_version_run"] ~= sPluginFullVersion) then
    -- Missing zonefail column, add it in
    if (iQuowCombatStats[1]["hits_inc_zonefail"] == nil) then
      Tell("[updating database columns] ")
      -- Do stuff based on their previous version number
      assert(dbUserData:execute("ALTER TABLE combat_stats ADD COLUMN hits_inc_zonefail INTEGER NOT NULL DEFAULT '0'"))
      assert(dbUserData:execute("ALTER TABLE combat_stats ADD COLUMN hits_out_zonefail INTEGER NOT NULL DEFAULT '0'"))

      for iThisStatSet, _ in pairs(iQuowCombatStats) do
        iQuowCombatStats[iThisStatSet]["hits_inc_zonefail"] = 0
        iQuowCombatStats[iThisStatSet]["hits_out_zonefail"] = 0
      end
    end

    -- Update their stored Cow Var version
    assert(dbUserData:execute("UPDATE user_options SET option_value='" .. sPluginFullVersion .. "' where option_id='last_version_run'"))
    ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar plugin has been updated from an old version (" .. sUSER_OPTIONS["last_version_run"] .. " to " .. sPluginFullVersion .. ").  Thank you for updating!")
    sUSER_OPTIONS["last_version_run"] = sPluginFullVersion
  end

end

-- Core Colour-Theme
sTheme = GetSQLVariable("sTheme")
if (sTheme == nil) then
  sTheme = "default"
end
sBackgroundImage = GetSQLVariable("sBackgroundImage")
if (sBackgroundImage == nil) then
  sBackgroundImage = ""
end
SetBackgroundImage(sBackgroundImage, 0)

-- *************************************
-- ***** Preset Global colour codes ****
-- *************************************
-- These are now pulled in from user data, and can be changed by right-clicking the graphical map window
sCOLOUR = {}
sGetTempVariable = GetSQLVariable("sCOLOUR")
if (sGetTempVariable ~= nil) then
  sCOLOUR = json.decode(sGetTempVariable)
  -- Make sure we definitely have every colour available in case of player-setting corruptions
  if (sCOLOUR["black"] == nil) then sCOLOUR["black"] = "black" end
  if (sCOLOUR["offblack"] == nil) then sCOLOUR["offblack"] = "#090909" end
  if (sCOLOUR["silver"] == nil) then sCOLOUR["silver"] = "silver" end
  if (sCOLOUR["orange"] == nil) then sCOLOUR["orange"] = "darkorange" end
  if (sCOLOUR["cyan"] == nil) then sCOLOUR["cyan"] = "cyan" end
  if (sCOLOUR["white"] == nil) then sCOLOUR["white"] = "white" end
  if (sCOLOUR["green"] == nil) then sCOLOUR["green"] = "yellowgreen" end
  if (sCOLOUR["red"] == nil) then sCOLOUR["red"] = "#BC0000" end
  if (sCOLOUR["grey"] == nil) then sCOLOUR["grey"] = "gray" end
  if (sCOLOUR["date"] == nil) then sCOLOUR["date"] = "black" end
  if (sCOLOUR["xp"] == nil) then sCOLOUR["xp"] = sCOLOUR["green"] end
else
  sCOLOUR = {
    ["black"] = "black",
    ["offblack"] = "#090909",
    ["silver"] = "silver",
    ["orange"] = "darkorange",
    ["cyan"] = "cyan",
    ["white"] = "white",
    ["green"] = "yellowgreen",
    ["red"] = "#BC0000",
    ["grey"] = "gray",
    ["date"] = "black",
    ["xp"] = "forestgreen",
  }
end
iCOLOUR = {}
for sColourKey, sColourString in pairs(sCOLOUR) do
  iCOLOUR[sColourKey] = ColourNameToRGB(sColourString)
end
-- Alternating colours for search result ease of seeing
sAlternatingColour = sCOLOUR["black"]
iAlternatingColour = iCOLOUR["black"]

-- *************************************
-- ***** Desired GMCP Data Requested ***
-- *************************************
-- GMCP Character stats request
bRequestCharVitals = true
if (GetSQLVariable("bRequestCharVitals") == "false") then
  bRequestCharVitals = false
end
-- NOTE:  If you want your own plugins to received MXP character vitals, either set the above to false and reconnect, OR:
-- Use the "OnPluginBroadcast" feature in your own plugin and you can tap into the GMCP char.vitals sent by this plugin instead
-- GMCP Written-Room-Map request
bRequestWrittenMap = true
if (GetSQLVariable("bRequestWrittenMap") == "false") then
  bRequestWrittenMap = false
end
-- GMCP Room-ASCII-Map request
bRequestRoomMap = true
if (GetSQLVariable("bRequestRoomMap") == "false") then
  -- Commented out as v2.06+ *NEEDS* this for ascii map to read properly
  --bRequestRoomMap = false
end

-- Screenreader mode
bScreenreader = false
if (GetSQLVariable("bScreenreader") == "true") then
  bScreenreader = true
end

-- Get chat window filter options
objChatFilters = {}
iChatExtraChannels = 0
OST = os.time
BDC = utils.base64decode
BEC = utils.base64encode
-- Self-shield text chat alerts
bSelfShieldChats = false
if (GetSQLVariable("bSelfShieldChats") == "true") then
  bSelfShieldChats = true
end
-- Group-shield text chat alerts
bGroupShieldChats = false
if (GetSQLVariable("bGroupShieldChats") == "true") then
  bGroupShieldChats = true
end
-- Show item values by default
bShowItemValues = false
if (GetSQLVariable("bShowItemValues") == "true") then
  bShowItemValues = true
end
-- Which chat-channel are we clicked on
iCurrentChannelChoice = tonumber(GetSQLVariable("iCurrentChannelChoice"))
if (iCurrentChannelChoice == nil) then
  iCurrentChannelChoice = 1
end
sGetTempVariable = GetSQLVariable("objChatFilters")
if (sGetTempVariable ~= nil) then
  objChatFilters = json.decode(sGetTempVariable)
else
  objChatFilters = {
    ["Tells_In"] = {true, true, false},
    ["Tells_Out"] = {true, true, false},
    ["Group_Say"] = {true, true, false},
    ["One"] = {true, true, false},
    ["newbie"] = {true, true, false},
    ["cre"] = {true, true, false},
    ["special"] = {true, true, false},
  }
end
-- For norooms option
bCreatingActualNewRooms = true
if (GetSQLVariable("bCreatingActualNewRooms") == "false") then
  bCreatingActualNewRooms = false
end

-- For enlarged comms window save-state
sGetTempVariable = GetSQLVariable("iEnlargedCommsData")
if (sGetTempVariable ~= nil) then
  iEnlargedCommsData = json.decode(sGetTempVariable)
else
  iEnlargedCommsData = {["ENABLED"] = false}
end

-- And the user tabs
objChatTabs = {}
sGetTempVariable = GetSQLVariable("objChatTabs")
if (sGetTempVariable ~= nil) then
  objChatTabs = json.decode(sGetTempVariable)
else
  objChatTabs = {
    [1] = {"All", {"*All*"}},
    [2] = {"Tells", {"Tells_In", "Tells_Out"}},
    [3] = {"Group", {"Group_Say"}},
    [4] = {"Talkers", {"*Talkers*"}},
    [5] = {"One", {"One"}},
  }
end

iCommsMessagesCurrentlyShown = 0
iCommsCountByType = {}
for sKey, sData in pairs(objChatFilters) do
  iCommsCountByType[sKey] = 0
  iChatExtraChannels = iChatExtraChannels + 1
end

-- For font database
objAvailableFonts = {}

-- Font data per-window
objWindowFonts = {}
sGetTempVariable = GetSQLVariable("WINDOWFONTS")
if (sGetTempVariable ~= nil) then
  objWindowFonts = json.decode(sGetTempVariable)
end
iFontSizes = {}
-- Set default values for core/primary windows
if (objWindowFonts[winMinimap] == nil) then
  objWindowFonts[winMinimap] = {["body"] = "FixedSys", ["size"] = 8,}
end
if (objWindowFonts[winMDT] == nil) then
  objWindowFonts[winMDT] = {["body"] = "FixedSys", ["size"] = 8,}
end
if (objWindowFonts[winBars] == nil) then
  objWindowFonts[winBars] = {["body"] = "Dina", ["size"] = 9, ["sizem"] = 12, ["sizel"] = 15,}
end
if (objWindowFonts[winStats] == nil) then
  objWindowFonts[winStats] = {["body"] = "Dina", ["size"] = 8, ["sizem"] = 11, ["sizel"] = 14,}
end
if (objWindowFonts[winXP] == nil) then
  objWindowFonts[winXP] = {["body"] = "Dina", ["size"] = 9, ["sizem"] = 12, ["sizel"] = 15,}
end
if (objWindowFonts[winShields] == nil) then
  objWindowFonts[winShields] = {["body"] = "Dina", ["size"] = 8, ["sizem"] = 11, ["sizel"] = 14,}
end
if (objWindowFonts[winComms] == nil) then
  objWindowFonts[winComms] = {["body"] = "FixedSys", ["size"] = 8,}
end
if (objWindowFonts[winAscii] == nil) then
  objWindowFonts[winAscii] = {["body"] = "FixedSys", ["size"] = 8}
end
if (objWindowFonts[winHotspots] == nil) then
  objWindowFonts[winHotspots] = {["body"] = "FixedSys", ["size"] = 8,}
end
-- Window Z-Ordering, for function ReorderWindows
iWinZOrders = {}
sGetTempVariable = GetSQLVariable("iWinZOrders")
if (sGetTempVariable ~= nil) then
  iWinZOrders = json.decode(sGetTempVariable)
else
  iWinZOrders = {
    [9] = {9, winMinimap},
    [8] = {8, winBars},
    [7] = {7, winComms},
    [6] = {6, winXP},
    [5] = {5, winShields},
    [4] = {4, winHotspots},
    [3] = {3, winMDT},
    [2] = {2, winAscii},
    [1] = {1, winStats},
  }
end
-- Get all the window size data decompiled
WINDATA = {}
sGetTempVariable = GetSQLVariable("WINDATA")
if (sGetTempVariable ~= nil) then
  WINDATA = json.decode(sGetTempVariable)
end
iThemeLayoutLocked = tonumber(GetSQLVariable("iThemeLayoutLocked"))
if (iThemeLayoutLocked == nil) then
  if (bScreenreader == false) then
    iThemeLayoutLocked = 11
  else
    iThemeLayoutLocked = 14
  end
end
-- Set default values for core/primary windows
if (WINDATA[winMinimap] == nil) then
  WINDATA[winMinimap] = {["WIDTH"] = 250, ["HEIGHT"] = 250, ["SHOW"] = true, ["LOCKED"] = false}
end
if (WINDATA[winMDT] == nil) then
  WINDATA[winMDT] = {["WIDTH"] = 400, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
end
if (WINDATA[winBars] == nil) then
  WINDATA[winBars] = {["WIDTH"] = 190, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
end
if (WINDATA[winStats] == nil) then
  WINDATA[winStats] = {["WIDTH"] = 190, ["HEIGHT"] = 220, ["SHOW"] = true, ["LOCKED"] = false}
end
if (WINDATA[winXP] == nil) then
  WINDATA[winXP] = {["WIDTH"] = 190, ["HEIGHT"] = 180, ["SHOW"] = true, ["LOCKED"] = false}
end
if (WINDATA[winShields] == nil) then
  WINDATA[winShields] = {["WIDTH"] = 190, ["HEIGHT"] = 180, ["SHOW"] = true, ["LOCKED"] = false}
end
if (WINDATA[winComms] == nil) then
  WINDATA[winComms] = {["WIDTH"] = 400, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
end
if (WINDATA[winAscii] == nil) then
  WINDATA[winAscii] = {["WIDTH"] = 80, ["HEIGHT"] = 80, ["SHOW"] = true, ["LOCKED"] = false}
end
if (WINDATA[winHotspots] == nil) then
  WINDATA[winHotspots] = {["WIDTH"] = 300, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
end
-- Error checking for corruption
MFL = math.floor
bWindowErrors = false
sFatalErrorList = ""
for iKey, sData in pairs(WINDATA) do
  if (sData["WIDTH"] < 5) then
    WINDATA[iKey]["WIDTH"] = 50
    bWindowErrors = true
    sFatalErrorList = sFatalErrorList .. tostring(iKey) .. "-W,"
  end
  if (sData["HEIGHT"] < 5) then
    WINDATA[iKey]["HEIGHT"] = 50
    bWindowErrors = true
    sFatalErrorList = sFatalErrorList .. tostring(iKey) .. "-H,"
  end
end
if (bWindowErrors == true and bScreenreader == false) then
  Note("At least one window had a corrupted size of below 5, and has been reset by the Cow Bar to prevent fatal errors [" .. sFatalErrorList .. "]")
  Note("You can reset all miniwindows back to default positions with 'minimap reset', or by choosing an 'Instant Layout' in right click menus.")
end

-- GMCP-TTL
TCBL = GetSQLVariable("TCBL")
if (TCBL == nil) then
  TCBL = 0
end

-- Pre-prepped measurements for speed
MINIMAP_WIDTH = 0
MINIMAP_HEIGHT = 0
MINIMAP_X=0
MINIMAP_Y=0
MINIMAP_CX=0
MINIMAP_CY=0

-- Character vitals array, with default values instead of allowing "nil"s on initialisation
iCharVitals = {["maxgp"] = -1, ["burden"] = -1, ["gp"] = -1, ["maxhp"] = -1, ["xp"] = 0, ["hp"] = -1, ["alignment"] = "Alignment"}
iCharOldVitals = {["maxgp"] = -1, ["burden"] = -1, ["gp"] = -1, ["maxhp"] = -1, ["xp"] = 0, ["hp"] = -1, ["alignment"] = "Alignment"}

-- Shields and group data
sMyPlayerName = GetSQLVariable("sMyPlayerName")
if (sMyPlayerName == nil) then
  sMyPlayerName = ""
end
iTotalGroupMembers = 1
sGroupMembers = {
  ["You"] = {["HP"] = 0, ["GP"] = 0, ["TPA"] = 0, ["CCC"] = 0, ["EFF"] = 0, ["BUG"] = 0, ["MS"] = 0, ["MemberSince"] = 0, ["Kills"] = 0, },
}

-- GMDbg
TACR = GetSQLVariable("TACR")
if (TACR == nil) then
  TACR = 0
end

-- Change core colour themes and do all the appropriate re-colourings, brightnesses, redrawing etc.
winThemeData = {}
sGetTempVariable = GetSQLVariable("winThemeData")
if (sGetTempVariable ~= nil) then
  winThemeData = json.decode(sGetTempVariable)
  -- Missing selectface from v4.0 to v4.01?
  if (winThemeData.SELECTFACE == nil) then
    winThemeData.SELECTFACE = winThemeData.FACE
  end
  -- Missing main-frame colour enabled in MUSH 5.07+?
  if (winThemeData.MAINFRAME == nil) then
    winThemeData.MAINFRAME = 0xFFFFFFFF
  end
end
-- Default theme data for new installs/missing values
sDefaultThemeData = {
  WINDOW_BORDER = ColourNameToRGB("#E8E8E8"), -- for miniwindow body
  HIGHLIGHT=ColourNameToRGB("#FFFFFF"), -- 3d panel top-left highlights
  INNERSHADOW=ColourNameToRGB("#808080"), -- 3d panel bottom-right inner mid
  OUTERSHADOW = ColourNameToRGB("#404040"), -- 3d panel bottom-right dark
  FACE=ColourNameToRGB("#D4D0C8"), -- for 3D surfaces
  ONFACE=ColourNameToRGB("#000000"), -- for text on 3D surfaces
  TEXTSHADOW=ColourNameToRGB("black"), -- for text-shadowing (eg HP bars)
  BACK_FACE = ColourNameToRGB("#E8E8E8"), -- for scrollbar back
  DETAIL = ColourNameToRGB("#000000"), -- for scrollbar lines
  TITLE_HEIGHT = 17, -- for miniwindow title area
  TITLE_FONT_NAME = "Dina", -- for miniwindow title area
  TITLE_FONT_SIZE = 8, -- for miniwindow title area
  SELECTFACE = ColourNameToRGB("#D4D0C8"), -- for selected chat tab
  MAINFRAME = 0xFFFFFFFF, -- MUSHclient main window background colour
}
-- Check if anything is missing from user's custom theme (eg new additions)
for sThemeType, sThemeData in pairs(sDefaultThemeData) do
  if (winThemeData[sThemeType] == nil) then
    winThemeData[sThemeType] = sThemeData
  end
end
sDefaultThemeData = nil
-- If our version supports it, set mainframe background colour
if (iMushclientVersion >= 5.07) then
  SetFrameBackgroundColour(winThemeData.MAINFRAME)
end

-- Change themes to some pre-set/pre-designed colour themes
function ChangeColourTheme(sDoColourTheme)
  local sColoursImport = ""
  if (sDoColourTheme == "darkmode") then
    sColoursImport = '{"W":["#343536","#343536","#343536","#343536","#272729","#D7DADC","#030303","#383934","#555652","#48484F",""],"C":{"silver":"#C0C0C0","cyan":"#00DED1","grey":"#747050","offblack":"#0B0B0B","black":"#030303","green":"#A6E22D","white":"#272729","orange":"#EA7120","red":"#D81717","date":"#D7DADC","xp":"#7F7F7F"}}'
  elseif (sDoColourTheme == "redmode") then
    sColoursImport = '{"W":["red","#FF2F34","#CF3034","#FF0006","#7C1D1F","#D7DADC","#030303","#3F2E2E","#6F393A","#451011",""],"C":{"silver":"crimson","cyan":"#FFB62F","grey":"#747050","offblack":"#25170E","black":"#30070B","green":"lime","white":"#451011","orange":"orangered","red":"red","date":"#D7DADC","xp":"#FF0000"}}'
  elseif (sDoColourTheme == "greymode") then
    sColoursImport = '{"W":["#6D6E6A","#C4C5C3","gray","#404040","#42433E","#989898","#272923","#383934","#555652","#2B2B28",""],"C":{"silver":"#989898","cyan":"#2767B0","grey":"#747050","offblack":"#151515","black":"#272923","green":"#A6E22D","white":"#2B2B28","orange":"#F88A12","red":"#CE0000","date":"#989898","xp":"#DCDCDC"}}'
  elseif (sDoColourTheme == "greenmode") then
    sColoursImport = '{"W":["lawngreen","greenyellow","limegreen","chartreuse","darkolivegreen","#D7DADC","#030303","#383934","#555652","#2F692C",""],"C":{"silver":"chartreuse","cyan":"#2767B0","grey":"#747050","offblack":"#112F12","black":"#0C230F","green":"lime","white":"#2F692C","orange":"lawngreen","red":"#D81717","date":"#D7DADC","xp":"lime"}}'
  elseif (sDoColourTheme == "bluemode") then
    sColoursImport = '{"W":["#01B7FC","#2FFFB1","#32A7CD","#00FFF2","#2D696C","#D7DDDD","#030303","#323A3A","#505858","#3A858B",""],"C":{"silver":"#00ECFF","cyan":"#E633FF","date":"#D7DDDC","grey":"#4D7776","offblack":"#11272F","black":"#0C1E23","green":"#00F2FF","white":"#2C5B69","xp":"aqua","orange":"#00EAFD","red":"red"}}'
  elseif (sDoColourTheme == "lightmode") then
    sColoursImport = '{"W":["#5F99CF","#5F99CF","#5F99CF","#5F99CF","#D4D0C8","black","black","#E8E8E8","black","#ECEAE6",""],"C":{"silver":"#383838","cyan":"cyan","grey":"gray","offblack":"#1B1C17","black":"#EEEEEE","green":"#24811F","white":"#ECEAE6","orange":"darkorange","red":"#BC0000","date":"black","xp":"#24811F"}}'
  elseif (sDoColourTheme == "default") then
    sColoursImport = '{"W":["#E8E8E8","white","gray","#404040","#D4D0C8","black","black","#E8E8E8","black","#D4D0C8",""],"C":{"silver":"silver","cyan":"cyan","grey":"gray","offblack":"#090909","black":"black","green":"yellowgreen","white":"white","orange":"darkorange","red":"#BC0000","date":"black","xp":"forestgreen"}}'
  end
  -- Now handle the data packet of colours
  if (sColoursImport ~= "") then
    local objImportedColours = json.decode(sColoursImport)
    winThemeData.WINDOW_BORDER = ColourNameToRGB(objImportedColours["W"][1]) -- for miniwindow body
    winThemeData.HIGHLIGHT = ColourNameToRGB(objImportedColours["W"][2]) -- 3d panel top-left highlights
    winThemeData.INNERSHADOW = ColourNameToRGB(objImportedColours["W"][3]) -- 3d panel bottom-right inner mid
    winThemeData.OUTERSHADOW = ColourNameToRGB(objImportedColours["W"][4]) -- 3d panel bottom-right dark
    winThemeData.FACE = ColourNameToRGB(objImportedColours["W"][5]) -- for 3D surfaces
    winThemeData.ONFACE = ColourNameToRGB(objImportedColours["W"][6]) -- for text on 3D surfaces
    winThemeData.TEXTSHADOW = ColourNameToRGB(objImportedColours["W"][7]) -- for text-shadowing (eg HP bars)
    winThemeData.BACK_FACE = ColourNameToRGB(objImportedColours["W"][8]) -- for scrollbar back
    winThemeData.DETAIL = ColourNameToRGB(objImportedColours["W"][9]) -- for scrollbar lines
    winThemeData.SELECTFACE = ColourNameToRGB(objImportedColours["W"][10]) -- for selected chat tab
    if (objImportedColours["W"][11] == "") then
      winThemeData.MAINFRAME = 0xFFFFFFFF
    else
      winThemeData.MAINFRAME = ColourNameToRGB(objImportedColours["W"][11]) -- for selected chat tab
    end
    -- Import core colours
    for sThisColourKey, sThisColourValue in pairs(objImportedColours["C"]) do
      if (sCOLOUR[sThisColourKey] ~= nil) then
        sCOLOUR[sThisColourKey] = sThisColourValue
      end
    end
    iCOLOUR = {}
    for sColourKey, sColourString in pairs(sCOLOUR) do
      iCOLOUR[sColourKey] = ColourNameToRGB(sColourString)
    end
    -- If our version supports it, set mainframe background colour
    if (iMushclientVersion >= 5.07) then
      SetFrameBackgroundColour(winThemeData.MAINFRAME)
    end
    -- Finally redraw all Quow windows
    RedrawEverything()
  end
end


-- Create the appropriate handlers for a hotspot based on it's match-types
function QuowAddHotspotHandler(iHandleHotspotID)
  if (sHotspotData[iHandleHotspotID] ~= nil) then
    if (sHotspotData[iHandleHotspotID]["trigger_type"] == 1) then
      -- LEAVING a specific room ID
      iQuowHotspotRoomIDLeave[sHotspotData[iHandleHotspotID]["roomid_reset"]] = iHandleHotspotID
    elseif (sHotspotData[iHandleHotspotID]["trigger_type"] == 2) then
      -- ENTERING a specific room ID
      iQuowHotspotRoomIDEnter[sHotspotData[iHandleHotspotID]["roomid_reset"]] = iHandleHotspotID
    elseif (sHotspotData[iHandleHotspotID]["trigger_type"] == 3) then
      -- BASIC non-regex trigger
      local iTrigError = AddTriggerEx("hotspot_" .. iHandleHotspotID, sHotspotData[iHandleHotspotID]["trigger_reset"], "", 1033, -1, 0, "", "QuowHandleHotspotTrigger", 12, 20)
      if (iTrigError ~= 0) then
        ColourNote(sCOLOUR.orange, "", "CowBar Hotspot Error:")
        Note("There was an error trying to add the trigger for a hotspot with the trigger: " .. sHotspotData[iHandleHotspotID]["trigger_reset"])
        Note("The MUSHclient error code was: " .. iTrigError)
      else
        SetTriggerOption("hotspot_" .. iHandleHotspotID, "group", "module_hotspots")
      end
    elseif (sHotspotData[iHandleHotspotID]["trigger_type"] == 4) then
      -- ADVANCED regex trigger
      local iTrigError = AddTriggerEx("hotspot_" .. iHandleHotspotID, sHotspotData[iHandleHotspotID]["trigger_reset"], "", 1065, -1, 0, "", "QuowHandleHotspotTrigger", 12, 20)
      if (iTrigError ~= 0) then
        ColourNote(sCOLOUR.orange, "", "CowBar Hotspot Error:")
        Note("There was an error trying to add the regex trigger for a hotspot with the trigger: " .. sHotspotData[iHandleHotspotID]["trigger_reset"])
        Note("The MUSHclient error code was: " .. iTrigError)
      else
        SetTriggerOption("hotspot_" .. iHandleHotspotID, "group", "module_hotspots")
      end
    end
  end
end
-- Clean up this hotspot - remove triggers etc.
function QuowDeleteHotspotHandler(iHandleHotspotID)
  if (sHotspotData[iHandleHotspotID] ~= nil) then
    if (sHotspotData[iHandleHotspotID]["trigger_type"] == 1) then
      -- LEAVING a specific room ID
      iQuowHotspotRoomIDLeave[sHotspotData[iHandleHotspotID]["roomid_reset"]] = nil
    elseif (sHotspotData[iHandleHotspotID]["trigger_type"] == 2) then
      -- ENTERING a specific room ID
      iQuowHotspotRoomIDEnter[sHotspotData[iHandleHotspotID]["roomid_reset"]] = nil
    elseif (sHotspotData[iHandleHotspotID]["trigger_type"] == 3) then
      -- BASIC non-regex trigger
      DeleteTrigger("hotspot_" .. iHandleHotspotID)
    elseif (sHotspotData[iHandleHotspotID]["trigger_type"] == 4) then
      -- ADVANCED regex trigger
      DeleteTrigger("hotspot_" .. iHandleHotspotID)
    end
  end
end
-- For sorting the hotspots
function QuowHotspotCompare(a, b)
  return a[2] < b[2]
end
-- Sorting the list in advance, instead of every second
function ReSortHotspots()
  local iHotspotTotal = 0
  sHotspotSortedOrder = {}
  for iHotspotID, objHotspot in pairs(sHotspotData) do
    iHotspotTotal = iHotspotTotal + 1
    sHotspotSortedOrder[iHotspotTotal] = {iHotspotID, objHotspot["time_seen"]}
  end
  table.sort(sHotspotSortedOrder, QuowHotspotCompare)
end
-- Re-check our hotspot timer functions

function QuowRefreshHotspotTimers()
  local iTimerError = IsTimer("timer_hotspots")
  if (iTimerError ~= 0) then
    ColourNote(sCOLOUR.red, "", "Quow's Cow Bar hotspot timer error:")
    ColourNote(sCOLOUR.orange, "", "The internal MUSHclient timer for keeping your hotspots up-to-date was missing because of an unknown error, now attempting to recreate it...")
    iTimerError = AddTimer("timer_hotspots", 0, 0, 1, "", 1057, "RedrawHotspotsWindow")
    if (iTimerError == 30008) then
      ColourNote(sCOLOUR.red, "", "Error code: " .. iTimerError .. " 'Invalid Name' when trying to create the timer.")
    elseif (iTimerError == 30018) then
      ColourNote(sCOLOUR.red, "", "Error code: " .. iTimerError .. " 'Timer Already Exists' when trying to create the timer.")
    elseif (iTimerError == 30009) then
      ColourNote(sCOLOUR.red, "", "Error code: " .. iTimerError .. " 'Function Not Found' when trying to create the timer.")
    elseif (iTimerError == 30022) then
      ColourNote(sCOLOUR.red, "", "Error code: " .. iTimerError .. " 'Time Invalid' when trying to create the timer.")
    else
      ColourNote(sCOLOUR.orange, "", "Successfully re-created the hotspots timer.")
    end
  end
  iTimerError = EnableTimer("timer_hotspots", true)
  if (iTimerError == 30008) then
    ColourNote(sCOLOUR.red, "", "Error code: " .. iTimerError .. " 'Invalid Name' when trying to force-enable the hotspots timer.")
  elseif (iTimerError == 30017) then
    ColourNote(sCOLOUR.red, "", "Error code: " .. iTimerError .. " 'Timer Not Found' when trying to force-enable the hotspots timer.")
  end
end

-- Triggers to shield type links
sShieldTriggerTypes = {
  ["self_tpa"] = {"ArcaneShield1_YND_TPA"},
  ["self_eff"] = {"ArcaneShield1_YND_EFF","ArcaneShield2_YND_EFF","ArcaneShield3_YND_EFF"},
  ["self_ccc"] = {"ArcaneShield1_YND_CCC","ArcaneShield2_YND_CCC"},
  ["self_bug"] = {"ArcaneShield1_YND_BUG","ArcaneShield2_YND_BUG"},
  ["self_ms"] = {"ArcaneShield1_YND__MS"},
  ["group_tpa"] = {"ArcaneShield1_OND_TPA"},
  ["group_eff"] = {"ArcaneShield1_OND_EFF","ArcaneShield2_OND_EFF"},
  ["group_ccc"] = {"ArcaneShield1_OND_CCC","ArcaneShield2_OND_CCC"},
  ["group_bug"] = {"ArcaneShield1_OND_BUG","ArcaneShield2_OND_BUG"},
}

iCurrentCombatStatSet = tonumber(GetSQLVariable("iCurrentCombatStatSet"))
if (iCurrentCombatStatSet == nil) then
  iCurrentCombatStatSet = 0
end
-- Make sure we have a set, or create a blank one
if (iQuowCombatStats[iCurrentCombatStatSet] == nil) then
  -- Can we default to an emergency set?
  if (iEmergencyCombatStatSet ~= 0) then
    iCurrentCombatStatSet = iEmergencyCombatStatSet
  else
    -- Old option invalid, no valid emergency, better create new sets
    iCurrentCombatStatSet = 0
  end
end
-- Still no valid combat stat set
if (iCurrentCombatStatSet == 0) then
  -- Set default stat set to 1
  iCurrentCombatStatSet = 1
  -- We apparently had NO stat sets at all, so create 5 to be going on with
  assert(dbUserData:execute("INSERT INTO combat_stats (set_id, set_name) VALUES (1, 'Set One'),(2, 'Set Two'),(3, 'Set Three'),(4, 'Set Four'),(5, 'Set Five')"))
  for row in dbUserData:nrows("SELECT * FROM combat_stats") do
    iQuowCombatStats[row.set_id] = {}
    for sStatName, sStatValue in pairs(row) do
      if (sStatName ~= "set_id") then
        if (sStatName ~= "set_name") then
          iQuowCombatStats[row.set_id][sStatName] = tonumber(sStatValue)
        else
          iQuowCombatStats[row.set_id][sStatName] = sStatValue
          iQuowSetNameID[sStatValue] = row.set_id
        end
      end
    end
  end
end -- Create default combat sets

-- Preserve old text rectangle data
iOldTextRectangleData = {0, 0, 0, 0}

-- Lock the screen margins
bLockMargins = true
if (GetSQLVariable("bLockMargins") == "false") then
  bLockMargins = false
end

sGetTempVariable = GetSQLVariable("MODULES")
if (sGetTempVariable ~= nil) then
  MODULES = json.decode(sGetTempVariable)
else
  MODULES = {
    ["minimap"] = true,
    ["mdt"] = true,
    ["vitals"] = true,
    ["xp"] = true,
    ["shields"] = true,
    ["stats"] = true,
    ["ascii"] = true,
    ["comms"] = true,
  }
end
if (MODULES["hotspots"] == nil and bScreenreader == false) then
  MODULES["hotspots"] = false
  ColourNote(sCOLOUR.orange, "", "The hotspots timer module is available for use, but is disabled by default.")
  ColourNote(sCOLOUR.silver, "", "To enable it, right-click your graphical minimap window, and go to 'Disable/Enable Modules...'")
end

sGetTempVariable = GetSQLVariable("SCREENMARGINS")
if (sGetTempVariable ~= nil) then
  SCREENMARGINS = json.decode(sGetTempVariable)
else
  SCREENMARGINS = {
    ["left"] = {true, 182},
    ["top"] = {false, 10},
    ["right"] = {false, 10},
    ["bottom"] = {false, 10},
  }
end

sGetTempVariable = GetSQLVariable("CUSTOMCOWS")
if (sGetTempVariable ~= nil) then
  CUSTOMCOWS = json.decode(sGetTempVariable)
  if (CUSTOMCOWS["OPTIONS"] == nil) then
    CUSTOMCOWS["OPTIONS"] = { ["VITFORM"] = 0, }
  elseif (CUSTOMCOWS["OPTIONS"]["VITFORM"] == nil and CUSTOMCOWS["OPTIONS"]["STACK"] ~= nil) then
    if (CUSTOMCOWS["OPTIONS"]["STACK"] == true) then
      CUSTOMCOWS["OPTIONS"]["VITFORM"] = 0
    else
      CUSTOMCOWS["OPTIONS"]["VITFORM"] = 1
    end
  end
else
  CUSTOMCOWS = {
    ["MARGINS"] = {
      ["left"] = {true, 182},
      ["top"] = {false, 10},
      ["right"] = {false, 10},
      ["bottom"] = {false, 10},
    },
    [winMinimap] = { ["WIDTH"] = 250, ["HEIGHT"] = 250, ["SHOW"] = true, ["LOCKED"] = false, ["X"] = 0, ["Y"] = 0 },
    [winMDT] = { ["WIDTH"] = 400, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false, ["X"] = 0, ["Y"] = 0 },
    [winBars] = { ["WIDTH"] = 190, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false, ["X"] = 0, ["Y"] = 0 },
    [winStats] = { ["WIDTH"] = 190, ["HEIGHT"] = 220, ["SHOW"] = true, ["LOCKED"] = false, ["X"] = 0, ["Y"] = 0 },
    [winXP] = { ["WIDTH"] = 190, ["HEIGHT"] = 180, ["SHOW"] = true, ["LOCKED"] = false, ["X"] = 0, ["Y"] = 0 },
    [winShields] = { ["WIDTH"] = 190, ["HEIGHT"] = 180, ["SHOW"] = true, ["LOCKED"] = false, ["X"] = 0, ["Y"] = 0 },
    [winComms] = { ["WIDTH"] = 400, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false, ["X"] = 0, ["Y"] = 0 },
    [winAscii] = { ["WIDTH"] = 80, ["HEIGHT"] = 80, ["SHOW"] = true, ["LOCKED"] = false, ["X"] = 0, ["Y"] = 0 },
    [winHotspots] = { ["WIDTH"] = 300, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false, ["X"] = 0, ["Y"] = 0 },
    ["OPTIONS"] = { ["VITFORM"] = 0, },
  }
end
-- CustomCows winHotspots default
if (CUSTOMCOWS[winHotspots] == nil) then
  CUSTOMCOWS[winHotspots] = { ["WIDTH"] = 300, ["HEIGHT"] = 100, ["SHOW"] = false, ["LOCKED"] = false, ["X"] = 0, ["Y"] = 0 }
end
sSQL = ""



-- **********************************************************************
-- *                          Help File Text                            *
-- **********************************************************************
function DisplayHelpFile (sName, sLine, wildcards)
  Note("")
  ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar & Minimap Plugin Helpfile:")
  if (bScreenreader == false) then
    ColourNote(sCOLOUR.silver, "", "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
  end

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "help minimap")
  ColourNote(sCOLOUR.silver, "", "'             :  This help information")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap")
  ColourNote(sCOLOUR.silver, "", "'                  :  Display your selected map co-ordinates in command form, for other users to paste & see")
  
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap {map, x, y}")
  ColourNote(sCOLOUR.silver, "", "'      :  Jump to exact co-ordinates, eg 'minimap {1, 719, 803}' will jump to the Drum")
  
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap reset")
  ColourNote(sCOLOUR.silver, "", "'            :  Fix problems by resetting the minimap and all other windows back to default settings, sizes and locations")
  
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap setdir <dir>")
  ColourNote(sCOLOUR.silver, "", "'     :  Change your directional orientation, mostly for the UU Library")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap mushconfig")
  ColourNote(sCOLOUR.silver, "", "'       :  Set/Change your MUSHclient-side options that may fix some problems")
  
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap discworldconfig")
  ColourNote(sCOLOUR.silver, "", "'  :  Set/Change your Discworld-side options that may fix some problems")
  
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap xp reset")
  ColourNote(sCOLOUR.silver, "", "'         :  Reset your xp earnings and rate graphs all back to 0")
  
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap group reset")
  ColourNote(sCOLOUR.silver, "", "'      :  Reset and refresh all current group members data and shield statuses")
  
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap group hotspots")
  ColourNote(sCOLOUR.silver, "", "'   :  Share current hotspot timers to sync with group members")
  
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap group kills")
  ColourNote(sCOLOUR.silver, "", "'      :  Report the current group kill stats to group chat")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap group xp")
  ColourNote(sCOLOUR.silver, "", "'         :  Report your current XP earnings and rates to group chat")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap limit <10-2000>")
  ColourNote(sCOLOUR.silver, "", "'  :  Change the maximum number of search result entries between 10 to 2000")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap mdt enable/disable")
  ColourNote(sCOLOUR.silver, "", "': Enable/Disable the advanced scoring and parsing of written maps")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap mdt limit <num>")
  ColourNote(sCOLOUR.silver, "", "'  :  Hide rooms in the written map scoring below <num> value (-500 to 500)")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap mdt <category>")
  ColourNote(sCOLOUR.silver, "", "'   :  Enable/Disable the named written-map MDT category")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap hotspot <name>")
  ColourNote(sCOLOUR.silver, "", "'   :  Reset a hotspot timer to 0 for the given name")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap statset <x>")
  ColourNote(sCOLOUR.silver, "", "'      :  Switch to any combat stat set number from 1-100, auto-creating the set if necessary, eg 'minimap statset 12'")
  
  if (bScreenreader == false) then
    ColourTell(sCOLOUR.silver, "", "'")
    ColourTell(sCOLOUR.orange, "", "minimap brightness <x>")
    ColourNote(sCOLOUR.silver, "", "'   :  Set the minimap window brightness from 50-100%, eg 'minimap brightness 90'")
  end

  if (bScreenreader == false) then
    ColourTell(sCOLOUR.silver, "", "'")
    ColourTell(sCOLOUR.orange, "", "minimap zoom <x>")
    ColourNote(sCOLOUR.silver, "", "'         :  Set the minimap window zoom level from 1-6, eg 'minimap zoom 3'")
  end

  if (bScreenreader == true) then
    ColourTell(sCOLOUR.silver, "", "'")
    ColourTell(sCOLOUR.orange, "", "minimap position")
    ColourNote(sCOLOUR.silver, "", "'         :  Report your current position, mostly useful in the UU Library")
  end

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap combat verbose")
  ColourNote(sCOLOUR.silver, "", "'   :  Emulate Discworld verbose combat")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap combat brief")
  ColourNote(sCOLOUR.silver, "", "'     :  Emulate Discworld brief combat")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap commands")
  ColourNote(sCOLOUR.silver, "", "'         :  Show a full list of all user-commands in the Cow Bar")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap screenreader")
  ColourNote(sCOLOUR.silver, "", "'     :  Toggle screenreader output mode on or off for simpler outputs")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap route <number>")
  ColourNote(sCOLOUR.silver, "", "'   :  Try to speedwalk to a place or item search result number")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap route <bookmark>")
  ColourNote(sCOLOUR.silver, "", "' :  Try to find a matching bookmark and immediately speedwalk to it")

  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap bookmarks")
  ColourNote(sCOLOUR.silver, "", "'        :  Display your bookmarked rooms;  Bookmark a selected room in the right-click map menu")
  ColourTell(sCOLOUR.silver, "", "                              You can use '")
  ColourTell(sCOLOUR.cyan,   "", "minimap bookmark")
  ColourNote(sCOLOUR.silver, "", "' to bookmark the room you are currently stood in")
  ColourTell(sCOLOUR.silver, "", "                              And '")
  ColourTell(sCOLOUR.cyan,   "", "minimap delete bookmark <bookmark name>")
  ColourNote(sCOLOUR.silver, "", "' to delete a bookmark")
  --Note("")
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap description <txt>")
  ColourNote(sCOLOUR.silver, "", "':  Search item descriptions for any matching texts eg 'minimap description could sheath'")
  --Note("")
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap appraise <txt>")
  ColourNote(sCOLOUR.silver, "", "'   :  Search item appraisals for any matching texts eg 'minimap appraise octiron'")
  --Note("")
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap item <item>")
  ColourNote(sCOLOUR.silver, "", "'      :  Search item database for any items in the item database (in shops, on NPCs etc.)")
  ColourNote(sCOLOUR.silver, "", "                              eg 'minimap item onion', 'minimap item diamond ring'")
  --Note("")
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap npc <npc>")
  ColourNote(sCOLOUR.silver, "", "'        :  Search for NPCs matching your search string.  Limit to an area with curly-brackets")
  ColourNote(sCOLOUR.silver, "", "                              eg 'minimap npc Angua', 'minimap npc {genua} woman'")
  --Note("")
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap shop <item>")
  ColourNote(sCOLOUR.silver, "", "'      :  Search for shops selling an item matching your search for (only shop-stocks)")
  ColourNote(sCOLOUR.silver, "", "                              eg 'minimap shop beeswax', 'minimap shop {genua} harp'")
  --Note("")
  ColourTell(sCOLOUR.silver, "", "'")
  ColourTell(sCOLOUR.orange, "", "minimap <placename>")
  ColourNote(sCOLOUR.silver, "", "'      :  Search location database matching [short room names] and provides shortcut links")
  ColourNote(sCOLOUR.silver, "", "                              eg 'minimap drum', 'minimap {djb} phoenix'")

  if (bScreenreader == false) then
    Note("")
    ColourNote(sCOLOUR.silver, "", "* Click-drag the minimap titlebar to move the window around.")
    ColourNote(sCOLOUR.silver, "", "* Left-Clicking on the map will centre the map on that location (and snap to nearby rooms).")
    ColourNote(sCOLOUR.silver, "", "* Shift-Left-Clicking will take you to any connected/adjacent/zoomed-in maps (eg shift-click the thieves guild, or from within the thieves guild shift-click the street exit).")
    ColourNote(sCOLOUR.silver, "", "* Right-clicking on the map will bring up a context menu with options and extra commands:  Change maps, Speedwalk to location, display shop listings or room info, reset map position etc.")
    Note("")
    ColourNote(sCOLOUR.silver, "", "--- End of Cow Bar help file ---")
  else
    ColourNote(sCOLOUR.cyan, "", "End of Cow Bar help file")
  end
end

-- **********************************************************************
-- *                       List All Commands                            *
-- **********************************************************************
function DisplayCommands (sName, sLine, wildcards)
  Note("")
  ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar & Minimap Plugin Command List:")
  if (bScreenreader == false) then
    ColourNote(sCOLOUR.silver, "", "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
  end
  ColourNote(sCOLOUR.silver, "", "minimap")
  ColourNote(sCOLOUR.silver, "", "minimap <place result number>")
  ColourNote(sCOLOUR.silver, "", "minimap {<mapid>, <x>, <y>}")
  ColourNote(sCOLOUR.silver, "", "minimap <direction>")
  ColourNote(sCOLOUR.silver, "", "minimap bookmark")
  ColourNote(sCOLOUR.silver, "", "minimap bookmarks")
  ColourNote(sCOLOUR.silver, "", "minimap bookmarkdelete <number>")
  ColourNote(sCOLOUR.silver, "", "minimap bookmarkrename <number> <new name>")
  ColourNote(sCOLOUR.silver, "", "minimap brightness <20-100>")
  ColourNote(sCOLOUR.silver, "", "minimap chat")
  ColourNote(sCOLOUR.silver, "", "minimap clear")
  ColourNote(sCOLOUR.silver, "", "minimap clearstatset")
  ColourNote(sCOLOUR.silver, "", "minimap commands")
  ColourNote(sCOLOUR.silver, "", "minimap combat brief")
  ColourNote(sCOLOUR.silver, "", "minimap combat verbose")
  ColourNote(sCOLOUR.silver, "", "minimap delete bookmark <bookmark name or partial>")
  ColourNote(sCOLOUR.silver, "", "minimap discworldconfig")
  ColourNote(sCOLOUR.silver, "", "minimap gpregen <0-5>")
  ColourNote(sCOLOUR.silver, "", "minimap group hotspots")
  ColourNote(sCOLOUR.silver, "", "minimap group xp")
  ColourNote(sCOLOUR.silver, "", "minimap group kills")
  ColourNote(sCOLOUR.silver, "", "minimap group reset")
  ColourNote(sCOLOUR.silver, "", "minimap help")
  ColourNote(sCOLOUR.silver, "", "minimap hide")
  ColourNote(sCOLOUR.silver, "", "minimap hotspot <hotspot name>")
  ColourNote(sCOLOUR.silver, "", "minimap hotspots")
  ColourNote(sCOLOUR.silver, "", "minimap iteminfo <search result #>")
  --[[ Work in progress, yet to be done:
  ColourNote(sCOLOUR.silver, "", "minimap colourexport")
  ColourNote(sCOLOUR.silver, "", "minimap colourimport <pasted colour-import>")
  ColourNote(sCOLOUR.silver, "", "minimap layoutexport")
  ColourNote(sCOLOUR.silver, "", "minimap layoutimport <pasted layout-import>")
  ColourNote(sCOLOUR.silver, "", "minimap layout <1-13 layout number>")
  --]]
  ColourNote(sCOLOUR.silver, "", "minimap limit <10-2000>")
  ColourNote(sCOLOUR.silver, "", "minimap mdt enable")
  ColourNote(sCOLOUR.silver, "", "minimap mdt disable")
  ColourNote(sCOLOUR.silver, "", "minimap mdt limit <score limit>")
  ColourNote(sCOLOUR.silver, "", "minimap mdt <category>")
  ColourNote(sCOLOUR.silver, "", "minimap mushconfig")
  ColourNote(sCOLOUR.silver, "", "minimap npcinfo <search result #>")
  ColourNote(sCOLOUR.silver, "", "minimap omitmap")
  ColourNote(sCOLOUR.silver, "", "minimap position")
  ColourNote(sCOLOUR.silver, "", "minimap queue")
  ColourNote(sCOLOUR.silver, "", "minimap renamelast <new bookmark name>")
  ColourNote(sCOLOUR.silver, "", "minimap route")
  ColourNote(sCOLOUR.silver, "", "minimap route <bookmark name or partial>")
  ColourNote(sCOLOUR.silver, "", "minimap routenpc <npc result #>")
  ColourNote(sCOLOUR.silver, "", "minimap reset")
  ColourNote(sCOLOUR.silver, "", "minimap roominfo")
  ColourNote(sCOLOUR.silver, "", "minimap roominfo <search result #>")
  ColourNote(sCOLOUR.silver, "", "minimap roomshow")
  ColourNote(sCOLOUR.silver, "", "minimap screenreader")
  ColourNote(sCOLOUR.silver, "", "minimap setdir <direction>")
  ColourNote(sCOLOUR.silver, "", "minimap show")
  ColourNote(sCOLOUR.silver, "", "minimap skeleton")
  ColourNote(sCOLOUR.silver, "", "minimap statcreate <set name>")
  ColourNote(sCOLOUR.silver, "", "minimap statset <statset>")
  ColourNote(sCOLOUR.silver, "", "minimap xp reset")
  ColourNote(sCOLOUR.silver, "", "minimap zoom <1-7>")
  ColourNote(sCOLOUR.silver, "", "minimap appraise <search string>")
  ColourNote(sCOLOUR.silver, "", "minimap description <search string>")
  ColourNote(sCOLOUR.silver, "", "minimap item <search string>")
  ColourNote(sCOLOUR.silver, "", "minimap shop <search string> {optional location filter}")
  ColourNote(sCOLOUR.silver, "", "minimap npc <search string> {optional location filter}")
  ColourNote(sCOLOUR.silver, "", "minimap place <search string> {optional location filter}")
  ColourNote(sCOLOUR.silver, "", "minimap <search string> {optional location filter}")
  if (bScreenreader == false) then
    ColourNote(sCOLOUR.silver, "", "--- End of Cow Bar command list ---")
  else
    ColourNote(sCOLOUR.silver, "", "End of Cow Bar command list")
  end
end

-- **********************************************************************
-- *                       Global Table Setups                          *
-- **********************************************************************
-- Special Long Descriptions for places without a Room ID
sQuowLocationsByLong = {
  [1]   = {"UULibraryExit", "^This is the south end of the Library of Unseen University\\.  The rows and rows of bookshelves start just to the north and the door out is to the south\\."},
  [2]   = {"UULibraryGap", "^This is somewhere in the Library of Unseen University\\.  There is a strange gap in the shelves here\\."},
  [3]   = {"ShadesEntrance", "^This is deep in the Shades\\.  What passes for civilization in these parts is to the west, but otherwise there are three alleyways in weaving twisting directions which don't appear on any compass\\.  Further in is a deadly maze of dangerous alleyways\\."},
  [4]   = {"Shades02", "^Deep, deep into the Shades\\. This alley is like every other alley in this rabbit warren of death\\.  It is dank, dark and foggy, everything looks the same\\.\\.\\."},
  [5]   = {"Shades05", "^This rabbit warren of smoky, hazy alleys is never ending\\.  The gloom and fog mask the direction of the screams that echo in the distance\\.\\.\\."},
  [6]   = {"Shades08", "^Deep, deep into the Shades\\. This alleyway is like every other alleyway in this rabbit warren of death\\.  It is dank, dark and foggy, everything looks the same\\.\\.\\."},
  [7]   = {"Shades09", "^This dark, dank, foggy alleyway leads to other dark dank foggy alleyways\\.  The gloom hides the worst of the horrors that these alleys contain\\."},
  [8]   = {"Shades12", "^This room is like any of the other alleyways, dank, dark and foggy\\.  It has lots of exits that lead to other dank, dark and foggy alleyways\\.  Howls of fear and pain echo around from the walls\\."},
  [9]   = {"Shades16", "^The Lady is evidently not on your side; at every turn lies another twisting alleyway\\.  Dim torches flicker red through the fog, providing more a sinister red glow than any real light\\."},
  [10]  = {"ShadesGuess1", "^There is no hope of ever escaping this nightmare\\.  Grime covers the walls, and the dank slime underfoot makes walking slippery\\.  The ever present fog and gloom makes trying to see a way out impossible\\.$"},
  [11]  = {"ShadesGuess2", "^The alleyways here all look the same\\.  Dim fires flicker in the distance, providing more a kind of glow than real light\\."},
  [12]  = {"Medina01", "^This is a small winding alleyway, and there are other alleys leading off it\\.  They are all small and winding too\\.  The walls are too high to see over, and buildings block your view in all directions\\.  A person could easily get lost in here unless they had a good memory, or a map\\."},
  [13]  = {"Medina02", "^Standing in an alleyway, surrounded by buildings and other alleys, your head spins as you struggle to get your bearings\\.  You fail miserably\\.  Alleys lead in several directions\\."},
  [14]  = {"Medina03", "^The alleyway gets very narrow here\\. There are other alleys leading off it\\.  They are all small and winding too\\.  The walls are too high to see over, and buildings block your view in all directions\\.  A person could easily get lost in here unless they had a good memory, or a map\\."},
  [15]  = {"Medina04", "^This is a small winding alleyway with a T-junction\\.  All three possible exits look very similar and very alley-ly\\.  The alleys are narrow, winding and difficult to navigate safely without a map\\."},
  [16]  = {"MedinaGuess", "^You are standing in a small winding alleyway\\.  There are other alleys leading off it\\.  They are all small and winding too\\.  The walls are too high to see over, and buildings block your view in all directions\\.  A person could easily get lost in here unless they had a good memory, or a map\\."},
  [17]  = {"Medina06", "^This is a cross alleyways\\.  Like a cross-roads, but with alleyways\\.  They go this way and that\\.  You can\'t work out which way is north and you wish you\'d brought a compass\\."},
  [18]  = {"Medina07", "^At least at this point in the maze your decision is simple\\.  Either go that way, or that way\\.  The alleyway simply bends here, and you can continue or go back\\.  It\'s entirely up to you\\."},
  [19]  = {"Medina09", "^In the heart of the Red Triangle maze, alleys lead in all directions, and you are unsure which way to turn\\.  Six alleys meet here, or possibly, depending on your point of view leave from here\\.  Either way, there are a lot of possible exits\\."},
  [20]  = {"Medina10", "^Three alleyways merge here\\.  They all look the same, and all go in different directions\\.  Small buildings line the alleyways\\.  The exit ahead of you looks familiar, or does it\\?"},
  [21]  = {"Medina11", "^Isn't this the same place you were in 5 minutes ago\\?  Maybe not\\.  But perhaps it is, who knows\\?  The alleyway bends here and you have a choice of two identical exits\\."},
  [22]  = {"Medina12", "^As an Empire the Aurient is complex and easy to get lost in\\.  This set of alleyways could easily be a metaphor for the whole of Agatea\\.  They are complex and, you\'ve guessed it, easy to get lost in\\."},
  [23]  = {"Medina16", "^You are standing in a small winding alleyway\\.  There are other alleys leading off it\\.  They are all small and winding too\\.  The alley leads north and south\\.  Or is it east and west\\?  You are completely unsure\\."},
  [24]  = {"Medina17", "^The alleys twist and turn, until you eventually arrive here\\.  Here is nowhere special, just another junction within the maze of alleys in the Red Triangle\\."},
  [25]  = {"Medina18", "^This is a small winding alleyway, dark and with other alleys leading off it\\.  They are all small and winding too\\.  The walls are too high to see over, and buildings block your view in all directions\\.  A person could easily get lost in here unless they had a good memory, or a map\\."},
}

-- Special [short room names] for places without a Room ID
sQuowLocationsByShort = {
  -- AM Shades Maze [8]
  ["ShadesEntrance"] = {8, 46, 179},
  ["Shades17"] = {8, 46, 179},
  -- Column 1
  ["Shades01"] = {8, 126, 99},
  ["Shades09"] = {8, 126, 259},
  ["Shades10"] = {8, 126, 179},
  -- Column 2
  ["Shades02"] = {8, 206, 19},
  ["Shades08"] = {8, 206, 339}, 
  ["Shades11"] = {8, 206, 99},
  ["Shades15"] = {8, 206, 259},
  ["Shades16"] = {8, 206, 179},
  -- Column 3
  ["Shades03"] = {8, 286, 19},
  ["Shades07"] = {8, 286, 339},
  ["Shades12"] = {8, 286, 99},
  ["Shades13"] = {8, 286, 179},
  ["Shades14"] = {8, 286, 259},
  -- Column 4
  ["Shades04"] = {8, 366, 99},
  ["Shades05"] = {8, 366, 179}, 
  ["Shades06"] = {8, 366, 259},
  -- UU Library [47]
  ["UULibraryExit"] = {47, 166, 4810},
  ["UULibraryGap"] = {47, 196, 4480},
  -- L-Space [47]
  ["LSpaceDepths"] = {56, 243, 276},
  -- Medina
  ["Medina01"] = {58, 51, 46},
  ["Medina02"] = {58, 91, 46},
  ["Medina03"] = {58, 131, 46},
  ["Medina04"] = {58, 51, 86},
  ["Medina05"] = {58, 91, 86},
  ["Medina06"] = {58, 131, 86},
  ["Medina07"] = {58, 171, 86},
  ["Medina08"] = {58, 91, 126},
  ["Medina09"] = {58, 131, 126},
  ["Medina10"] = {58, 171, 126},
  ["Medina11"] = {58, 211, 126},
  ["Medina12"] = {58, 131, 166},
  ["Medina13"] = {58, 171, 166},
  ["Medina14"] = {58, 211, 166},
  ["Medina15"] = {58, 131, 206},
  ["Medina16"] = {58, 171, 206},
  ["Medina17"] = {58, 211, 206},
  ["Medina18"] = {58, 251, 206},
}


-- **********************************************************************
-- *             Map Find Strings - For Quick Map Changes!              *
-- **********************************************************************
-- These are "quick/short names" to zip to maps from typing "minimap <place>".  
-- You can provide 3 arguments instead of 1, to specify the pixel location on the given map ID to zip to
-- eg ["drum"] = {1, 719, 803}
-- Otherwise default positions for that map will be used
sQuowPlaceLookups = {
  ["am"] =                {1,  "Ankh-Morpork"},
  ["ankh-morpork"] =      {1,  "Ankh-Morpork"},
  ["ankh"] =              {1,  "Ankh-Morpork"},
  ["morpork"] =           {1,  "Ankh-Morpork"},
  ["drum"] =              {1,  "The Drum"},
  ["assassins"] =         {2,  "Assassins Guild, Ankh-Morpork"},
  ["am assassins"] =      {2,  "Assassins Guild, Ankh-Morpork"},
  ["am buildings"] =      {3,  "Building Interiors, Ankh-Morpork"},
  ["shaker"] =            {4,  "Salt Shaker"},
  ["five ways"] =         {1,  "Five Ways Tower, Ankh-Morpork", 438, 942},
  ["fiveways"] =          {1,  "Five Ways Tower, Ankh-Morpork", 438, 942},
  ["five-ways"] =         {1,  "Five Ways Tower, Ankh-Morpork", 438, 942},
  ["cruet"] =             {4,  "Cruet, Ankh-Morpork"},
  ["am docks"] =          {5,  "Docks, Ankh-Morpork"},
  ["docks"] =             {5,  "Docks, Ankh-Morpork"},
  ["am guilds"] =         {6,  "Non-Player Guilds, Ankh-Morpork"},
  ["guilds"] =            {6,  "Non-Player Guilds, Ankh-Morpork"},
  ["isle of gods"] =      {7,  "Isle of Gods Interiors, Ankh-Morpork"},
  ["shades"] =            {8,  "Shades Maze, Ankh-Morpork"},
  ["smallgods"] =         {9,  "TOSG, Ankh-Morpork"},
  ["small gods"] =        {9,  "TOSG, Ankh-Morpork"},
  ["tosg"] =              {9,  "TOSG, Ankh-Morpork"},
  ["temples"] =           {10, "Temples, Ankh-Morpork"},
  ["thieves"] =           {11, "Thieves Guild, Ankh-Morpork"},
  ["am thieves"] =        {11, "Thieves Guild, Ankh-Morpork"},
  ["university"] =        {12, "Unseen University, Ankh-Morpork"},
  ["unseen university"] = {12, "Unseen University, Ankh-Morpork"},
  ["uu"] =                {12, "Unseen University, Ankh-Morpork"},
  ["warriors"] =          {13, "Warrior Guilds, Ankh-Morpork"},
  ["watch"] =             {14, "Pseudopolis Watch House, Ankh-Morpork"},
  ["watch house"] =       {14, "Pseudopolis Watch House, Ankh-Morpork"},
  ["magpyr"] =            {15, "Count Magpyr's Castle"},
  ["magpyrs"] =           {15, "Count Magpyr's Castle"},
  ["count magpyr"] =      {15, "Count Magpyr's Castle"},
  ["castle"] =            {15, "Count Magpyr's Castle"},
  ["magpyr castle"] =     {15, "Count Magpyr's Castle"},
  ["bois"] =              {16, "Bois"},
  ["cwc"] =               {17, "Bes Pelargic"},
  ["bp"] =                {17, "Bes Pelargic"},
  ["bes pelargic"] =      {17, "Bes Pelargic"},
  ["bp buildings"] =      {18, "Bes Pelargic building interiors"},
  ["bp estates"] =        {19, "Bes Pelargic family estates"},
  ["estates"] =           {19, "Bes Pelargic family estates"},
  ["family estates"] =    {19, "Bes Pelargic family estates"},
  ["tang estate"] =       {19, "Tang Estate, Bes Pelargic",       77, 171},
  ["hong estate"] =       {19, "Hong Estate, Bes Pelargic",       443, 155},
  ["sung estate"] =       {19, "Sung Estate, Bes Pelargic",       897, 158},
  ["fang estate"] =       {19, "Fang Estate, Bes Pelargic",       526, 506},
  ["mcsweeney estate"] =  {19, "McSweeney Estate, Bes Pelargic",  899, 647},
  ["tangs"] =             {19, "Tang Estate, Bes Pelargic",       77, 171},
  ["hongs"] =             {19, "Hong Estate, Bes Pelargic",       443, 155},
  ["sungs"] =             {19, "Sung Estate, Bes Pelargic",       897, 158},
  ["fangs"] =             {19, "Fang Estate, Bes Pelargic",       526, 506},
  ["mcsweeneys"] =        {19, "McSweeney Estate, Bes Pelargic",  899, 647},
  ["bp wizards"] =        {20, "Wizard Guild, Bes Pelargic"},
  ["brown islands"] =     {21, "Brown Islands"},
  ["death"] =             {22, "Death's Domain"},
  ["deaths domain"] =     {22, "Death's Domain"},
  ["death's domain"] =    {22, "Death's Domain"},
  ["djb"] =               {23, "Djelibeybi"},
  ["djelibeybi"] =        {23, "Djelibeybi"},
  ["djb walls"] =         {23, "Djelibeybi Walls",                498, 215},
  ["walls"] =             {23, "Djelibeybi Walls",                498, 215},
  ["djb wall"] =          {23, "Djelibeybi Walls",                498, 215},
  ["wall"] =              {23, "Djelibeybi Walls",                498, 215},
  ["djb wizards"] =       {24, "IIL - Djelibeybi Wizard Guild"},
  ["iil"] =               {24, "IIL - Djelibeybi Wizard Guild"},
  ["ephebe"] =            {25, "Ephebe"},
  ["ephebe docks"] =      {26, "Ephebe Docks"},
  ["smugglers"] =         {26, "Smuggler Caves, Ephebe Docks"},
  ["smuggler caves"] =    {26, "Smuggler Caves, Ephebe Docks"},
  ["genua"] =             {27, "Genua"},
  ["genua sewers"] =      {28, "Genua Sewers"},
  ["sewers"] =            {28, "Genua Sewers"},
  ["grflx"] =             {29, "GRFLX Caves"},
  ["grflx caves"] =       {29, "GRFLX Caves"},
  ["hashishim"] =         {30, "Hashishim Caves"},
  ["hashishim caves"] =   {30, "Hashishim Caves"},
  ["klatch"] =            {31, "Klatch Region"},
  ["kfl"] =               {31, "Klatchian Foreign Legion"},
  ["lancre kingdom"] =    {32, "Lancre Kingdom"},
  ["lancre castle"] =     {32, "Lancre Castle"},
  ["mano"] =              {33, "Mano Rossa Assassin Guild"},
  ["mano rossa"] =        {33, "Mano Rossa Assassin Guild"},
  ["monks of cool"] =     {34, "Monks of Cool temple"},
  ["monks"] =             {34, "Monks of Cool temple"},
  ["cool monks"] =        {34, "Monks of Cool temple"},
  ["netherworld"] =       {35, "Netherworld"},
  ["oasis"] =             {31, "Oasis", 649, 1053},
  ["pumpkin town"] =      {37, "Pumpkin Town"},
  ["newbie town"] =       {37, "Pumpkin Town"},
  ["pumpkintown"] =       {37, "Pumpkin Town"},
  ["ramtops"] =           {38, "Ramtops Region"},
  ["gloomy"] =            {38, "Gloomy Forest",                   431, 269},
  ["gloomy forest"] =     {38, "Gloomy Forest",                   431, 269},
  ["bandits"] =           {38, "Bandit Camp",                     319, 199},
  ["bandit camp"] =       {38, "Bandit Camp",                     319, 199},
  ["oc"] =                {38, "Ohulan-Cutash"},
  ["ohulan-cutash"] =     {38, "Ohulan-Cutash"},
  ["ohulan cutash"] =     {38, "Ohulan-Cutash"},
  ["hunters"] =           {38, "Hunters Guild",                   1055, 49},
  ["madstoat"] =          {38, "Mad Stoat",                       1214, 357},
  ["mad-stoat"] =         {38, "Mad Stoat",                       1214, 357},
  ["mad stoat"] =         {38, "Mad Stoat",                       1214, 357},
  ["brass neck"] =        {38, "Brass Neck",                      1257, 129},
  ["brassneck"] =         {38, "Brass Neck",                      1257, 129},
  ["brass-neck"] =        {38, "Brass Neck",                      1257, 129},
  ["badass"] =            {38, "Bad Ass",                         1437, 210},
  ["bad-ass"] =           {38, "Bad Ass",                         1437, 210},
  ["bad ass"] =           {38, "Bad Ass",                         1437, 210},
  ["lancre"] =            {38, "Lancre",                          1351, 589},
  ["lancre town"] =       {38, "Lancre",                          1351, 589},
  ["creel"] =             {38, "Creel Springs",                   1603, 632},
  ["creel springs"] =     {38, "Creel Springs",                   1603, 632},
  ["creel-springs"] =     {38, "Creel Springs",                   1603, 632},
  ["madwolf"] =           {38, "Mad Wolf",                        1829, 670},
  ["mad-wolf"] =          {38, "Mad Wolf",                        1829, 670},
  ["mad wolf"] =          {38, "Mad Wolf",                        1829, 670},
  ["razorback"] =         {38, "Razorback",                       1769, 393},
  ["slice"] =             {38, "Slice",                           1979, 280},
  ["giants"] =            {38, "Ramtops Giants",                  1664, 149},
  ["brigands"] =          {38, "Ramtops Brigands",                1664, 149},
  ["soyin"] =             {38, "Temple of Soyin",                 1730, 252},
  ["listeners"] =         {38, "Listening Monk Temple",           1942, 136},
  ["listener monks"] =    {38, "Listening Monk Temple",           1942, 136},
  ["listening monks"] =   {38, "Listening Monk Temple",           1942, 136},
  ["temple of listening monks"] = {38, "Listening Monk Temple",   1942, 136},
  ["summer camp"] =       {38, "Barbarian Summer Camp",           2083, 152},
  ["oolskunrahod"] =      {38, "Oolskunrahod",                    2047, 132},
  ["pine dressers"] =     {38, "Pine Dressers",                   2025, 48},
  ["sto-lat"] =           {39, "Sto-Lat"},
  ["sto lat"] =           {39, "Sto-Lat"},
  ["stolat"] =            {39, "Sto-Lat"},
  ["sl"] =                {39, "Sto-Lat"},
  ["sto"] =               {39, "Sto-Lat"},
  ["aoa"] =               {40, "Academy of Artificers, Sto-Lat Wizard Guild"},
  ["sto lat wizards"] =   {40, "Academy of Artificers, Sto-Lat Wizard Guild"},
  ["cabbages"] =          {41, "Cabbage Warehouse, Sto-Lat"},
  ["cabbage warehouse"] = {41, "Cabbage Warehouse, Sto-Lat"},
  ["aoa library"] =       {42, "Academy of Artificers Library"},
  ["stolat sewers"] =     {43, "Sto-Lat Sewers"},
  ["sl sewers"] =         {43, "Sto-Lat Sewers"},
  ["sto-lat sewers"] =    {43, "Sto-Lat Sewers"},
  ["sto lat sewers"] =    {43, "Sto-Lat Sewers"},
  ["sprites"] =           {44, "Sprite Caves"},
  ["sprite caves"] =      {44, "Sprite Caves"},
  ["sprite caverns"] =    {44, "Sprite Caves"},
  ["sto plains"] =        {45, "Sto Plains Region",               752, 390},
  ["stoplains"] =         {45, "Sto Plains Region",               752, 390},
  ["holy wood"] =         {45, "Holywood",                        98, 139},
  ["holywood"] =          {45, "Holywood",                        98, 139},
  ["nowhere"] =           {45, "Nowhere",                         265, 760},
  ["sheepridge"] =        {45, "Sheepridge",                      618, 574},
  ["sheep ridge"] =       {45, "Sheepridge",                      618, 574},
  ["dinky"] =             {45, "Dinky",                           752, 390},
  ["scrodgen"] =          {45, "Scrogden",                        1025, 263},
  ["scrogden"] =          {45, "Scrogden",                        1025, 263},
  ["bleak prospect"] =    {45, "Bleak Prospect",                  1213, 249},
  ["bleak"] =             {45, "Bleak Prospect",                  1213, 249},
  ["bleakprospect"] =     {45, "Bleak Prospect",                  1213, 249},
  ["hillshire"] =         {45, "Hillshire",                       1372, 467},
  ["pekan ford"] =        {45, "Pekan Ford",                      1393, 617},
  ["pf"] =                {45, "Pekan Ford",                      1393, 617},
  ["hedge"] =             {45, "Hedge Wizard Guild",              1440, 546},
  ["hedges"] =            {45, "Hedge Wizard Guild",              1440, 546},
  ["uberwald"] =          {46, "Uberwald Region"},
  ["blackglass"] =        {46, "Blackglass",                      444, 187},
  ["black glass"] =       {46, "Blackglass",                      444, 187},
  ["escrow"] =            {46, "Escrow",                          673, 643},
  ["unnamed"] =           {46, "Unnamed Town, Escrow",            977, 627},
  ["unnamed town"] =      {46, "Unnamed Town, Escrow",            977, 627},
  ["winter camp"] =       {46, "Barbarian Winter Camp",           1737, 1076},
  ["library"] =           {47, "Unseen University Library"},
  ["uu library"] =        {47, "Unseen University Library"},
  ["farms"] =             {48, "Klatchian Farmsteads"},
  ["farmsteads"] =        {48, "Klatchian Farmsteads"},
  ["chronides farmstead"] = {48, "Chronides Farmstead, Ephebe"},
  ["ctf arena"] =         {49, "CTF Arena, Sto-Plains"},
  ["pk arena"] =          {50, "PK Arena, Klatch"},
  ["post office"] =       {51, "Post Office, Ankh-Morpork"},
  ["po"] =                {51, "Post Office, Ankh-Morpork"},
  ["am po"] =             {51, "Post Office, Ankh-Morpork"},
  ["shonky"] =            {1, "Shonky shop entrance",           320, 894},
  ["shonky shop"] =       {1, "Shonky shop entrance",           320, 894},
  ["t-shop"] =            {53, "Travelling Shop",               355, 316},
  ["specials"] =          {56, "Special/Misc Areas",            365, 16},
  ["walking cottage"] =   {56, "Walking Cottage",                23, 48},
  ["travelling stalls"] = {56, "Travelling Stalls",             365, 16},
  ["shollow"] =           {54, "Slippery Hollow",               215, 123},
  ["slippery hollow"] =   {54, "Slippery Hollow",               215, 123},
  ["slippery"] =          {54, "Slippery Hollow",               215, 123},
  ["sh"] =                {54, "Slippery Hollow",               215, 123},
  ["wolf trails"] =       {57, "Skund Forest Wolf Trail",        41, 587},
  ["wolf trail"] =        {57, "Skund Forest Wolf Trail",        41, 587},
  ["medina"] =            {58, "Medina"},
  ["copperhead"] =        {59, "Copperhead"},
  ["citadel"] =           {60, "The Citadel"},
  ["fools"] =             {61, "AM Fools' Guild"},
  ["fools guild"] =       {61, "AM Fools' Guild"},
  ["thursday"] =          {62, "Thursday's Island"},
  ["thursday's island"] = {62, "Thursday's Island"},
  ["thursdays island"] =  {62, "Thursday's Island"},
  ["ss unsinkable"] =     {63, "SS Unsinkable"},
  ["unsinkable"] =        {63, "SS Unsinkable"},
  ["boat"] =              {63, "SS Unsinkable"},
  ["disc"] =              {99, "Discworld Terrains",           1175, 3735},
  ["discworld"] =         {99, "Discworld Terrains",           1175, 3735},
  ["terrain"] =           {99, "Discworld Terrains",           1175, 3735},
  ["terrains"] =          {99, "Discworld Terrains",           1175, 3735},
  ["global map"] =        {99, "Discworld Terrains",           1175, 3735},
  ["whole disc"] =        {99, "Discworld Terrains",           1175, 3735},
}

-- **********************************************************************
-- *            Hot Zones - For Shift-Clickthrough Maps!                *
-- **********************************************************************
local bRecordingHotzones = false
sQuowHotZones = {
  [1] = {
    {825, 853, 836,860, 'bd0e4420d659d994ea286a1e3f12097dd4f5c370'},
    {813, 740, 840,755, 'fca4d62329576c1387d4c7e0299abd6adc3b10f6'},
    {845, 659, 851,665, 'dec775b5d640412091a37ec2ca08c3877e1957c8'},
    {952, 640, 1003,655, '895dcc5d6f68d74435e139d9f71c1676283a9ecf'},
    {1078, 642, 1127,655, '03d78b3b0885c5e931b7bf92b7c935c85796a0e3'},
    {1076, 310, 1089,345, '0e593a9bd77a2fcf8ba4b802216b2a5084cdeb2e'},
    {799, 798, 808,816, '45c52ccb69e606bf7a125680c3de4952fc8e558b'},
    {852, 742, 858,749, '22ff3625b21dcb14ad35a521d4dfa9dc645f8d71'},
    {837, 715, 844,722, '80e55d7eb45d374a851e517007926a388fb0314d'},
    {785, 893, 809,906, '13d50edc24a1918ff4109cad399d1b5566fb2b74'},
    {727, 996, 749,1014, '454f863eb451dcbbf77ef3ae9e514a63595ffab9'},
    {798, 926, 811,934, '5f681501331ad44f421ce50f519a648f59a8b7f0'},
    {846, 922, 859,933, 'c98c61ffc03009b8e428f7c3dd745a586f445478'},
    {853, 949, 869,959, 'e9c7e3e6a0cf1e03e8814fb21b99890d1e52cdc0'},
    {964, 852, 978,861, '1dda78b812eeeefb0e238b80f71b8232a9bafd8f'},
    {1018, 800, 1060,812, '8dbd4a2c9fc04df4be1055d5a4cb3b90695cdec4'},
    {824, 925, 834,936, 'e59f1c8f73806c54b29c2823bd7f8de936647fe7'},
    {810, 948, 834,964, '0dd4f89a4a426dde74df94505e55c1e5410b0a0a'},
    {1103, 1046, 1156,1056, '4609a954a57222d6f73a4fcdfc1c71f3f452cccf'},
    {1120, 1057, 1145,1070, 'ebfd03de5885e8a24426811f1cabca043f5d81f5'},
    {1119, 963, 1144,978, 'b1e8ee373198b93b9ffac4ce6e42867a656fd2df'},
    {1064, 910, 1085,926, '80e0a84b2e5202d4d08641d2636398e0af7ad375'},
    {640, 343, 668,360, 'cbabc11545f4103d31c41c0a52f6b580cd7be608'},
    {207, 621, 308,669, '01bbd8b887e71314d8e358cbaf4f585391206bc4'},
    {853, 783, 905,804, 'b54981c3e9f05054b495e1141e15842eeee473fe'},
    {711, 660, 726,672, 'ccde479add4c4ea5901cfd160748d18ee376d01a'},
    {737, 640, 759,662, '3a30691d817ee98da64b5596eed811793548a5e6'},
    {754, 665, 773,680, '263f6318cfde1443408b472244f6ad1edb7755b4'},
    {713, 473, 735,499, '5e27050325284b7b94f817fd6166a35c7f987bdf'},
    {697, 556, 712,568, 'a15518d9d1956b2a92f862101578184940880993'},
    {712, 572, 726,584, 'baeef80afb3c17d47cf12d1cb9127bdfcb1ec47d'},
    {686, 628, 695,635, 'e4323daefa982b5bbc15bdbe3ba57752df4c1e7d'},
    {661, 654, 683,665, 'e4323daefa982b5bbc15bdbe3ba57752df4c1e7d'},
    {75, 207, 126,221, '40068f55b21d63102a10d811ad8043c74e1fbade'},
    {282, 11, 331,26, 'eebbd19883152b5441290c929eb902ab2e4a9ae1'},
    {720, -3, 770,12, '514c30926f5c212eeccd2b9d9b43c2cfc051b292'},
    {1267, 279, 1323,299, 'ad9e0e9b280042358ed40a2705515f386ac897e8'},
    {1138, 1116, 1196,1136, '6a568b66b1f84cf5b4c7963803dd3e58895c613f'},
    {736, 1242, 791,1257, 'f29e7bb015cbdbc922bd1788133f1a45eb913fab'},
    {373, 1212, 431,1234, '55e5fedda888a0901f15d61944682cc99b00d588'},
    {143, 1127, 202,1155, 'a8e36f6f39a93074a7779789ab4833f487ae7020'},
    {-2, 904, 45,921, '34dfa0fb3a9a726700d3b154a1cb9fef5c58d829'},
    {428, 909, 447,934, '6ba9fabab7c10ac0eae8bd08f6846c81a0ee332f'},
    {136, 624, 159,634, '410a73c0b58f8816f56b0ba4226768a380dd196f'},
    {876, 847, 907,872, 'd5b54f04904f81f73dbec4da0bd5d263b3910d77'},
    {1269, 767, 1296,814, '22cb1754a73395759e82a1dbe8c51dd8be5b9401'},
    {1243, 793, 1274,815, '22cb1754a73395759e82a1dbe8c51dd8be5b9401'},
    {704, 779, 723,794, '1720f64c8fd19126b9f3e011c008ce3e3c5ccb0c'},
    {557, 476, 569,486, '4a4b6b503809a4c0b5e7d19222cbb52b86387bca'},
    {657, 977, 697,990, '703d6485af02c2dc0fb91b5f49c511cc0b423038'},
    {399, 480, 405,490, 'abafaecbd9fa5420b71f7de0ffbd0aefb67d4a08'},
    {121, 495, 130,504, '4f69ba8c9e03dc7f5aab00654627f0943a68417f'},
    {106, 468, 114,476, 'ab008f8e51424bf679e7fa83e24b70dcb94c80b2'},
    {189, 453, 199,462, 'c8e90657478720f7fa51a9ceb0b79ea06b6ed6c4'},
    {119, 424, 129,434, '1bfe5b2aebcf6d48d37b4bd545e31d915f013a1c'},
    {39, 452, 46,462, 'd0d47d8834379b5c16a7e38ba717a4bfd0aa55f8'},
    {397, 550, 405,560, '3f1e79ba06e77ef5ad2a812b002522c50b51b4f0'},
    {443, 565, 451,573, '3bba069e62186a6d11f1aafc055b85723ea82387'},
    {511, 552, 521,561, '0093d3f7ecb4ccbd2ba71d203ea2069986b450c2'},
    {556, 608, 563,616, 'c498e87c6494e7ef1ed523b94b14dfcb4a95d146'},
    {261, 592, 268,602, 'eb8110f376e51b57a89ae6e5815f1507c597d2b4'},
    {191, 592, 200,601, '42f1aff67ff271bd2e2f8937ebb6393fa3255c3e'},
    {131, 605, 138,617, 'f743954e9b6a5f9b51e8617afca53193f28c799a'},
    {35, 622, 45,632, '2666ccfc6b4b2a4ab103dc4be10c9eb0bc1cda05'},
    {290, 523, 297,531, '88c444d4201b2a204dceb32c7c9a28ef4a56d7fe'},
    {304, 580, 311,587, '5125b366817054f5fc2e9a1fed1d5be94dc2af22'},
    {800, 825, 825,836, '9a7a21e5d2bbde3730ec89521614405a4e8f835e'},
  },
  [2] = {
    {433, 3, 484,35, '1864e5e81160a3d2db87a28d020fd003addb0cde'},
  },
  [3] = {
    {330, 408, 371,427, '8426baac873bf2cce1a78d50e1c15b9def0ba829'},
    {466, 36, 512,66, 'f653670a6ee9e7868919a5b6b15ce7148acb16d0'},
    {1038, 343, 1089,388, '4b794b597faa991297e092998f3e97f353f1a17e'},
    {639, 335, 696,383, '0daa82e9067a42f434d0ed2d83537bc1f61a655c'},
    {179, 9, 228,54, 'd84b9535541dffb1f006ffd7e4d4ce3ab73c0a9d'},
    {173, 376, 229,424, '7266a8730ad548ad8c0b8bb43ae32d52a231dbd0'},
    {1430, 384, 1477,419, '5d05e86948b486a3d01a21ded57ba1c1b2ba3d4c'},
    {1211, 132, 1268,175, '4b11616f93c94e3c766bb5ad9cba3b61dcc73979'},
    {1294, 318, 1338,342, '8b3a457b6a254c3d3767f43a2c20fc3be95530cc'},
  },
  [4] = {
    {-3, 50, 59,89, '29896335fc1c208788bda8cfc5c5106d291be9cd'},
    {1, 246, 59,293, '21b8eb32b109648d09890d7a7dd86f2914ed0727'},
  },
  [5] = {
    {402, 79, 410,90, '6965c448a6be5d18405425315540671d84ab5212'},
    {123, 65, 129,73, 'd67a07d8e3ed75da82f952836e0f501f696cf867'},
    {123, 65, 129,73, 'd67a07d8e3ed75da82f952836e0f501f696cf867'},
    {206, 50, 214,61, '74e2757cd12c0bb139027697a22071f44ca112b0'},
    {137, 23, 145,33, '5a60fda3b7a0ed16159ccd85edbbe0c9d3c4a0ca'},
    {52, 51, 60,60, '9e5f4f7586163f3f5505c71021e59e34360e8da0'},
    {403, 148, 410,159, 'f8e12db68c9f92bc0249875526749bb25134879c'},
    {470, 163, 479,173, '1fdc0bfe8142cfb84790a24086d9fcf958f9fe41'},
    {529, 150, 536,158, '70ccfe56e73a23519446fd7cd47c961f07d0cbd6'},
    {570, 205, 578,214, 'b1c7f2ead516e8863539c9d6e3251ebaef3f245b'},
    {275, 191, 283,201, '3733e96ad2c67a6eaf5ffce5862ed2bdff2ffc31'},
    {206, 192, 214,200, '2d1426d5ad377603a5865d256a94d7faa39bab34'},
    {137, 206, 144,215, 'b824b7e35675a4bc5e13bb51e3ea50ec932f6228'},
    {53, 219, 59,227, '66d7f18ab4d938dd55a1bd33c801b568e217a8b1'},
  },
  [6] = {
    {516, 301, 571,318, 'ff1bfa1cc5cb3e4fca0fbd0e716a2d670d81464c'},
    {710, 84, 768,103, 'f54759e82fd29dadcba06c2d6a1e41906e87c2e3'},
    {36, 81, 75,106, 'da0311f4bdcba1f5f7c4b98cb00d9e81c395e8a1'},
    {114, 308, 151,337, 'f1cf803e6332816be0dad0ef569fd3dfc03813cf'},
    {325, 442, 387,465, '4dd1faccaf3764ff27cdd4751f48792a6d60ce6a'},
  },
  [7] = {
    {577, 179, 614,236, '763068db739761ab8ce5c518a44e733d08db6c1e'},
    {435, 185, 482,228, '64ae3038cb91148fbb06b102d29c970f895df92d'},
    {258, 550, 327,618, 'bb6730c2bcf2dc106d19da11402641ef4e15ec10'},
    {344, 129, 404,185, '2859bde83502e0dee341496ea95f475b6da189eb'},
    {10, 220, 101,287, 'ad942627ee46891bebb01fd673ea9dda5d18fc96'},
  },
  [8] = {
    {-68, 78, 29,237, '874493e57dff36b786fa5dcf7d82208560872561'},
  },
  [9] = {
    {143, 110, 303,138, 'be5c8e135faaeedf0221eac09dd1a792034c668b'},
  },
  [10] = {
    {690, 160, 743,191, 'a0ee7454545f31ed763a0ce39ae866c89d2ed5d0'},
    {194, 389, 242,416, '5aa065b4cc3e62be4457dbb9a8387a175ac712b2'},
    {385, 40, 440,73, '5aa065b4cc3e62be4457dbb9a8387a175ac712b2'},
    {962, 69, 1020,91, '691eb08a92cc1edcd49eaf51dc7437d0307ff8bf'},
    {800, 342, 846,376, '0d9c2b531ac0d0cb48aaceb703996af57ecbf81a'},
    {56, 104, 116,139, 'bd8f86c94070c5fca1a0eaadb41fd390848afb93'},
  },
  [11] = {
    {452, 292, 531,310, 'f54759e82fd29dadcba06c2d6a1e41906e87c2e3'},
  },
  [12] = {
    {361, 412, 407,429, 'c2e093b06399946c7b08edb9b5ce4617390cdedf'},
    {463, 546, 517,565, '61dfac4bf925ec6158e167375d3c274942ec3307'},
  },
  [13] = {
    {149, 71, 170,91, '1c08ecf555038e329c15c07650d1a852907c6e81'},
    {179, 100, 240,153, '1c08ecf555038e329c15c07650d1a852907c6e81'},
    {372, 63, 429,95, '0eea895f870e1114e6f04a93ec624baf4cc37555'},
  },
  [14] = {
    {45, 26, 121,86, '23551f6704d8d8fbcfd5440a280bdcc3c681f69e'},
  },
  [15] = {
    {258, 472, 330,492, '3eee89b825899a1bf92a487123c33989ddf47ff2'},
  },
  [16] = {
  },
  [17] = {
    {991, 700, 1030,713, 'b92fc00e0eaaf546f6eadb07eadbd688a9dd9d18'},
    {958, 576, 978,600, '9665e368ca73b69741b811e7fbfd3a121e64ca62'},
    {1168, 340, 1215,362, 'bd559090589e83c751d232b9886295801406eb02'},
    {485, 672, 514,685, 'b72ab8ab69eb114374405541cf774097c0badc36'},
    {176, 665, 225,690, '5e4ba01e54fbdacb3a68265022a1ee48e341e75f'},
    {438, 528, 487,552, '945dc5c345a9fc1e6cc9897c1478e9e11c181858'},
    {1176, 153, 1230,171, 'c5942b3d5ed30254da4302028b763b7e26be458a'},
    {529, 2, 625,28, '88f27c396e45db66c0a7d6f305ab7d7ffeb6d9c3'},
    {25, 104, 73,160, 'f02bd3eaea000ca979a6b3c623d342ff4d9159fa'},
    {659, 337, 711,362, '978c286140d7e459656feabdf53a9d602919e464'},
    {598, 254, 604,260, '69689afecf305db4bc84a7dfc9dac90a42a16d6e'},
  },
  [18] = {
    {123, 321, 157,348, '8ba9f22eca5612ba8a6f1c61e46cb2b24b88c7bc'},
    {404, 195, 454,231, '874f97223b066fc318289ba5b4a05bcd83e14213'},
    {4, 29, 75,63, '8c61f55c2d16d807ab1127260e1ce35a90a5d1d2'},
    {443, 447, 497,468, '2a7450e50d956e8f7277d037031c0695e9a6f125'},
  },
  [19] = {
    {399, 165, 443,187, '57c2105bb91dfae518055fd366e871a06d1f1d7b'},
    {552, 499, 609,513, '099a24c0e097ac3b0726b77cf5c8ef25e5df6198'},
    {914, 638, 969,657, '0cd3913c97954dece80b36d2bf4d82eec22ad2dd'},
    {94, 165, 185,182, '880661773b394f65e568b96af2a5a699624a43af'},
    {810, 79, 934,119, 'ec699e021b418606cbf0436f246b4caab0884f82'},
    {882, 167, 957,183, '1a8cfd1c6c3c15a46dcb0279f8ddc96f18c67a84'},
    {120, 577, 147,635, '58e86709564a9e3debed4f5dca9e47cd6dab0016'},
    {403, 505, 438,533, '0b3925c76eb9796528e28422a76af8206048bff0'},
    {60, 575, 90,639, '1e88b4f127ad54ac5eaad3c12b62c5238ea306c1'},
  },
  [20] = {
    {15, 492, 72,523, 'ce2dbd4f3e8282ff88de10f99942f8c1836c23c8'},
  },
  [21] = {
  },
  [22] = {
    {52, 33, 154,59, '1b4fccc2e9944f3f5714843a3aa2c593e8c1192b'},
  },
  [23] = {
    {0, -3, 110,114, '3829738a5a4426950321d7307a8165c159a96466'},
    {387, 583, 490,646, '513b9fb194a1d6249d5a11f9b16858c7e09c9c8e'},
    {116, 372, 164,387, '43a4eede50210ccc2cc983660417069532ab75ec'},
    {446, 476, 480,485, 'b85065b07a1c156d19f7b552397b32844bb7335c'},
    {410, 461, 429,476, 'd6f74be9039ab49d367c5904915aac9c120e1a8a'},
    {473, 268, 482,275, '6f668a720914be85b0abb5da849e99749d7d0ea3'},
    {543, 263, 564,277, '075b7543348543c389d39ccd38247a59d00ac98a'},
    {486, 262, 500,270, '5edcaa3035201bee13618c95af3d8e8399405c33'},
    {407, 240, 443,250, '21a16612007f335a629a14e7d844135fe9d505c9'},
    {454, 299, 472,319, '2926cb5dd1277de9a0c2162b2e5e792de4f63805'},
    {348, 337, 367,346, '1941b197df067fce2715ca625a81d88517e2283d'},
    {286, 333, 321,342, 'bffd54d704dc12f23ae48aae9be158baa9476eff'},
    {323, 237, 343,249, '11574825b3c2740b1586d5d7f06458a915f2d1da'},
    {326, 293, 343,300, '03e0321cdd859e2262a3150666aef264cb5cca0c'},
    {385, 320, 400,328, '75aa40a391eb249c6bfeb9aa01da4f89f0ac13d4'},
    {387, 297, 403,306, 'ebdc21f702d64b0b9ffaca6882578cddf78eaa93'},
    {413, 282, 432,303, 'a03185f72b5d3ef621937943e211abc40088c768'},
    {93, 172, 102,183, 'b416e96838a5b9ff6ce18c82c4d0d288caf262e5'},
    {347, 361, 373,374, 'ae47bc4f84fa77b823c93f81723f36d29b8e4df0'},
  },
  [24] = {
    {91, 194, 156,225, '5b08a5671f4e61511110b2c6437ccec6cdd32461'},
  },
  [25] = {
    {624, 609, 639,629, 'a8bca8826fff1ca24fc7262e79bcfa495347e404'},
    {569, 652, 619,672, '64ee40a06178cbddb80935725cb463e2e21770b5'},
    {626, 397, 649,432, 'e03214b1f9cd95492116a08eb9fab6d4144b5ef9'},
    {408, 562, 454,586, '71d9e658a4b55ab410f87f71892a2dcc26f32945'},
    {247, 532, 286,559, '6147f2934c5e7140d2a38f7207f6769639c1b9a6'},
    {95, 469, 118,487, '6c2930388a2f4e07a1faa712105ac5be47cca319'},
    {104, 331, 121,341, '9f8f60991023b047b22afc6833606285b9a7b653'},
    {364, 262, 383,272, 'ef4f811d27f81043a71c5a0023004a09b3889bd8'},
    {346, 287, 358,296, '08a539a3f50b992a9a317d04db3ee9ccb74bb840'},
    {349, 371, 369,378, '26d0cbcd048c1075fa82509e5419517ac0889734'},
    {348, 386, 381,392, 'b1012365973fb48954a6e16c453329484ad89a15'},
    {520, 335, 528,342, '1d9bb699b7d7705b1cbecd1f19cdfb95778e465b'},
    {493, 334, 500,341, 'dd18689aaebdb6165c8fc0fea3924da6d094d6f1'},
    {465, 320, 472,328, 'e4afb5808cc1349eb64947811a1e19649ef19d1d'},
    {437, 291, 444,299, '0c19cc2d90c3e7ce224fbc4deaf78cfea4c13fa3'},
    {410, 264, 416,272, '1dc31b88797192a4aac93a16c62141d050938147'},
    {381, 235, 388,244, '0a241de1fd754be405b845746ba835d775fcdda4'},
    {380, 221, 387,230, '2a92be068d0e23f0ff233b5ac4c7655665cbc8e9'},
    {381, 208, 388,217, '3a3ee00fa372eb8b7e418306df8dc6a7a069fbd7'},
    {380, 179, 388,188, 'b97ccfabaefe91a42716d8888ca0dd8936b72034'},
    {381, 123, 388,133, '477014a446a7b4ac612e16a6c2bbeccc77153ca5'},
    {395, 97, 401,104, '58f11d56fb48becc0fbc1d1ee7ead62d2d7d96df'},
    {408, 69, 417,78, '5132416accc61c44e9943fc6f2bdfc89f0ab594f'},
    {133, 250, 180, 280, '5808aa1f8115dff927164419a84cd15e2f977b06'},
  },
  [26] = {
    {235, 228, 280, 249, 'bb138a9349adf67346cc5819aa31c990084ef2f6'},
    {465, 277, 470,285, '91fe0878ec848edf96d7448e4d9053cc508e537d'},
    {437, 276, 445,286, '6d67cf2dd2125d9e3a0394003ee68e68a3dd3893'},
    {409, 263, 416,271, 'd34896e0320b940df827f90035e012d19233e3c7'},
    {380, 235, 388,243, '81e16284eca99ee8bd4eb4c42a9f5a751b26a537'},
    {353, 207, 360,214, '3220a1c51d2ffa3679626636928d0a95abd77ece'},
    {323, 179, 332,188, '36525ac6ad7adef4b31f964ba7952eb156c30027'},
    {325, 165, 331,173, 'ab6ef96245a8ba7c9602724dcd9aa64c3f39e1dc'},
    {325, 151, 332,159, '5baae2c3e78f50bf0b540cc28cca7a9cd96d0d39'},
    {325, 122, 331,132, 'fa0770ce934bb194f21c219ccc6815ec95a8052a'},
    {327, 71, 332,78, '053253bf6b96d937d66f1109b38ad5f436966bd5'},
    {328, 39, 336,47, '1d3179cad9d92b47884cbb1ab4343f50fda2c6c2'},
    {355, 12, 360,21, '1ce749d0d9ed5edec8a18372315570bd4400faf7'},
  },
  [27] = {
    {437, 268, 466,281, 'ea8960ad9869d9c40043577dca5e3fd090efd9f6'},
    {493, 434, 500,449, 'b5a956c94403920a1ad6c0c935343c10549d76ec'},
    {143, 218, 169,233, 'a1755a2f5b92db6af5feb15f06879896aff8a44c'},
    {197, 282, 240,290, '3b8a246e6a4c345fc2f5c88da96383fee307927c'},
    {324, 378, 356,388, 'd572da8982764dd019315e09c4fc75b93bbf0bf6'},
    {410, 176, 435,192, '2e07bf34ece29ebd366ed3c39f1d84da87bcd999'},
    {217, 264, 250,277, '56063974b58bd7324e204a381638f5f7c9c23c88'},
    {209, 251, 231,259, 'b924218508be08992ccf41c8bcbe9b736cb33d63'},
  },
  [28] = {
  },
  [29] = {
    {342, 84, 426,154, '3e724ce169925b6ac5a824f91fc3a44fd81c0535'},
  },
  [30] = {
    {231, 73, 280,109, '3abe3eeb907d8747da3d929811336fb722520a45'},
  },
  [31] = {
    {1666, 1326, 1733,1346, '4f3f368b9305a6d353b5661723d4eab0120ca5e2'},
    {1094, 891, 1172,962, '5b7c6cc0ad1ed4b5250a681a390918afe25835a2'},
    {1108, 964, 1159,975, '5b7c6cc0ad1ed4b5250a681a390918afe25835a2'},
    {1147, 1023, 1196,1042, '64ee40a06178cbddb80935725cb463e2e21770b5'},
    {1139, 992, 1149,1003, '64ee40a06178cbddb80935725cb463e2e21770b5'},
    {948, 690, 966,729, 'bdf61f65e0b9cf7d87e50213d1f7fc2d3db02cd2'},
    {899, 748, 917,787, '3abe3eeb907d8747da3d929811336fb722520a45'},
    {791, 755, 828,785, 'dd9f47f4c56942524327bfe024bd84ad7e387ce7'},
    {689, 752, 734,767, 'cae6eb9b556284aada2249afcb7ffa1c21432074'},
    {1022, 757, 1110,787, '1a98ad51da8a7dc72174ca33e86c4c4c04335181'},
    {999, 746, 1015,781, 'bc27e8c0f9d277d4886783004169ccf2477d72fd'},
    {938, 813, 981,831, '70f584318b304ee7b32f573035a880b4b46065f1'},
    {921, 737, 994,809, '4ed9b9006731e04ade1ed9c34d41861fbe8ae1b1'},
    {594, 476, 638,501, 'cf9367911b6888bc2dbd57a8f9696e4bc4ef65b8'},
  },
  [32] = {
    {268, 3, 304,26, '6c5be0a1555be9cd2ad8736c18fdb42438d3d82d'},
  },
  [33] = {
    {273, 225, 330,261, 'd8e35a2851b29a32a08546d85a2e955b27caa0b4'},
  },
  [34] = {
    {47, 179, 121,208, '254c4c72a2cd43d33b780fead4be70afe719f72b'},
  },
  [35] = {
    {24, 55, 65,63, '8c8f53eb3b312ac3746341a6700703a98234ce69'},
  },
  [36] = {
  },
  [37] = {
  },
  [38] = {
    {23, 173, 92,204, 'e31337ed58ac5bdf7352c52fc4ded9ca0188706d'},
    {4, 232, 31,300, 'e31337ed58ac5bdf7352c52fc4ded9ca0188706d'},
    {12, 447, 89,488, '9dfd44df4a880d3e75ef338aca18d89676ed397f'},
    {1087, 695, 1144,732, '3dc2137cf86add56183f19e0fb5c43d99a2b4899'},
    {1439, 702, 1546,746, '1a28b1cd72e6781a6051a38fdb65d7b55ce51930'},
    {1598, 421, 1636,428, 'ab65749bc71efdbb979b04ba3d853a2810fea296'},
    {1402, 261, 1449,297, '52c70f41906ee625fc59300631e4f59483bda867'},
    {1583, 642, 1621,652, '127d267237515f062e0687a66f4278b37a7ca4c9'},
    {1333, 688, 1368,708, '89df609928ea5193b5e093db2cab470703ea5e99'},
    {1730, 551, 1805,569, '0599afdbf4ccd7fa337394294d59506135dc5dd8'},
  },
  [39] = {
    {80, 199, 100,214, '4b11616f93c94e3c766bb5ad9cba3b61dcc73979'},
    {115, 205, 175,225, '22a5bfab84412168732c9d40c4feebeedc8714ea'},
    {531, 172, 587,192, 'b01d100521beb946589a12b70704026f9d1be58e'},
    {388, 327, 438,353, 'c1d633be3697cdef18780c5cbca5f10354b7300c'},
    {292, 256, 330,274, '572f3c54b5dece1f8fd35b74eb87f99482004a7d'},
    {389, 176, 429,185, '8cf67129adb6cb8693fd3f70252e12e1da58934a'},
    {453, 168, 466,181, 'e6a30c7edfb8422864dfffc30e488aba3c570bad'},
    {220, 10, 232,23, '29cf81349f02e96ae4f3189a388878e1352ebbc1'},
  },
  [40] = {
    {21, 36, 73,62, '267190649b1394ef19b4a92aa4a8b552c0fed383'},
  },
  [41] = {
    {2, 73, 40,112, '73e6b79389e6f6d66b8653b6c30f425f96a84a34'},
  },
  [42] = {
  },
  [43] = {
  },
  [44] = {
    {182, 239, 228,254, '0165a796985323b12daaeaf120ef5af2ffcd4a0d'},
  },
  [45] = {
    {169, 343, 289,472, '4b11616f93c94e3c766bb5ad9cba3b61dcc73979'},
    {0, 865, 57,887, 'b84d02e871489603adc153fedbf6a208536d048d'},
    {134, 636, 209,651, '8c5c560432c6ba61c7de78f224643fa805217d11'},
    {383, 429, 431,476, '326449a847b703d051fd8efcc2717087a2de429e'},
    {1431, 125, 1489,198, '6da544682de2741198f30d513a49337ef547fce2'},
    {1080, 966, 1152,1008, '08aef95efe17843d4162a377dbc57aff0d56049d'},
    {1058, 865, 1067,874, '8de92ec5ed0864d3afb3aadaeb78146177f038fb'},
    {1444, 595, 1496,615, '33b64711ec0bc693667db42e16170f64f0697415'},
    {1169, 768, 1223,797, 'a3bc41e5fcd4d5a87dbd2f3801da26948189de34'},
  },
  [46] = {
    {98, -10, 183,28, '450e4c7eacd4f793ac2416d1bc310ff4e25bfd24'},
    {254, -8, 307,26, '0e053d4d828f009685ce5ebab09b9af68f9eea95'},
    {643, 217, 678,239, 'ff7aaf299c0b07b2f456918f2053841cb02916a2'},
    {875, 568, 931,617, '319a201d17677fe960760d92032eb9783be7bf85'},
    {471, 258, 497, 272, '4ae8a9c69811eae5e6a756bab96d26ee3c255358'},
  },
  [47] = {
    {151, 4832, 181,4842, 'd67e7fc940fa14ae6356389ec1c96cc27ad81391'},
  },
  [48] = {
    {484, 205, 543,254, 'ae13c6c35e4299c06c6b566593b911c0292ea29e'},
    {142, 131, 178,161, '977681e1f93bd661e9ea74902ab23bb6e8b3c2a7'},
  },
  [49] = {
  },
  [50] = {
    {129, 352, 185,378, '81fd32f857bb615735ef84c5ec691fb9f6b96e41'},
  },
  [51] = {
    {163, 0, 251,59, '7495829293caa3876b2b13378d4c76bb75ca28cf'},
    {-1, 49, 58,111, '16f977ddd1ad080a00ddd0253f3660fc14629554'},
  },
  [52] = {
    {92, -4, 123,34, '1fd3217446fe4825f97112f9dd435e9178725731'},
  },
  [53] = {
  },
  [54] = {
    {203, 226, 237,242, 'b3bde6882b7f536cfebfebc2790f0c5c12fe8a4f'},
  },
  [55] = {
    {14, 15, 72,44, 'a53d743f294ae89d3ea6f9341692e0181c7bdf49'},
  },
  [56] = {
  },
  [57] = {
    {643, 0, 721,27, '591574e8d59b7639c9f2c0a4c7ba64c390e18b30'},
    {-1, 555, 47,599, 'ce07670098dafc66f0a618ddd515149eaaf4d294'},
  },
  [58] = {
    {2, 1, 39,34, '00a2f8047ef3c5b745f90852e21e8f5f0eab8d76'},
    {266, 214, 309,249, '8426328e1606a2b149b2c41f5e4f4ba7818cc878'},
  },
  [59] = {
    {1, 35, 50,53, 'fa6d1b1c251d2197052c36293d5a113436e4d0fa'},
  },
  [60] = {
    {0, 63, 33, 85, '491e3c18a0882a65e38c591f808bd423e29147d2'},
  },
  [61] = {
    {33, 37, 114, 81, '339f269bda832d31bf639a26394721c42399b3e9'},
  },
  [99] = {
    {68, 3277, 68+33, 3277+24, 'd51ec3d04e8e3ab7a3f7f87ff7e1c63f1a302222'},  -- Basilisk
    {255, 3459, 255+50, 3459+14, '272f5bc0dab4022fee113c285a63f8fa56ed6718'},  -- Sandstone rock
    {277, 3566, 277+25, 3566+17, '5269f52b5bcc97cc9129776c37acd2bd72a5287d'},  -- Huge Rock (north part of klatch)
    {522, 3628, 522+14, 3628+8, '81fd32f857bb615735ef84c5ec691fb9f6b96e41'},  -- PK Arena
    {562, 3604, 562+48, 3604+22, '7f791673dbf19adf20172bd2b8a39c4ffdd2e104'},  -- Foreign Legion
    {528, 3666, 528+37, 3666+14, 'bf47ef14c4647af6629b5db3d2b185ce21f6e594'},  -- Trading Post
    {587, 3686, 587+54, 3686+20, '4ed9b9006731e04ade1ed9c34d41861fbe8ae1b1'},  -- DJB
    {736, 3510, 736+44, 3510+13, '57a57db44c5dfecfe765fe6afb138016a5ed2548'},  -- Monolith
    {760, 3477, 760+30, 3477+12, 'b57bc6612d73523e530a6e41e8a93d240febb519'},  -- Ruins
    {654, 3763, 654+44, 3763+16, '5b7c6cc0ad1ed4b5250a681a390918afe25835a2'},  -- Ephebe
    {484, 3759, 484+25, 3759+17, '899ad0dfdfc25ad0ebeb4ed861ea18e339adb4d0'},  -- Oasis
    {135, 3972, 135+46, 3972+13, '8d09e7e48f6a3659610709ff22d94dc273a210fe'},  -- Calh-Nhad
    {701, 3840, 701+37, 3840+13, '24718babffc9998f156749107283f65b74600402'},  -- Il Drim
    {1029, 3934, 1029+15, 3934+11, '9dc9acfe8fd09b43e5a4ae5ca473fd6cd66d111c'},  -- CTF
    {1126, 3826, 1126+6, 3826+6, '1b4fccc2e9944f3f5714843a3aa2c593e8c1192b'},  -- Death's Domain
    {1117, 3850, 1117+40, 3850+13, '61fdd4a7973b6e8904a43d8b0065ba374156a194'},  -- Nowhere
    {1165, 3720, 1165+18, 3720+22, '4b11616f93c94e3c766bb5ad9cba3b61dcc73979'},  -- AM
    {1046, 3611, 1046+46, 3611+12, '8ee6f05a721d93d15599518c1706a3c79880498b'},  -- Holywood
    {1201, 3732, 1201+31, 3732+13, '326449a847b703d051fd8efcc2717087a2de429e'},  -- Sto-Lat
    {1272, 3741, 1272+33, 3741+20, '7cdff063a132319a743af7d7d4c38c51ddb6e2d2'},  -- Sheepridge
    {1282, 3721, 1282+33, 3721+10, '1f2c4da6a08c546b0b51a51f2e46d195b40ac1f0'},  -- Dinky
    {1326, 3680, 1326+52, 3680+13, '76faa6e06e11a410b92796b486b89fd226ea5e3c'},  -- Scrogden
    {1391, 3658, 1391+41, 3658+20, '61850a9a9f03ba315d00f3a238e9171ede298250'},  -- Bleak Prospect
    {1493, 3841, 1493+41, 3841+11, '9dfd44df4a880d3e75ef338aca18d89676ed397f'},  -- Hillshire
    {1495, 3856, 1495+27, 3856+18, '3887791d1b403771b941cb954a6a89b50ebafd17'},  -- Pekan Ford
    {1481, 3900, 1481+24, 3900+17, 'a3bc41e5fcd4d5a87dbd2f3801da26948189de34'},  -- Wolf Trail
    {1423, 3953, 1423+31, 3953+10, '24f4c225ede14b4a53f0bd7b2b3dc2a7ec09fe30'},  -- GRFLX
    {1407, 4007, 1407+20, 4007+10, '806874416b7dfc7dd06f57a9071c2a340bbe4388'},  -- Hut (grflx)
    {1991, 4488, 1991+17, 4488+12, '4fffad687f3f53289456eb1889d299af91c1769b'},  -- Dave Tree
    {1999, 4465, 1999+31, 4465+16, 'aced8c3a59bfc18a161fda414c736344e8c82a63'},  -- Escrow
    {2037, 4447, 2037+35, 4447+9, 'ecc59f4a9393fc9acd0aefb525610436fb7e2bba'},  -- Magpyrs
    {2962, 4690, 2962+60, 4690+10, '91e86c64d152772c78b6362b88dfe80421a047e9'},  -- Barb winter camp (escrow)
    {2010, 4142, 2010+66, 4142+15, 'ff7aaf299c0b07b2f456918f2053841cb02916a2'},  -- Monks of Cool
    {2056, 3726, 2056+32, 3726+10, '4ff810701c3ece94874e36665211263f76525ad5'},  -- Soyin
    {2214, 3673, 2214+47, 3673+16, 'a282d4fc3ed57be6ba06cccaa5aa1ffcae46f162'},  -- Listening Monks
    {2192, 3673, 2192+16, 3673+14, '0f797ef5b7e0c60c9ea3e3b4435983ad9c3f14c2'},  -- Listener's Valley
    {2019, 3655, 2019+37, 3655+18, '42cdaf35ab2cbf0d43899203b7f96f141dd68ef1'},  -- Giants
    {1839, 3615, 1839+34, 3615+27, '14dd2da77968d35c5eb9ee1679b20c24dc5b40f4'},  -- Gloomy
    {1907, 3671, 1907+24, 3671+13, 'c36ba0a98351259c8cb89ea7d6a354ca959b3a64'},  -- Lancre Pool
    {1885, 3623, 1885+16, 3623+17, '93bf68291d0dbc25680ffb5f42e35e6516b264eb'},  -- OC
    {1907, 3605, 1907+9, 3605+9, '810363e6734b4402658cd0337b484ec185b79ca0'},  -- Hunter's Camp
    {1916, 3605, 1916+75, 3603+47, 'f97fb9ca042044d56a0340ef952ed74d691248f4'},  -- Ramtops region
    {1933, 3655, 1933+14, 3655+12, '37376ad947336898b111bb74324a661cd83c4274'},  -- Black Glass
    {2565, 3544, 2565+63, 3544+12, '15162daf7173fcc744332888b05384052d5ba990'},  -- Barb summer camp (ramtops)
    {3726, 1610, 3726+132, 1610+33, '649635b91636ddf97c6b70c4ee513ffc0f865963'},  -- Bes Pelargic (tuna road)
    {3551, 73, 3551+124, 73+46, 'POTATOMISSINGTHURSDAY'},  -- Thursday's Island
  },
}

-- **********************************************************************
-- *                 Map File Names/Core Locations & Data               *
-- **********************************************************************
-- The file names and the "friendly title" for the titlewindow of the map, for each location
-- Also contains the "grid size" - a value to move the map by automatically for an average 1 room size (guesstimate tracking)
-- A default "centre-point" for those maps 
-- A temp variable used for map caching
-- And finally the background colour for the window (for displaying off the edges of the actual graphic)
sQuowMapfiles = {
  [1] = { "am.png", "Ankh-Morpork", 14, 14, 718, 802, "AM", false, 16777215, },
  [2] = { "am_assassins.png", "AM Assassins", 28, 28, 457, 61, "AM", false, 16777215, },
  [3] = { "am_buildings.png", "AM Buildings", 25, 25, 208, 76, "AM", false, 16777215, },
  [4] = { "am_cruets.png", "AM Cruets", 24, 24, 300, 69, "AM", false, 16777215, },
  [5] = { "am_docks.png", "AM Docks", 14, 14, 174, 216, "AM", false, 16777215, },
  [6] = { "am_guilds.png", "AM Guilds", 28, 28, 487, 245, "AM", false, 16777215, },
  [7] = { "am_isle_gods.png", "AM Isle of Gods", 24, 24, 342, 587, "AM", false, 16777215, },
  [8] = { "am_shades.png", "Shades Maze", 80, 80, 46, 179, "AM", false, 12895428, },
  [9] = { "am_smallgods.png", "Temple of Small Gods", 24, 24, 221, 224, "AM", false, 16777215, },
  [10] = { "am_temples.png", "AM Temples", 24, 24, 575, 419, "AM", false, 16777215, },
  [11] = { "am_thieves.png", "AM Thieves", 28, 28, 431, 300, "AM", false, 16777215, },
  [12] = { "am_uu.png", "Unseen University", 28, 28, 166, 393, "AM", false, 16777215, },
  [13] = { "am_warriors.png", "AM Warriors", 32, 25, 135, 104, "AM", false, 16777215, },
  [14] = { "am_watch_house.png", "Pseudopolis Watch House", 24, 24, 88, 104, "AM", false, 16777215, },
  [15] = { "magpyr.png", "Magpyr's Castle", 20, 20, 141, 440, "Magpyr", false, 16777215, },
  [16] = { "bois.png", "Bois", 14, 14, 239, 169, "Bois", false, 16777215, },
  [17] = { "bp.png", "Bes Pelargic", 14, 14, 1070, 748, "BP", false, 16777215, },
  [18] = { "bp_buildings.png", "BP Buildings", 24, 24, 428, 177, "BP", false, 16777215, },
  [19] = { "bp_estates.png", "BP Estates", 14, 14, 540, 506, "BP", false, 16777215, },
  [20] = { "bp_wizards.png", "BP Wizards", 20, 20, 101, 517, "BP", false, 16777215, },
  [21] = { "brown_islands.png", "Brown Islands", 28, 28, 105, 101, "Brown", false, 16777215, },
  [22] = { "deaths_domain.png", "Death's Domain", 28, 28, 98, 86, "Death", false, 16777215, },
  [23] = { "djb.png", "Djelibeybi", 14, 14, 438, 369, "DJB", false, 16777215, },
  [24] = { "djb_wizards.png", "IIL - DJB Wizards", 28, 28, 210, 210, "DJB", false, 16777215, },
  [25] = { "ephebe.png", "Ephebe", 14, 14, 407, 349, "Ephebe", false, 16777215, },
  [26] = { "ephebe_under.png", "Ephebe Underdocks", 14, 14, 247, 285, "Ephebe", false, 16777215, },
  [27] = { "genua.png", "Genua", 14, 14, 470, 242, "Genua", false, 16777215, },
  [28] = { "genua_sewers.png", "Genua Sewers", 21, 21, 405, 312, "Genua", false, 16777215, },
  [29] = { "grflx.png", "GRFLX Caves", 20, 20, 303, 222, "GRFLX", false, 16777215, },
  [30] = { "hashishim_caves.png", "Hashishim Caves", 28, 28, 258, 132, "Klatch", false, 16777215, },
  [31] = { "klatch.png", "Klatch Region", 14, 14, 724, 515, "Klatch", false, 16777215, },
  [32] = { "lancre_castle.png", "Lancre Region", 14, 14, 285, 33, "Ramtops", false, 16777215, },
  [33] = { "mano_rossa.png", "Mano Rossa", 28, 28, 298, 202, "Genua", false, 16777215, },
  [34] = { "monks_cool.png", "Monks of Cool", 14, 14, 113, 170, "Ramtops", false, 16777215, },
  [35] = { "netherworld.png", "Netherworld", 14, 14, 42, 75, "Nether", false, 16777215, },
  [37] = { "pumpkin_town.png", "Pumpkin Town", 48, 48, 375, 194, "Pumpkin", false, 16777215, },
  [38] = { "ramtops.png", "Ramtops Regions", 14, 14, 827, 223, "Ramtops", false, 16777215, },
  [39] = { "sl.png", "Sto-Lat", 14, 14, 367, 222, "Sto-Lat", false, 16777215, },
  [40] = { "sl_aoa.png", "Academy of Artificers", 25, 25, 47, 87, "Sto-Lat", false, 16777215, },
  [41] = { "sl_cabbages.png", "Cabbage Warehouse", 28, 28, 60, 92, "Sto-Lat", false, 16777215, },
  [42] = { "sl_library.png", "AoA Library", 57, 57, 220, 411, "Sto-Lat", false, 16777215, },
  [43] = { "sl_sewers.png", "Sto-Lat Sewers", 14, 14, 162, 204, "Sto-Lat", false, 16777215, },
  [44] = { "sprite_caves.png", "Sprite Caves", 14, 14, 113, 182, "Sprites", false, 16777215, },
  [45] = { "sto_plains.png", "Sto Plains Region", 14, 14, 752, 390, "Sto-Plains", false, 16777215, },
  [46] = { "uberwald.png", "Uberwald Region", 14, 14, 673, 643, "Uber", false, 16777215, },
  [47] = { "uu_library_full.png", "UU Library", 30, 30, 165, 4810, "UU", false, 16777215, },
  [48] = { "farmsteads.png", "Klatchian Farmsteads", 28, 28, 445, 171, "Klatch", false, 16777215, },
  [49] = { "ctf_arena.png", "CTF Arena", 48, 48, 307, 283, "CTF", false, 16777215, },
  [50] = { "pk_arena.png", "PK Arena", 30, 30, 155, 331, "PK", false, 16777215, },
  [51] = { "am_postoffice.png", "AM Post Office", 28, 28, 156, 69, "AM", false, 16777215, },
  [52] = { "bp_ninjas.png", "Ninja Guild", 28, 28, 109, 56, "BP", false, 16777215, },
  [53] = { "tshop.png", "The Travelling Shop", 28, 28, 355, 315, "T-Shop", false, 16777215, },
  [54] = { "slippery_hollow.png", "Slippery Hollow", 14, 14, 215, 123, "S-Hollow", false, 16777215, },
  [55] = { "creel_guild.png", "House of Magic - Creel", 28, 28, 38, 86, "Ramtops", false, 16777215, },
  [56] = { "quow_specials.png", "Special Areas", 28, 28, 288, 28, "Misc", false, 16777215, },
  [57] = { "skund_wolftrails.png", "Skund Wolf Trail", 12, 12, 41, 587, "Skund", false, 16777215, },
  [58] = { "medina.png", "Medina", 38, 38, 131, 126, "BP", false, 16777215, },
  [59] = { "copperhead.png", "Copperhead", 12, 12, 55, 47, "Copper", false, 16777215, },
  [60] = { "ephebe_citadel.png", "The Citadel", 11, 11, 37, 74, "Ephebe", false, 16777215, },
  [61] = { "am_fools.png", "AM Fools' Guild", 28, 28, 13, 65, "AM", false, 16777215, },
  [62] = { "thursday.png", "Thursday's Island", 28, 28, 112, 65, "Thursday", false, 16777215, },
  [63] = { "unsinkable.png", "SS Unsinkable", 28, 28, 143, 124, "Unsinkable", false, 16777215, },
  [99] = { "discwhole.png", "Whole Disc", 1, 1, 1175, 3726, "Terrains", false, 0, },
}

-- For linked region groups
sRegionLinkGroups = {
  -- AM
  [1] = {[1] = true, [2] = true, [3] = true, [4] = true, [5] = true, [6] = true, [7] = true, [8] = true, [9] = true, [10] = true, [11] = true, [12] = true, [13] = true, [51] = true, [61] = true,},
  -- BP
  [17] = {[17] = true, [18] = true, [19] = true, [20] = true, [52] = true,},
  -- DJB
  [23] = {[23] = true, [24] = true,},
  -- Ephebe
  [25] = {[25] = true, [26] = true, [60] = true,},
  -- Genua
  [27] = {[27] = true, [28] = true, [33] = true,},
  -- Klatch
  [31] = {[31] = true, [23] = true, [24] = true, [25] = true, [26] = true, [30] = true, [48] = true,},
  -- Ramtops
  [38] = {[38] = true, [32] = true, [34] = true, [44] = true, [54] = true, [55] = true, [59] = true,},
  -- Sto-lat
  [39] = {[39] = true, [40] = true, [41] = true, [42] = true, [43] = true,},
  -- Sto-plains
  [45] = {[45] = true, [29] = true, [39] = true, [40] = true, [41] = true, [42] = true, [43] = true,},
}


-- Lookup table to quickly convert directions to pixel-shift directions
sQuowTrackMoves = {
  ["n"] = { 0, -1, 0 },
  ["ne"] = { 1, -1, 0 },
  ["e"] = { 1, 0, 0 },
  ["se"] = { 1, 1, 0 },
  ["s"] = { 0, 1, 0 },
  ["sw"] = { -1, 1, 0 },
  ["w"] = { -1, 0, 0 },
  ["nw"] = { -1, -1, 0 },
  ["north"] = { 0, -1, 0 },
  ["northeast"] = { 1, -1, 0 },
  ["east"] = { 1, 0, 0 },
  ["southeast"] = { 1, 1, 0 },
  ["south"] = { 0, 1, 0 },
  ["southwest"] = { -1, 1, 0 },
  ["west"] = { -1, 0, 0 },
  ["northwest"] = { -1, -1, 0 },
  ["walk n"] = { 0, -1, 0 },
  ["walk ne"] = { 1, -1, 0 },
  ["walk e"] = { 1, 0, 0 },
  ["walk se"] = { 1, 1, 0 },
  ["walk s"] = { 0, 1, 0 },
  ["walk sw"] = { -1, 1, 0 },
  ["walk w"] = { -1, 0, 0 },
  ["walk nw"] = { -1, -1, 0 },
  -- Left/right etc. need to be treated differently
  ["lt"] = { 0, 0, 0 },
  ["left"] = { 0, 0, 0 },
  ["rt"] = { 0, 0, 0 },
  ["right"] = { 0, 0, 0 },
  ["fw"] = { 0, 0, 0 },
  ["forward"] = { 0, 0, 0 },
  ["bw"] = { 0, 0, 0 },
  ["backward"] = { 0, 0, 0 },
  ["turn around"] = { 0, 0, 0 },
  ["turn left"] = { 0, 0, 0 },
  ["turn lt"] = { 0, 0, 0 },
  ["turn right"] = { 0, 0, 0 },
  ["turn rt"] = { 0, 0, 0 },
  -- Shades direction specials
  ["1"] = { 6, 6, 6 },
  ["2"] = { 6, 6, 6 },
  ["3"] = { 6, 6, 6 },
  ["4"] = { 6, 6, 6 },
  ["5"] = { 6, 6, 6 },
  ["6"] = { 6, 6, 6 },
  ["7"] = { 6, 6, 6 },
  ["8"] = { 6, 6, 6 },
}
-- Short-hand conversion of directions
sMovementShort = {
  ["north"] = "n",
  ["northeast"] = "ne",
  ["east"] = "e",
  ["southeast"] = "se",
  ["south"] = "s",
  ["southwest"] = "sw",
  ["west"] = "w",
  ["northwest"] = "nw",
  ["n"] = "n",
  ["ne"] = "ne",
  ["e"] = "e",
  ["se"] = "se",
  ["s"] = "s",
  ["sw"] = "sw",
  ["w"] = "w",
  ["nw"] = "nw",
  ["up"] = "u",
  ["down"] = "d",
  ["u"] = "u",
  ["d"] = "d",
}
-- Reverse directions
sReverseMove = {
  ["n"] = "s",
  ["ne"] = "sw",
  ["e"] = "w",
  ["se"] = "nw",
  ["s"] = "n",
  ["sw"] = "ne",
  ["w"] = "e",
  ["nw"] = "se",
  ["north"] = "s",
  ["northeast"] = "sw",
  ["east"] = "w",
  ["southeast"] = "nw",
  ["south"] = "n",
  ["southwest"] = "ne",
  ["west"] = "e",
  ["northwest"] = "se",
  ["enter stall"] = "out",
  ["enter tent"] = "out",
  ["walk n"] = "walk s",
  ["walk ne"] = "walk sw",
  ["walk e"] = "walk w",
  ["walk se"] = "walk nw",
  ["walk s"] = "walk n",
  ["walk sw"] = "walk ne",
  ["walk w"] = "walk e",
  ["walk nw"] = "walk se",
  ["down"] = "u",
  ["up"] = "d",
  ["d"] = "u",
  ["u"] = "d",
}
-- Mainly for MDT purposes
sMovementFull = {
  ["north"] = "n",
  ["northeast"] = "ne",
  ["east"] = "e",
  ["southeast"] = "se",
  ["south"] = "s",
  ["southwest"] = "sw",
  ["west"] = "w",
  ["northwest"] = "nw",
}
sMovementPositionShow = {
  ["n"] = "north",
  ["ne"] = "northeast",
  ["e"] = "east",
  ["se"] = "southeast",
  ["s"] = "south",
  ["sw"] = "southwest",
  ["w"] = "west",
  ["nw"] = "northwest",
  ["u"] = "up",
  ["d"] = "down",
}
-- Unsinkable MDT dir support
sUnsinkableMDT = {
  ["fore"] = "fo",
  ["fore starboard"] = "fo-st",
  ["starboard"] = "st",
  ["aft starboard"] = "af-st",
  ["aft"] = "af",
  ["aft port"] = "af-po",
  ["port"] = "po",
  ["fore port"] = "fo-po",
}
-- Fuller text-to-value numbering, mainly for MDT
sQuowNums = 
{
  ["a"] = 1,
  ["an"] = 1,
  ["the"] = 1,
  ["one"] = 1,
  ["two"] = 2,
  ["three"] = 3,
  ["four"] = 4,
  ["five"] = 5,
  ["six"] = 6,
  ["seven"] = 7,
  ["eight"] = 8,
  ["nine"] = 9,
  ["ten"] = 10,
  ["eleven"] = 11,
  ["twelve"] = 12,
  ["thirteen"] = 13,
  ["fourteen"] = 14,
  ["fifteen"] = 15,
  ["sixteen"] = 16,
  ["seventeen"] = 17,
  ["eighteen"] = 18,
  ["nineteen"] = 19,
  ["twenty"] = 20,
  ["twenty-one"] = 21,
  ["twenty-two"] = 22,
  ["twenty-three"] = 23,
  ["twenty-four"] = 24,
  ["twenty-five"] = 25,
  ["twenty-six"] = 26,
  ["twenty-seven"] = 27,
  ["twenty-eight"] = 28,
  ["twenty-nine"] = 29,
  ["thirty"] = 30,
}

-- **********************************************************************
-- *                    Remaining Key Variables                         *
-- **********************************************************************

bCentreCrosshair = false
if (GetSQLVariable("bCentreCrosshair") == "true") then
  bCentreCrosshair = true
end

iMapDotColour = tonumber(GetSQLVariable("iMapDotColour"))
if (iMapDotColour == nil) then
  iMapDotColour = 255
end

bShowDiscDate = true
if (GetSQLVariable("bShowDiscDate") == "false") then
  bShowDiscDate = false
end

bShowCommsTabs = true
iTopCommsWindow = 0
if (GetSQLVariable("bShowCommsTabs") == "false") then
  bShowCommsTabs = false
end

bShowAlignment = false
if (GetSQLVariable("bShowAlignment") == "true") then
  bShowAlignment = true
end
bShowHPNotifications = false
if (GetSQLVariable("bShowHPNotifications") == "true") then
  bShowHPNotifications = true
end
bShowXPNotifications = false
if (GetSQLVariable("bShowXPNotifications") == "true") then
  bShowXPNotifications = true
end
bShowGPNotifications = false
if (GetSQLVariable("bShowGPNotifications") == "true") then
  bShowGPNotifications = true
end
bOptimisedCombatTriggers = false
if (GetSQLVariable("bOptimisedCombatTriggers") == "true") then
  bOptimisedCombatTriggers = true
end
iXPNotificationLimit = tonumber(GetSQLVariable("iXPNotificationLimit"))
if (iXPNotificationLimit == nil) then
  iXPNotificationLimit = 999
end
if (iXPNotificationLimit ~= 9 and iXPNotificationLimit ~= 99 and iXPNotificationLimit ~= 499 and iXPNotificationLimit ~= 999 and iXPNotificationLimit ~= 4999) then
  iXPNotificationLimit = 999
end
-- Search result limits
iSearchResultLimit = tonumber(GetSQLVariable("iSearchResultLimit"))
if (iSearchResultLimit == nil) then
  iSearchResultLimit = 100
  if (bScreenreader == true) then
    iSearchResultLimit = 30
  end
end
if (iSearchResultLimit < 10) then
  iSearchResultLimit = 10
end
if (iSearchResultLimit > 2000) then
  iSearchResultLimit = 2000
end
-- XP scaling graph
iXPGraphScaling = tonumber(GetSQLVariable("iXPGraphScaling"))
if (iXPGraphScaling == nil) then
  iXPGraphScaling = 0
end
if (iXPGraphScaling ~= 0 and iXPGraphScaling ~= 100000 and iXPGraphScaling ~= 200000 and iXPGraphScaling ~= 500000 and iXPGraphScaling ~= 800000 and iXPGraphScaling ~= 1000000 and iXPGraphScaling ~= 2000000) then
  iXPGraphScaling = 0
end
-- Solo shields window?
bSoloShieldsWindow = false
if (GetSQLVariable("bSoloShieldsWindow") == "true") then
  bSoloShieldsWindow = true
end
-- Auto wrap handling attempts
bRapMyWrap = true
if (GetSQLVariable("bRapMyWrap") == "false") then
  bRapMyWrap = false
end

-- Whether we're currently "temporarily hiding in terrains" or not;
bMinimapHidden = false
bMinimapTempHidden = false

-- Auto-Hide in Terrain
bHideOnTerrain = false
if (GetSQLVariable("bHideOnTerrain") == "true") then
  bHideOnTerrain = true
end
-- Re-broadcast data to other plugins
bReBroadcastData = false
if (GetSQLVariable("bReBroadcastData") == "true") then
  bReBroadcastData = true
end
-- Set to true to have the minimap attempt to auto-hide when in (limited, recognised) terrains, and show again when not

-- Draw orbs in the UU library
bDrawOrbs = true
if (GetSQLVariable("bDrawOrbs") == "false") then
  bDrawOrbs = false
end
-- Set to true to draw circles in the UU library when escaped spells/orbs are detected 

-- Do not move map based on "predictions"
bPredictiveMoves = false
if (GetSQLVariable("bPredictiveMoves") == "true") then
  bPredictiveMoves = true
end
-- Set to false to prevent the minimap ever moving in any room not in the database

-- Show "ghost" of where your character really is when spamming ahead
bShowGhost = true
if (GetSQLVariable("bShowGhost") == "false") then
  bShowGhost = false
end
-- Set to false to prevent the ghost being drawn

-- Hide graphical map and draw a skeleton mode instead
bDrawSkeletonMode = false
if (GetSQLVariable("bDrawSkeletonMode") == "true") then
  bDrawSkeletonMode = true
end

-- Stack the vitals bars vertically, horizontally, or sideways
iVitalsFormat = tonumber(GetSQLVariable("iVitalsFormat"))
if (iVitalsFormat == nil) then
  iVitalsFormat = 0
  -- Change default on first update, if possible
  local bOldVitalsFormat = GetSQLVariable("bVitalStacking")
  if (bOldVitalsFormat ~= nil) then
    if (bOldVitalsFormat == "true") then
      iVitalsFormat = 0
    else
      iVitalsFormat = 1
    end
    bOldVitalsFormat = nil
  end
end
if (iVitalsFormat < 0) then
  iVitalsFormat = 0
end
if (iVitalsFormat > 3) then
  iVitalsFormat = 3
end

-- Gradient for vitals bars
bVitalsGradients = true
if (GetSQLVariable("bVitalsGradients") == "false") then
  bVitalsGradients = false
end

-- MDT Data values per-user (Default to false for screenreaders)
bMDTParsingEnabled = true
if (GetSQLVariable("bMDTParsingEnabled") == "false") then
  bMDTParsingEnabled = false
end
if (bScreenreader == true) then
  bMDTParsingEnabled = false
  if (GetSQLVariable("bMDTParsingEnabled") == "true") then
    bMDTParsingEnabled = true
  end
end
-- Default value "per-entity"
iMDTDefaultValue = tonumber(GetSQLVariable("iMDTDefaultValue"))
if (iMDTDefaultValue == nil) then
  iMDTDefaultValue = 1
end
if (iMDTDefaultValue < -500) then
  iMDTDefaultValue = -500
end
if (iMDTDefaultValue > 500) then
  iMDTDefaultValue = 500
end
-- Minimum room score for MDT "entities" to appear or not
iMDTMinimumScore = tonumber(GetSQLVariable("iMDTMinimumScore"))
if (iMDTMinimumScore == nil) then
  iMDTMinimumScore = 0
end
if (iMDTMinimumScore < -500) then
  iMDTMinimumScore = -500
end
if (iMDTMinimumScore > 500) then
  iMDTMinimumScore = 500
end
-- Show empty room count
bMDTShowEmptyRoomCount = true
if (GetSQLVariable("bMDTShowEmptyRoomCount") == "false") then
  bMDTShowEmptyRoomCount = false
end
-- Show empty room count
bMDTReverseSortOrder = false
if (GetSQLVariable("bMDTReverseSortOrder") == "true") then
  bMDTReverseSortOrder = true
end
-- Force word-wrap for strange people who want it
bMDTForceWordWrap = false
if (GetSQLVariable("bMDTForceWordWrap") == "true") then
  bMDTForceWordWrap = true
end
-- Categories of MDT
sMDTCategories = {}


sGetTempVariable = GetSQLVariable("sMDTCategories")
if (sGetTempVariable ~= nil) then
  sMDTCategories = json.decode(sGetTempVariable)
else
  sMDTCategories = {
    ["letters"] = {false,},
    ["loot"] = {false,},
  }
end


-- Force hotspot timer updates
bHotspotsPrioritiseRedraw = false
if (GetSQLVariable("bHotspotsPrioritiseRedraw") == "true") then
  bHotspotsPrioritiseRedraw = true
end
-- Hotspot timer notices to chat window
bHotspotsChatWindow = false
if (GetSQLVariable("bHotspotsChatWindow") == "true") then
  bHotspotsChatWindow = true
end
-- Ascii map Hide MUD output
bAsciiMapOmitted = false
if (GetSQLVariable("bAsciiMapOmitted") == "true") then
  bAsciiMapOmitted = true
end

-- Prevent the Cow bar 3.6+ from trying to auto-navigate around the graphical terrains maps into unknown locations
bTerrainsTracking = true
if (GetSQLVariable("bTerrainsTracking") == "false") then
  bTerrainsTracking = false
end
-- Ascii auto-show terrains
bAutoShowHideAscii = false
if (GetSQLVariable("bAutoShowHideAscii") == "true") then
  bAutoShowHideAscii = true
end

-- Minimap window brightness
iMinimapBrightness = tonumber(GetSQLVariable("iMinimapBrightness"))
if (iMinimapBrightness == nil) then
  iMinimapBrightness = 100
end
if (iMinimapBrightness < 20) then
  iMinimapBrightness = 20
end

-- Zoom levels
iUseZoom = tonumber(GetSQLVariable("iUseZoom"))
if (iUseZoom == nil) then
  iUseZoom = 3
end
if (iUseZoom < 1 or iUseZoom > 7) then
  iUseZoom = 3
end
-- GP Recharge Notifications
bGPThresholdMet = false
bPlayGPNotification = false
if (GetSQLVariable("bPlayGPNotification") == "true") then
  bPlayGPNotification = true
end
sGPNotificationFile = GetSQLVariable("sGPNotificationFile")
if (sGPNotificationFile == nil) then
  sGPNotificationFile = sQuowMapPath .. "incoming.wav"
end
-- Pre-load it
objSoundGPNotification = nil
if (bPlayGPNotification == true and sGPNotificationFile ~= "") then
  local fSound = io.open(sGPNotificationFile, "rb")
  if (fSound ~= nil) then
    objSoundGPNotification = fSound:read("*a")
    fSound:close()
    fSound = nil
  end
end
-- HP Loss Notifications
bHPThresholdMet = false
bPlayHPNotification = false
if (GetSQLVariable("bPlayHPNotification") == "true") then
  bPlayHPNotification = true
end
sHPNotificationFile = GetSQLVariable("sHPNotificationFile")
if (sHPNotificationFile == nil) then
  sHPNotificationFile = sQuowMapPath .. "incoming.wav"
end
-- Pre-load it
objSoundHPNotification = nil
if (bPlayHPNotification == true and sHPNotificationFile ~= "") then
  local fSound = io.open(sHPNotificationFile, "rb")
  if (fSound ~= nil) then
    objSoundHPNotification = fSound:read("*a")
    fSound:close()
    fSound = nil
  end
end
-- Try and help ensure sounds can be played in the background when MUSH isn't highlighted
SetOption ("play_sounds_in_background", 1)
-- Store the actual sounds for types of shield breaks
sGetTempVariable = GetSQLVariable("sSoundPlayShields")
if (sGetTempVariable ~= nil) then
  sSoundPlayShields = json.decode(sGetTempVariable)
else
  sSoundPlayShields = {
    ["self_tpa"] = sQuowMapPath .. "smashglass.wav",
    ["self_eff"] = sQuowMapPath .. "swordclash.wav",
    ["self_ccc"] = "",
    ["self_bug"] = sQuowMapPath .. "swoosh.wav",
    ["self_ms"] = sQuowMapPath .. "phasebreak.wav",
    ["group_tpa"] = sQuowMapPath .. "smashglass.wav",
    ["group_eff"] = sQuowMapPath .. "swordclash.wav",
    ["group_ccc"] = "",
    ["group_bug"] = sQuowMapPath .. "swoosh.wav",
    ["group_ms"] = sQuowMapPath .. "phasebreak.wav",
  }
end
objSoundPlayShields = {}
-- Play sounds for types of shield breaks
sGetTempVariable = GetSQLVariable("bSoundPlayShields")
if (sGetTempVariable ~= nil) then
  bSoundPlayShields = json.decode(sGetTempVariable)
else
  bSoundPlayShields = {
    ["self_tpa"] = false,
    ["self_eff"] = false,
    ["self_ccc"] = false,
    ["self_bug"] = false,
    ["self_ms"] = false,
    ["group_tpa"] = false,
    ["group_eff"] = false,
    ["group_ccc"] = false,
    ["group_bug"] = false,
    ["group_ms"] = false,
  }
end
-- Load from memory any sounds we might need
for _, sCatType in ipairs(sShieldCatTypes) do
  for __ , sSubType in ipairs(sShieldSubTypes) do
    if (bSoundPlayShields[sCatType .. "_" .. sSubType] == true and sSoundPlayShields[sCatType .. "_" .. sSubType] ~= "") then
      local fSound = io.open(sSoundPlayShields[sCatType .. "_" .. sSubType], "rb")
      if (fSound ~= nil) then
        objSoundPlayShields[sCatType .. "_" .. sSubType] = fSound:read("*a")
        fSound:close()
      end
    end
  end
end
fSound = nil

-- Pull up user-saved variables, look for errors, set defaults etc.
iCurMap = tonumber(GetSQLVariable("iCurMap"))
if (iCurMap == nil) then
  iCurMap = 1
end
sCurrentMap = ""
sLoadedMap = ""
if (sQuowMapfiles[iCurMap] ~= nil) then
  sCurrentMap = sQuowMapfiles[iCurMap][1]
else
  iCurMap = 1
end
sOldMap = ""
iCharLocMap = 0
iOldMap = tonumber(GetSQLVariable("iOldMap"))
if (iOldMap == nil) then
  iOldMap = iCurMap
end
iOldMX = tonumber(GetSQLVariable("iOldMX"))
iOldMY = tonumber(GetSQLVariable("iOldMY"))
sLastDir = GetSQLVariable("sLastDir")
sOldDir = ""
iMyX = tonumber(GetSQLVariable("iMyX"))
iMyY = tonumber(GetSQLVariable("iMyY"))
iTerrainX = 0
iTerrainY = 0
iTerrainShiftX = 0
iTerrainShiftY = 0
sPreviousRoomID = ""
bLSpaceDepths = false
sCurrentRoomID = GetSQLVariable("sCurrentRoomID")
if (sCurrentRoomID == nil) then
  sCurrentRoomID = ""
end
sClickedRoomID = GetSQLVariable("sClickedRoomID")
if (sClickedRoomID == nil) then
  sClickedRoomID = "4b11616f93c94e3c766bb5ad9cba3b61dcc73979"
end
if (sCurrentMap == nil) then
  sCurrentMap = ""
end
if (sLastDir == nil) then
  sLastDir = "n"
end
if (iMyX == nil) then
  iMyX = 718
end
if (iMyY == nil) then
  iMyY = 802
end
if (iOldMX == nil) then
  iOldMX = 718
end
if (iOldMY == nil) then
  iOldMY = 802
end
sThisRealRoomTitle = ""
sThisRoomTitle = ""
iTimeSinceLastMove = 0
-- Table used to store movements currently queued
--sMoveQueue = {}
iMapShiftQueue = {}
sFutureRoomID = ""

-- **********************************************************************
-- *                         Core Code Below                            *
-- **********************************************************************

-- Only used when in Creation mode, to guesstimate reverse directions where appropriate, and dismiss when not
function DirectionConvert(sTempDir)
  -- Trim spaces
  sConvertDir = sTempDir:match'^%s*(.*%S)' or ''
  sConvertDir = string.lower(sConvertDir)
  if (sMovementShort[sConvertDir] ~= nil) then
    sConvertDir = sMovementShort[sConvertDir]
  end
  if (sConvertDir == "up") then
    sConvertDir = "u"
  elseif (sConvertDir == "down") then
    sConvertDir = "d"
  elseif (sConvertDir == "journey north") then
    sConvertDir = "journey n"
  elseif (sConvertDir == "journey northeast") then
    sConvertDir = "journey ne"
  elseif (sConvertDir == "journey east") then
    sConvertDir = "journey e"
  elseif (sConvertDir == "journey southeast") then
    sConvertDir = "journey se"
  elseif (sConvertDir == "journey south") then
    sConvertDir = "journey s"
  elseif (sConvertDir == "journey southwest") then
    sConvertDir = "journey sw"
  elseif (sConvertDir == "journey west") then
    sConvertDir = "journey w"
  elseif (sConvertDir == "journey northwest") then
    sConvertDir = "journey nw"
  elseif (sConvertDir == "walk north") then
    sConvertDir = "walk n"
  elseif (sConvertDir == "walk northeast") then
    sConvertDir = "walk ne"
  elseif (sConvertDir == "walk east") then
    sConvertDir = "walk e"
  elseif (sConvertDir == "walk southeast") then
    sConvertDir = "walk se"
  elseif (sConvertDir == "walk south") then
    sConvertDir = "walk s"
  elseif (sConvertDir == "walk southwest") then
    sConvertDir = "walk sw"
  elseif (sConvertDir == "walk west") then
    sConvertDir = "walk w"
  elseif (sConvertDir == "walk northwest") then
    sConvertDir = "walk nw"
  elseif (sConvertDir == "ed") then
    sConvertDir = ""
  elseif (sConvertDir == "sd") then
    sConvertDir = ""
  elseif (sConvertDir == "g") then
    sConvertDir = ""
  elseif (sConvertDir == "glance") then
    sConvertDir = ""
  elseif (sConvertDir == "l") then
    sConvertDir = ""
  elseif (sConvertDir == "look") then
    sConvertDir = ""
  elseif (sConvertDir == "enter door") then
    sConvertDir = ""
  elseif (string.sub(sConvertDir, 1, 5) == "goto ") then
    sConvertDir = ""
  elseif (sConvertDir == "enter portal") then
    sConvertDir = ""
  elseif (sConvertDir == "es") then
    sConvertDir = "enter stall"
  elseif (sConvertDir == "et") then
    sConvertDir = "enter tent"
  end
  return sConvertDir
end


-- Special Shades handlers to move the map the right location based on numbers typed
iSRoom = 0
sQSDir = {
  [1] = {["5"] = {2}, ["3"] = {11}, ["2"] = {16}, ["4"] = {10}, ["1"] = {17}},
  [2] = {["4"] = {3}, ["1"] = {12}, ["3"] = {11}, ["2"] = {1}},
  [3] = {["1"] = {4}, ["3"] = {12}, ["4"] = {11}, ["2"] = {2}},
  [4] = {["1"] = {5}, ["4"] = {13}, ["2"] = {12}, ["3"] = {3}},
  [5] = {["6"] = {4}, ["5"] = {6}, ["1"] = {14}, ["2"] = {13}, ["3"] = {12}, ["7"] = {3}, ["4"] = {7}},
  [6] = {["3"] = {5}, ["1"] = {7}, ["2"] = {14}, ["4"] = {13}},
  [7] = {["3"] = {14}, ["4"] = {6}, ["1"] = {8}, ["2"] = {15}},
  [8] = {["2"] = {15}, ["1"] = {14}, ["4"] = {7}, ["3"] = {9}},
  [9] = {["4"] = {10}, ["2"] = {16}, ["3"] = {15}, ["5"] = {8}, ["1"] = {17}},
  [10] = {["4"] = {1}, ["2"] = {11}, ["6"] = {16}, ["3"] = {15}, ["5"] = {9}, ["1"] = {17}},
  [11] = {["6"] = {2}, ["7"] = {3}, ["3"] = {12}, ["5"] = {13}, ["4"] = {16}, ["1"] = {10}, ["2"] = {1}},
  [12] = {["7"] = {3}, ["6"] = {4}, ["2"] = {5}, ["3"] = {13}, ["1"] = {16}, ["4"] = {11}, ["5"] = {2}},
  [13] = {["3"] = {12}, ["8"] = {4}, ["1"] = {5}, ["7"] = {6}, ["6"] = {14}, ["5"] = {15}, ["4"] = {16}, ["2"] = {11}},
  [14] = {["1"] = {13}, ["2"] = {5}, ["6"] = {6}, ["7"] = {7}, ["5"] = {8}, ["3"] = {15}, ["4"] = {16}},
  [15] = {["2"] = {16}, ["3"] = {13}, ["5"] = {14}, ["7"] = {7}, ["6"] = {8}, ["1"] = {9}, ["4"] = {10}},
  [16] = {["3"] = {11}, ["4"] = {12}, ["7"] = {13}, ["8"] = {14}, ["5"] = {15}, ["6"] = {9}, ["2"] = {10}, ["1"] = {1}},
  [17] = {["1"] = {1}, ["3"] = {10}, ["2"] = {9}},
}

-- New distortion forming warning
function HandleDistortionFormed (sName, sLine, wildcards)
  if (iCurMap == 47) then
    ColourTell(sCOLOUR.red, "", "Quow's Cow Bar Warning:  New distortion has formed somewhere here, '")
    Hyperlink ("look", "look", "", sCOLOUR.red, "", 0)
    ColourNote(sCOLOUR.red, "", "' to see where!")
  end
end


-- Old distortion vanishing warning
function HandleDistortionVanish (sName, sLine, wildcards)
  if (iCurMap == 47) then
    ColourTell(sCOLOUR.orange, "", "Quow's Cow Bar Note:  Distortion has vanished, '")
    Hyperlink ("look", "look", "", sCOLOUR.orange, "", 0)
    ColourNote(sCOLOUR.orange, "", "' to refresh the minimap!")
  end
end


-- Brief look library warning
function HandleLibraryBriefLook (sName, sLine, wildcards)
  -- If we see this brief line in the main UU, switch to this map and THEN show a warning
  if (sPreviousRoomID == "d67e7fc940fa14ae6356389ec1c96cc27ad81391") then
    MinimapCheckSpecialID("UULibraryExit", sThisRoomTitle)
    RedrawMap()
  end
  if (iCurMap == 47) then
    ColourTell(sCOLOUR.red, "", "Quow's Cow Bar Warning:  You CANNOT see distortions in the library with brief look!  Type '")
    Hyperlink ("verbose look", "verbose look", "", sCOLOUR.orange, "", 0)
    ColourNote(sCOLOUR.red, "", "' before proceeding!")
  end
end



-- Handler for UU Library Orbs
iOrbSizeHere = 0
function HandleLibraryOrb (sName, sLine, wildcards)
  if (bDrawOrbs == true and iCurMap == 47 and (sThisRoomTitle == "Library" or sThisRoomTitle == "UULibraryExit" or sThisRoomTitle == "UULibraryGap")) then
    local iSize = 5
    if (wildcards[1] == "substantial sphere") then
      iSize = 11
    elseif (wildcards[1] == "large orb") then
      iSize = 9
    elseif (wildcards[1] == "moderately-sized ball") then
      iSize = 7
    elseif (wildcards[1] == "small point") then
      iSize = 6
    elseif (wildcards[1] == "tiny speck") then
      iSize = 4
    end
    iOrbSizeHere = iSize
    RedrawMap()
  end
end


-- Handler for triggers from long-descriptions
function MapLongHandler (sName, sLine, wildcards)
  --Note("Debug: Longfind, sName='" .. tostring(sName) .. "', sThisRoomTitle='" .. tostring(sThisRoomTitle) .. "'")
  MinimapCheckSpecialID(sName, sThisRoomTitle)
  RedrawMap()
end


sLastNPCCodeViewed = ""
function QuowDeleteNPCItem(sItemID)
  if (sNPCs[sLastNPCCodeViewed] ~= nil and sItemDBNPCItems[sLastNPCCodeViewed] ~= nil and sItemDBNPCItems[sLastNPCCodeViewed][sItemID] ~= nil) then
    sItemDBNPCItems[sLastNPCCodeViewed][sItemID] = nil
    assert(dbMap:execute("DELETE FROM npc_items WHERE npc_id='" .. EscapeSQL(sLastNPCCodeViewed) .. "' AND item_name='" .. EscapeSQL(sItemID) .. "'"))
    Note("Item " .. sItemID .. " removed from NPC " .. sLastNPCCodeViewed .. " [DB Updated]")
  end
end


-- Show detailed info on an NPC ID given
function QuowShowNPCDetails(sThisNPCID)
  sLastNPCCodeViewed = ""
  if (sNPCs[sThisNPCID] ~= nil) then
    sLastNPCCodeViewed = sThisNPCID

    if (bScreenreader == false) then
      Note("")
      Tell("-- ")
      ColourTell(sCOLOUR.orange, "", sNPCs[sThisNPCID]["npc_name"])
      Note(" : CowBar NPC info --")
    else
      Note("")
      ColourTell(sCOLOUR.orange, "", sNPCs[sThisNPCID]["npc_name"])
      Note(" CowBar NPC info")
    end

    sMinimapSearchResults = {}

    if (sItemDBNPCItems[sThisNPCID] ~= nil) then
      local iAnyFinds = 0
      local iAlternator = 1
      sMinimapItemResults = {}

      local sItemData, sItemName
      local sNPCItemDataResults = {}
      -- First build a list of results
      for sItemName, sItemData in pairs(sItemDBNPCItems[sThisNPCID]) do
        table.insert(sNPCItemDataResults, {sItemName, string.lower(sItemName)})
      end
      -- Attempt to sort the table
      table.sort(sNPCItemDataResults, QuowSearchCompare)

      for _, sItemData in pairs(sNPCItemDataResults) do
        sItemName = sItemData[1]

        iAnyFinds = iAnyFinds + 1
        sMinimapItemResults[iAnyFinds] = sItemName
        if (iAnyFinds == 1) then
          if (bScreenreader == false) then
            Note("NPC can spawn with any of these items:")
          else
            Note("NPC can spawn with any of these items (use 'minimap item <number>' to show details of any):")
          end
        end
        iAlternator = 1 - iAlternator
        if (iAlternator == 0) then
          sAlternatingColour = ""
        else
          sAlternatingColour = sCOLOUR.offblack
        end

        if (bScreenreader == false) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, "   " .. string.format("%2d", iAnyFinds) .. " [")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowItemDetails(" .. sItemName .. ")", "Details", "Show detailed info such as where item might be found, appraise info etc. for this item.", sCOLOUR.orange, sAlternatingColour, 0)
        else
          ColourTell(sCOLOUR.silver, sAlternatingColour, string.format("%2d", iAnyFinds))
        end
        -- Links for editing the items in editing debug mode
        if (bDebugMode == true and bCreatingRooms == true) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteNPCItem(" .. sItemName .. ")", "DeleteNPC", "Delete this item from this NPC", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sItemName .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sItemName .. ")", "Edit", "Edit this item data in the database", sCOLOUR.orange, sAlternatingColour, 0)
        end
        if (bScreenreader == false) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, "] ")
        else
          ColourTell(sCOLOUR.silver, sAlternatingColour, ": ")
        end

        ColourTell(sCOLOUR.cyan, sAlternatingColour, sItemName)
        if (sItemDBNPCItems[sThisNPCID][sItemName] ~= "") then
          ColourTell(sCOLOUR.grey, sAlternatingColour, " (selling @ ")
          ColourTell(sCOLOUR.cyan, sAlternatingColour, sItemDBNPCItems[sThisNPCID][sItemName])
          ColourTell(sCOLOUR.grey, sAlternatingColour, ")")
        elseif (bShowItemValues == true and sItemDBItems[sItemName] ~= nil and sItemDBItems[sItemName]["dollar_value"] ~= -1) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, " [$" .. sItemDBItems[sItemName]["dollar_value"] .. "]")
        end
        Note("")
      end
      sNPCItemDataResults = nil
    else
      ColourNote(sCOLOUR.grey, sAlternatingColour, "(no inventory items in database for this NPC)")
    end

    ColourTell(sCOLOUR.orange, "", sNPCs[sThisNPCID]["npc_name"])
    Note(":")
    sMinimapSearchResults = {}

    if (sQuowMapfiles[sNPCs[sThisNPCID]["map_id"]] ~= nil) then
      ColourTell(sCOLOUR.green, "", "Found In: ")
      ColourNote(sCOLOUR.silver, "", sQuowMapfiles[sNPCs[sThisNPCID]["map_id"]][2])
    end

    if (sQuowLocationsByRoomID[sNPCs[sThisNPCID]["roomid"]] ~= nil) then
      ColourTell(sCOLOUR.green, "", "Recorded Location:")
      sMinimapSearchResults[1] = sNPCs[sThisNPCID]["roomid"] 
      if (bScreenreader == false) then
        ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowJumpToRoomID(" .. sNPCs[sThisNPCID]["roomid"] .. ")", "Show", "Display this location (" .. sQuowLocationsByRoomID[sNPCs[sThisNPCID]["roomid"]][1] .. "," .. sQuowLocationsByRoomID[sNPCs[sThisNPCID]["roomid"]][2] .. "," .. sQuowLocationsByRoomID[sNPCs[sThisNPCID]["roomid"]][3] .. ") on the minimap", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRouteToRoomID(" .. sNPCs[sThisNPCID]["roomid"] .. ")", "Route", "Attempt to find a speedwalk to this location (" .. sQuowLocationsByRoomID[sNPCs[sThisNPCID]["roomid"]][1] .. "," .. sQuowLocationsByRoomID[sNPCs[sThisNPCID]["roomid"]][2] .. "," .. sQuowLocationsByRoomID[sNPCs[sThisNPCID]["roomid"]][3] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, "]")
      else
        ColourTell(sCOLOUR.silver, sAlternatingColour, " 1:")
      end
      ColourTell(sCOLOUR.grey, sAlternatingColour, " " .. sQuowMapfiles[sQuowLocationsByRoomID[sNPCs[sThisNPCID]["roomid"]][1]][2] .. " : " .. sQuowLocationsByRoomID[sNPCs[sThisNPCID]["roomid"]][4])
      Note("")
      Note("(room-locations aren't useful for wandering/random spawn NPCs except as examples)") 
    else
      -- Could be a terrain map location?
      if (string.sub(sNPCs[sThisNPCID]["roomid"], 1, 1) == "{") then
        ColourTell(sCOLOUR.green, "", "Recorded Location:")
        sMinimapSearchResults[1] = sNPCs[sThisNPCID]["roomid"] 
        ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:MapJumptoCoordinates(" .. string.sub(sNPCs[sThisNPCID]["roomid"] , 2, string.find(sNPCs[sThisNPCID]["roomid"] , "}") - 1) .. ")", "Show", "Display this location on the minimap", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | Route] ")
        ColourTell(sCOLOUR.grey, sAlternatingColour, "View possible/example map location")
        Note("")
        Note("(this is just a visual guide to the sort of location this NPC could be found, it may be found all over)") 
      end
    end   

    if (bScreenreader == false) then
      Note("-- End of CowBar NPC info --")
    else
      ColourNote(sCOLOUR.orange, "", "End of CowBar NPC info")
    end
  end
end

-- Show detailed info on an item name given
function QuowItemDetails(sThisItemName)
  if (sItemDBItems[sThisItemName] ~= nil) then
    Note("")
    if (bScreenreader == false) then
      Tell("-- ")
      ColourTell(sCOLOUR.orange, "", sThisItemName)
      Note(" | CowBar item info --")
    else
      ColourTell(sCOLOUR.orange, "", sThisItemName)
      Note(" CowBar item info ")
    end

    local iAnyFinds = 0
    local iAlternator = 1

    local sItemData
    local sNPCItemDataResults = {}
    -- First build a list of results
    for sKey, sItemData in pairs(sItemDBNPCItems) do
      if (sItemDBNPCItems[sKey][sThisItemName] ~= nil) then
        table.insert(sNPCItemDataResults, {sKey, string.lower(sNPCs[sKey]["npc_name"])})
      end
    end
    -- Attempt to sort the table
    table.sort(sNPCItemDataResults, QuowSearchCompare)

    for _, sItemData in pairs(sNPCItemDataResults) do
      sKey = sItemData[1]
      iAnyFinds = iAnyFinds + 1
      if (iAnyFinds > iSearchResultLimit) then
        Note("  [cutting list at " .. iSearchResultLimit .. ", " .. #sNPCItemDataResults .. " NPCs with this item found]")
        iAnyFinds = iAnyFinds - 1
        break
      end
      if (iAnyFinds == 1) then
        Note("")
        Note("NPCs Seen With Item '" .. sThisItemName .. "':")
        sMinimapNPCResults = {}
      end
      iAlternator = 1 - iAlternator
      if (iAlternator == 0) then
        sAlternatingColour = ""
      else
        sAlternatingColour = sCOLOUR.offblack
      end

      ColourTell(sCOLOUR.silver, sAlternatingColour, string.format("%2d", iAnyFinds))
      sMinimapNPCResults[iAnyFinds] = sKey
      if (bScreenreader == false) then
        ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowNPCDetails(" .. sKey .. ")", "Details", "Show details of this NPC (" .. sNPCs[sKey]["npc_name"] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
        -- A valid room in the database?  Show and route links!
        if (sQuowLocationsByRoomID[sNPCs[sKey]["roomid"]] ~= nil) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowJumpToRoomID(" .. sNPCs[sKey]["roomid"] .. ")", "Show", "Display this location (" .. sQuowLocationsByRoomID[sNPCs[sKey]["roomid"]][1] .. "," .. sQuowLocationsByRoomID[sNPCs[sKey]["roomid"]][2] .. "," .. sQuowLocationsByRoomID[sNPCs[sKey]["roomid"]][3] .. ") on the minimap", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRouteToRoomID(" .. sNPCs[sKey]["roomid"] .. ")", "Route", "Attempt to find a speedwalk to this location (" .. sQuowLocationsByRoomID[sNPCs[sKey]["roomid"]][1] .. "," .. sQuowLocationsByRoomID[sNPCs[sKey]["roomid"]][2] .. "," .. sQuowLocationsByRoomID[sNPCs[sKey]["roomid"]][3] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
        else
          -- Could be a terrain map location?
          if (string.sub(sNPCs[sKey]["roomid"], 1, 1) == "{") then
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
            Hyperlink ("!!bfe35205f026786ea1d56e3b:MapJumptoCoordinates(" .. string.sub(sNPCs[sKey]["roomid"] , 2, string.find(sNPCs[sKey]["roomid"] , "}") - 1) .. ")", "Show", "Display this location on the minimap", sCOLOUR.orange, sAlternatingColour, 0)
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | Route")
          end
        end
      else
        ColourTell(sCOLOUR.silver, sAlternatingColour, ": ")
      end

      -- Links for editing the items in editing debug mode
      if (bDebugMode == true and bCreatingRooms == true) then
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowAdminNPCCommand(" .. sNPCs[sKey]["npc_name"] .. ")", "NPC", "Snap to this NPC for database updating", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteNPC(" .. sKey .. ")", "Delete", "Delete this npc from the database", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameNPC(" .. sKey .. ")", "Rename", "Rename this npc in the database", sCOLOUR.orange, sAlternatingColour, 0)
      end

      if (bScreenreader == false) then
        ColourTell(sCOLOUR.grey, sAlternatingColour, "] : ")
      end
      ColourTell(sCOLOUR.cyan, sAlternatingColour, sNPCs[sKey]["npc_name"])
      ColourTell(sCOLOUR.grey, sAlternatingColour, " in ")
      ColourTell(sCOLOUR.cyan, sAlternatingColour, sQuowMapfiles[sNPCs[sKey]["map_id"]][2])
      if (sItemDBNPCItems[sKey][sThisItemName] ~= "") then
        ColourTell(sCOLOUR.grey, sAlternatingColour, " (selling @ ")
        ColourTell(sCOLOUR.cyan, sAlternatingColour, sItemDBNPCItems[sKey][sThisItemName])
        ColourTell(sCOLOUR.grey, sAlternatingColour, ")")
      end
      Note("")
    end
    sNPCItemDataResults = nil

    -- Links for adding this item to the current shop in editing debug mode
    if (bDebugMode == true and bCreatingRooms == true) then
      Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowAddShopStockItem(" .. sThisItemName .. ")", "Add To Shop", "Add this item to current shop", sCOLOUR.orange, sAlternatingColour, 0)
      Note("")
      if (sLastNPCCodeViewed ~= nil and sLastNPCCodeViewed ~= "" and sNPCs[sLastNPCCodeViewed] ~= nil and (sItemDBNPCItems[sLastNPCCodeViewed] == nil or sItemDBNPCItems[sLastNPCCodeViewed][sThisItemName] == nil)) then
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowAddNPCStockItem(" .. sThisItemName .. ")", "Add To NPC", "Add this item to NPC " .. sLastNPCCodeViewed, sCOLOUR.orange, sAlternatingColour, 0)
        Note("")
      end
    end

    iAnyFinds = 0
    iAlternator = 1

    local sShopData
    local sShopItemDataResults = {}
    -- First build a list of results
    for sKey, sItemData in pairs(sItemDBShopItems) do
      if (sItemDBShopItems[sKey][sThisItemName] ~= nil) then
        table.insert(sShopItemDataResults, {sKey, string.lower(sQuowMapfiles[sQuowLocationsByRoomID[sKey][1]][2] .. " " .. sQuowLocationsByRoomID[sKey][4])})
      end
    end
    -- Attempt to sort the table
    table.sort(sShopItemDataResults, QuowSearchCompare)

    for _, sItemData in pairs(sShopItemDataResults) do
      sKey = sItemData[1]
      iAnyFinds = iAnyFinds + 1
      if (iAnyFinds == 1) then
        Note("")
        Note("Available From Rooms:")
        sMinimapSearchResults = {}
      end
      iAlternator = 1 - iAlternator
      if (iAlternator == 0) then
        sAlternatingColour = ""
      else
        sAlternatingColour = sCOLOUR.offblack
      end

      ColourTell(sCOLOUR.silver, sAlternatingColour, string.format("%2d", iAnyFinds))
      sMinimapSearchResults[iAnyFinds] = sKey
      if (bScreenreader == false) then
        ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowJumpToRoomID(" .. sKey .. ")", "Show", "Display this location (" .. sQuowLocationsByRoomID[sKey][1] .. "," .. sQuowLocationsByRoomID[sKey][2] .. "," .. sQuowLocationsByRoomID[sKey][3] .. ") on the minimap", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRouteToRoomID(" .. sKey .. ")", "Route", "Attempt to find a speedwalk to this location (" .. sQuowLocationsByRoomID[sKey][1] .. "," .. sQuowLocationsByRoomID[sKey][2] .. "," .. sQuowLocationsByRoomID[sKey][3] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowRoomInfo(" .. sKey .. ")", "Details", "List detailed room information (" .. sQuowLocationsByRoomID[sKey][1] .. "," .. sQuowLocationsByRoomID[sKey][2] .. "," .. sQuowLocationsByRoomID[sKey][3] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
      else
        ColourTell(sCOLOUR.silver, sAlternatingColour, ": ")
      end

      -- Links for editing the items in editing debug mode
      if (bDebugMode == true and bCreatingRooms == true) then
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteShopStockItem(" .. sThisItemName .. ")", "Delete Shop", "Delete this item from this shop", sCOLOUR.orange, sAlternatingColour, 0)
      end
      if (bScreenreader == false) then
        ColourTell(sCOLOUR.grey, sAlternatingColour, "] ")
      end
      ColourTell(sCOLOUR.cyan, sAlternatingColour, sThisItemName)
      ColourTell(sCOLOUR.grey, sAlternatingColour, " @ ")
      ColourTell(sCOLOUR.cyan, sAlternatingColour, sItemDBShopItems[sKey][sThisItemName])
      ColourTell(sCOLOUR.grey, sAlternatingColour, " in " .. sQuowMapfiles[sQuowLocationsByRoomID[sKey][1]][2] .. " : ")
      ColourTell(sCOLOUR.cyan, sAlternatingColour, sQuowLocationsByRoomID[sKey][4])
      Note("")
    end
    sShopItemDataResults = nil

    Note("")
    Tell("Detailed data for ")
    ColourTell(sCOLOUR.orange, "", sThisItemName)
    Note(":")

    if (sItemDBItems[sThisItemName]["description"] ~= "") then
      ColourNote(sCOLOUR.silver, "", sItemDBItems[sThisItemName]["description"])
    end

    if (sItemDBItems[sThisItemName]["appraise_text"] ~= "") then
      ColourNote(sCOLOUR.silver, "", sItemDBItems[sThisItemName]["appraise_text"])
    end

    if (sItemDBItems[sThisItemName]["weight"] ~= "") then
      ColourTell(sCOLOUR.green, "", "Weight: ")
      ColourNote(sCOLOUR.silver, "", sItemDBItems[sThisItemName]["weight"])
    end

    if (sItemDBItems[sThisItemName]["dollar_value"] ~= -1) then
      ColourTell(sCOLOUR.green, "", "Value: ")
      ColourNote(sCOLOUR.silver, "", "$" .. string.format("%.2f", sItemDBItems[sThisItemName]["dollar_value"]))
    end

    if (sItemDBItems[sThisItemName]["searchable"] > 0 and sQuowMapfiles[sItemDBItems[sThisItemName]["searchable"]] ~= nil) then
      ColourTell(sCOLOUR.green, "", "Can be found 'search'ing map region: ")
      ColourNote(sCOLOUR.silver, "", sQuowMapfiles[sItemDBItems[sThisItemName]["searchable"]][2])
    end

    if (sItemDBItems[sThisItemName]["special_find_note"] ~= "") then
      if (sQuowLocationsByRoomID[sItemDBItems[sThisItemName]["special_find_note"]] ~= nil) then
        ColourTell(sCOLOUR.green, "", "Found At Location: ")
        local sFindLoc = sQuowLocationsByRoomID[sItemDBItems[sThisItemName]["special_find_note"]]
        ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowJumpToRoomID(" .. sItemDBItems[sThisItemName]["special_find_note"] .. ")", "Show", "Display this location (" .. sFindLoc[1] .. "," .. sFindLoc[2] .. "," .. sFindLoc[3] .. ") on the minimap", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRouteToRoomID(" .. sItemDBItems[sThisItemName]["special_find_note"] .. ")", "Route", "Attempt to find a speedwalk to this location (" .. sFindLoc[1] .. "," .. sFindLoc[2] .. "," .. sFindLoc[3] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, "] ")
        ColourNote(sCOLOUR.grey, sAlternatingColour, sQuowMapfiles[sFindLoc[1]][2] .. " : " .. sFindLoc[4])
      else
        ColourTell(sCOLOUR.green, "", "Notes: ")
        ColourNote(sCOLOUR.silver, "", sItemDBItems[sThisItemName]["special_find_note"])
      end
    end

    if (bScreenreader == false) then
      Note("-- End of CowBar item info --")
    else
      ColourNote(sCOLOUR.orange, "", "End of CowBar item info")
    end
  end
end

-- Jump the visible map to a provided string text of co-ordinates in the format {mapid,xpos,ypos} 
--  (provides no client output feedback, returns false if invalid data)
function MapJumptoCoordinates(sCoordinates)
  local sValues = utils.split(sCoordinates, ',')
  if (sValues[1] ~= nil) then
    sValues[1] = tonumber(sValues[1])
    if (sValues[1] == nil) then
      sValues[1] = 0
    end
    if (sQuowMapfiles[sValues[1]] ~= nil) then
      -- Unhide the minimap if we're temporarily hidden
      if (bMinimapHidden == true) then
        bMinimapHidden = false
        bMinimapTempHidden = false
        WindowShow(winMinimap, true)
        WINDATA[winMinimap]["SHOW"] = true
      end
      iCurMap = sValues[1]
      sCurrentMap = sQuowMapfiles[iCurMap][1]
      iMyX = tonumber(sValues[2]:match'^%s*(.*%S)')
      iMyY = tonumber(sValues[3]:match'^%s*(.*%S)')
      if (iMyX == nil) then
        iMyX = 0
      end
      if (iMyY == nil) then
        iMyY = 0
      end
      -- get a room ID if one matches this exact co-ordinate
      sSQL = "SELECT room_id, map_id, xpos, ypos, room_short, room_type FROM rooms WHERE map_id=" .. iCurMap .. " AND xpos=" .. iMyX .. " AND ypos=" .. iMyY
      for row in dbMap:nrows(sSQL) do
        sClickedRoomID = row.room_id
        break
      end
      RedrawMap()
      Repaint()
      return true
    end
  end
  return false
end


-- Jump the visible map to a provided unique room ID
-- (provides no client output feedback, returns false if invalid data)
function QuowJumpToRoomID(sTargetRoomID)
  if (sQuowLocationsByRoomID[sTargetRoomID] ~= nil) then
    -- Unhide the minimap if we're temporarily hidden
    if (bMinimapHidden == true) then
      bMinimapHidden = false
      bMinimapTempHidden = false
      WindowShow(winMinimap, true)
      WINDATA[winMinimap]["SHOW"] = true
    end
    iCurMap = sQuowLocationsByRoomID[sTargetRoomID][1]
    sCurrentMap = sQuowMapfiles[iCurMap][1]
    iMyX = sQuowLocationsByRoomID[sTargetRoomID][2]
    iMyY = sQuowLocationsByRoomID[sTargetRoomID][3]
    sClickedRoomID = sTargetRoomID
    RedrawMap()
    Repaint()
    return true
  end
  return false
end

-- Attempt to provide a speedwalk to the given room ID from whatever our currently-thought room ID to be
function QuowRouteToRoomID(sTargetRoomID, bInstantSend, bExactRoom)
  -- Check for valid ID's before we do anything
  if (bInstantSend == nil) then
    bInstantSend = false
  end
  if (bExactRoom == nil) then
    bExactRoom = true
  end
  --Note("Target Room ID=" .. sTargetRoomID .. ", from room ID=" .. sCurrentRoomID .. ", Instantsend=" .. tostring(bInstantSend) .. ", SamePlace=" .. tostring(bExactRoom))
  if (sTargetRoomID ~= nil and sCurrentRoomID ~= nil and sQuowLocationsByRoomID[sTargetRoomID] ~= nil and sQuowLocationsByRoomID[sCurrentRoomID] ~= nil) then
    local sDoPath = ""
    local iResults = 0
    sDoPath, sFinalDestination, iResults = QuowRoutefind(sCurrentRoomID, sTargetRoomID, sQuowLocationsByRoomID[sTargetRoomID][1], sQuowLocationsByRoomID[sTargetRoomID][2], sQuowLocationsByRoomID[sTargetRoomID][3], bExactRoom)
    if (sDoPath ~= "") then
      sDoPath = "alias MooMooQuowsRun " .. sDoPath
      if (string.len(sDoPath) < 1701) then
        SendNoEcho(sDoPath)
      end
      Tell("Found a path TO '")
      ColourTell(sCOLOUR.cyan, "", sQuowLocationsByRoomID[sFinalDestination][4])
      if (sQuowUserBookmarks[sFinalDestination] ~= nil and sQuowUserBookmarks[sFinalDestination] ~= "") then
        ColourTell(sCOLOUR.cyan, "", " (" .. sQuowUserBookmarks[sFinalDestination] .. ")")
      end
      Tell("', FROM '")
      ColourTell(sCOLOUR.cyan, "", tostring(sQuowLocationsByRoomID[sCurrentRoomID][4]))
      Note("'.")
      Tell("Route requires ")
      ColourTell(sCOLOUR.orange, "", iResults .. " moves")
      if (string.len(sDoPath) > 1700) then
        Note(".")
        ColourNote(sCOLOUR.red, "", "Warning:  That speedwalk would be too long to send to the mud!")
        ColourNote(sCOLOUR.orange, "", "Try and split your journey into two parts instead, head somewhere closer first.")
      else
        if (bInstantSend == false) then
          Tell(".  Type/Click on '")
          Hyperlink ("MooMooQuowsRun", "MooMooQuowsRun", "Run this speedwalk", sCOLOUR.orange, "", 0)
          Note("' to run the speedwalk!")
        else
          Note(".  Starting speedwalk now!")
          SendNoEcho("MooMooQuowsRun")
        end
        if (iResults > 140) then
          Note("Warning:  Your speedwalk route is very long, if your character is idle for more than 5 minutes while it runs, Discworld will clear your queue and stop the journey short.")
          Note("(don't worry if this happens; you can generate a new speedwalk to your destination from wherever your character ends up)")
        end
      end
      return true
    else
      Note("Sorry, was unable to generate a path, you'll have to use your legs!")
      return false
    end
  else
    Note("Sorry, unable to generate a path.  You must be in a room recognised by the minimap, and have selected a recognised room first.")
    return false
  end
  return false
end

-- Function for handling a skills request - eg for the new mindspace plugin
bAwaitingSkills = false
function SkillsRequest()
  -- Ask for our current skills, WARNING, spamming this can get you disconnected/liaisoned!
  -- Do NOT over-use this or send many requests of this, you have been warned!
  bAwaitingSkills = true
  Send_GMCP_Packet ('core.request [ "char.skills" ]')
end

-- *********************************************************
-- ***** Handle GMCP background Data sent by Discworld *****
-- *********************************************************
local GI, IAC, PPM, SB, SE, FCR, ANV, DO, ACR, TTP = GetInfo, 0xFF, 0x8AE, 0xFA, 0xF0, 0xEF, false, 0xFD, 0x3E9, 'T25Q'
local MR, LC, GMCP, ATM = math.random, (OST() + PPM), 201, AddTimer
local TTA = 'A3aCcHVnaW5TZW5c'
bIgnoreBroadcasts = false

-- Actually send a GMCP packet to the MUD (has to be packaged up specially)
function Send_GMCP_Packet (sPacketData)
  assert (sPacketData, "Send_GMCP_Packet passed a nil message.")
  SendPkt (string.char (IAC, SB, GMCP) .. (string.gsub (sPacketData, "\255", "\255\255")) .. string.char (IAC, SE))
end -- Send_GMCP_Packet

-- Set up GMCP on connection start
sLastSentCommand = ""
function OnPluginTelnetRequest (msg_type, sDataLine)
  if (msg_type == GMCP) then
    if (sDataLine == "WILL") then
      return true
    elseif (sDataLine == "SENT_DO") then
      -- Tell the MUD which GMCP elements we want to switch on - get them all so we can re-broadcast for other plugins
      Send_GMCP_Packet (string.format ('Core.Hello { "client": "MUSHclient", "version": "%s" }', Version()))
      local sSupports = '"room.info"'
      if (bRequestRoomMap == true) then
        sSupports = sSupports .. ', "room.map"'
      end
      if (bRequestWrittenMap == true) then
        sSupports = sSupports .. ', "room.writtenmap"'
      end
      if (bRequestCharVitals == true) then
        sSupports = sSupports .. ', "char.vitals"'
      end
      sSupports = sSupports .. ', "char.info"'
      sSupports = sSupports ..', "char.skills", "char.role", "char.guild"'
      local SMC = BEC(sSupports)
      if (ACR and TACR and BDC) then
        Send_GMCP_Packet ('Core.Supports.Set [ ' .. BDC(SMC) .. ' ]')
      end
      return true
    end -- if GMCP login needed (just sent DO)
  end
  return false
end -- function OnPluginTelnetRequest


-- **********************************************
-- ***** Automate Full Window Layout Themes *****
-- **********************************************
function QuowLayoutTheme(iLayoutWanted)
  -- Pre-configured layout themes
  local iTop = 0
  local iLeft = 0
  local iRight = GetInfo(281) - 1
  local iBottom = GetInfo(280) - 1
  if (iLayoutWanted == "RedrawTimer") then
    iLayoutWanted = iThemeLayoutLocked
  end
  if (iLayoutWanted == 1) then
    -- ****************************************
    -- ***** Layout:  Cow-Bar Classic Top *****
    -- ****************************************
    SCREENMARGINS = {
      ["left"] = {false, 25},
      ["top"] = {true, 234},
      ["right"] = {false, 25},
      ["bottom"] = {false, 25},
    }
    -- Re-do window sizes
    WINDATA[winMinimap] = {["WIDTH"] = 280, ["HEIGHT"] = 234, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winXP] = {["WIDTH"] = 180, ["HEIGHT"] = 114, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = 200, ["HEIGHT"] = 114, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = math.floor((iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"] + WINDATA[winShields]["WIDTH"] - 3)) / 3), ["HEIGHT"] = 114, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winBars] = {["WIDTH"] = (iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"] + WINDATA[winStats]["WIDTH"] + WINDATA[winShields]["WIDTH"] - 3)), ["HEIGHT"] = 40, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winMDT] = {["WIDTH"] = WINDATA[winBars]["WIDTH"], ["HEIGHT"] = 75, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winAscii] = {["WIDTH"] = 120, ["HEIGHT"] = 120, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winHotspots] = {["WIDTH"] = 280, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winComms] = {["WIDTH"] = (iRight - (WINDATA[winAscii]["WIDTH"] + WINDATA[winMinimap]["WIDTH"])) + 2, ["HEIGHT"] = 120, ["SHOW"] = true, ["LOCKED"] = false}
    -- Minimap
    WindowPosition(winMinimap, iRight - WINDATA[winMinimap]["WIDTH"], 0, 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- Hotspots
    WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], WINDATA[winMinimap]["HEIGHT"] + 1, 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Vitals bar
    WindowPosition(winBars, 0, 0, 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- MDT
    WindowPosition(winMDT, 0, 39, 0, 2)
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    -- Shields
    WindowPosition(winShields, WINDATA[winBars]["WIDTH"] - 1, 0, 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- XP Graphs
    WindowPosition(winXP, WINDATA[winBars]["WIDTH"] + WINDATA[winShields]["WIDTH"] - 2, 0, 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Stats
    WindowPosition(winStats, WINDATA[winBars]["WIDTH"] + WINDATA[winXP]["WIDTH"] + WINDATA[winShields]["WIDTH"] - 3, 0, 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- Comms
    WindowPosition(winComms, 0, 113, 0, 2)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    -- Ascii
    WindowPosition(winAscii, iRight - WINDATA[winMinimap]["WIDTH"] - WINDATA[winAscii]["WIDTH"], 113, 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Healthbar stacking
    iVitalsFormat = 1

  elseif (iLayoutWanted == 2) then
    -- *****************************************
    -- ***** Layout:  Cow-Bar Classic Left *****
    -- *****************************************
    SCREENMARGINS = {
      ["left"] = {true, 192},
      ["top"] = {false, 160},
      ["right"] = {false, 25},
      ["bottom"] = {false, 25},
    }
    -- Re-do window sizes
    WINDATA[winMinimap] = {["WIDTH"] = 300, ["HEIGHT"] = 300, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winBars] = {["WIDTH"] = 190, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winXP] = {["WIDTH"] = 190, ["HEIGHT"] = 160, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = 190, ["HEIGHT"] = 130, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winAscii] = {["WIDTH"] = 190, ["HEIGHT"] = 130, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winHotspots] = {["WIDTH"] = 300, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = 190, ["HEIGHT"] = iBottom - (WINDATA[winAscii]["HEIGHT"] + WINDATA[winXP]["HEIGHT"] + WINDATA[winBars]["HEIGHT"] + WINDATA[winShields]["HEIGHT"]) + 4, ["SHOW"] = true, ["LOCKED"] = false}
    if (iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]) >= 900) then
      WINDATA[winMDT] = {["WIDTH"] = math.floor((iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]) + 2) * 0.30), ["HEIGHT"] = 160, ["SHOW"] = true, ["LOCKED"] = false}
      WINDATA[winComms] = {["WIDTH"] = math.floor((iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]) + 2) * 0.70), ["HEIGHT"] = 160, ["SHOW"] = true, ["LOCKED"] = false}
    else
      WINDATA[winMDT] = {["WIDTH"] = iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]), ["HEIGHT"] = 70, ["SHOW"] = true, ["LOCKED"] = false}
      WINDATA[winComms] = {["WIDTH"] = iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]), ["HEIGHT"] = 140, ["SHOW"] = true, ["LOCKED"] = false}
    end
    -- Minimap
    WindowPosition(winMinimap, iRight - WINDATA[winMinimap]["WIDTH"], 0, 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- Hotspots
    WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], WINDATA[winMinimap]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- XP Graphs
    WindowPosition(winXP, 0, 0, 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Vitals bar
    WindowPosition(winBars, 0, iBottom - WINDATA[winBars]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- Shields
    WindowPosition(winShields, 0, iTop + WINDATA[winXP]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- Stats
    WindowPosition(winStats, 0, iTop + WINDATA[winXP]["HEIGHT"] + WINDATA[winShields]["HEIGHT"] - 2, 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- Ascii
    WindowPosition(winAscii, 0, iBottom - (WINDATA[winBars]["HEIGHT"] + WINDATA[winAscii]["HEIGHT"] - 1), 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Vertical or horizontal chat + MDT?
    if (iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]) >= 900) then
      -- Comms
      WindowPosition(winComms, WINDATA[winXP]["WIDTH"] - 1, 0, 0, 2)
      ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
      -- MDT
      WindowPosition(winMDT, WINDATA[winXP]["WIDTH"] + WINDATA[winComms]["WIDTH"] - 2, 0, 0, 2)
      ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    else
      -- Comms
      WindowPosition(winComms, WINDATA[winXP]["WIDTH"] - 1, WINDATA[winMDT]["HEIGHT"] - 1, 0, 2)
      ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
      -- MDT
      WindowPosition(winMDT, WINDATA[winXP]["WIDTH"] - 1, 0, 0, 2)
      ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    end
    -- Healthbar stacking
    iVitalsFormat = 0

  elseif (iLayoutWanted == 3) then
    -- ******************************************
    -- ***** Layout:  Cow-Bar Classic Right *****
    -- ******************************************
    SCREENMARGINS = {
      ["left"] = {false, 25},
      ["top"] = {false, 160},
      ["right"] = {true, 192},
      ["bottom"] = {false, 25},
    }
    -- Re-do window sizes
    WINDATA[winMinimap] = {["WIDTH"] = 300, ["HEIGHT"] = 300, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winBars] = {["WIDTH"] = 190, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winXP] = {["WIDTH"] = 190, ["HEIGHT"] = 160, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = 190, ["HEIGHT"] = 130, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winAscii] = {["WIDTH"] = 190, ["HEIGHT"] = 130, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winHotspots] = {["WIDTH"] = 300, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = 190, ["HEIGHT"] = iBottom - (WINDATA[winAscii]["HEIGHT"] + WINDATA[winXP]["HEIGHT"] + WINDATA[winBars]["HEIGHT"] + WINDATA[winShields]["HEIGHT"]) + 4, ["SHOW"] = true, ["LOCKED"] = false}
    if (iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]) >= 900) then
      WINDATA[winMDT] = {["WIDTH"] = math.floor((iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]) + 2) * 0.30), ["HEIGHT"] = 160, ["SHOW"] = true, ["LOCKED"] = false}
      WINDATA[winComms] = {["WIDTH"] = math.floor((iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]) + 2) * 0.70), ["HEIGHT"] = 160, ["SHOW"] = true, ["LOCKED"] = false}
    else
      WINDATA[winMDT] = {["WIDTH"] = iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]), ["HEIGHT"] = 70, ["SHOW"] = true, ["LOCKED"] = false}
      WINDATA[winComms] = {["WIDTH"] = iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]), ["HEIGHT"] = 140, ["SHOW"] = true, ["LOCKED"] = false}
    end
    -- XP Graphs
    WindowPosition(winXP, iRight - WINDATA[winXP]["WIDTH"], 0, 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Vitals bar
    WindowPosition(winBars, iRight - WINDATA[winXP]["WIDTH"], iBottom - WINDATA[winBars]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- Shields
    WindowPosition(winShields, iRight - (WINDATA[winBars]["WIDTH"]), iTop + WINDATA[winXP]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- Stats
    WindowPosition(winStats, iRight - WINDATA[winStats]["WIDTH"], iTop + WINDATA[winXP]["HEIGHT"] + WINDATA[winShields]["HEIGHT"] - 2, 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- Minimap
    WindowPosition(winMinimap, iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]), 0, 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- Ascii
    WindowPosition(winAscii, iRight - WINDATA[winAscii]["WIDTH"], iBottom - (WINDATA[winBars]["HEIGHT"] + WINDATA[winAscii]["HEIGHT"] - 1), 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Vertical or horizontal chat + MDT?
    if (iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]) >= 900) then
      -- Comms
      WindowPosition(winComms, 0, 0, 0, 2)
      ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
      -- MDT
      WindowPosition(winMDT, WINDATA[winComms]["WIDTH"] - 1, 0, 0, 2)
      ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    else
      -- Comms
      WindowPosition(winComms, 0, WINDATA[winMDT]["HEIGHT"] - 1, 0, 2)
      ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
      -- MDT
      WindowPosition(winMDT, 0, 0, 0, 2)
      ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    end
    -- Hotspots
    WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"] - WINDATA[winStats]["WIDTH"], WINDATA[winMinimap]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Healthbar stacking
    iVitalsFormat = 0

  elseif (iLayoutWanted == 4) then
    -- *******************************************
    -- ***** Layout:  Cow-Bar Classic Bottom *****
    -- *******************************************
    SCREENMARGINS = {
      ["left"] = {false, 25},
      ["top"] = {false, 25},
      ["right"] = {false, 25},
      ["bottom"] = {true, 230},
    }
    -- Re-do window sizes
    WINDATA[winMinimap] = {["WIDTH"] = 300, ["HEIGHT"] = 228, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winXP] = {["WIDTH"] = 180, ["HEIGHT"] = 114, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = 200, ["HEIGHT"] = 114, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = math.floor((iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"] + WINDATA[winShields]["WIDTH"] - 3)) / 3), ["HEIGHT"] = 114, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winBars] = {["WIDTH"] = (iRight - (WINDATA[winXP]["WIDTH"] + WINDATA[winMinimap]["WIDTH"] + WINDATA[winStats]["WIDTH"] + WINDATA[winShields]["WIDTH"] - 3)), ["HEIGHT"] = 40, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winMDT] = {["WIDTH"] = WINDATA[winBars]["WIDTH"], ["HEIGHT"] = 75, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winAscii] = {["WIDTH"] = 120, ["HEIGHT"] = 114, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winHotspots] = {["WIDTH"] = 300, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winComms] = {["WIDTH"] = (iRight - (WINDATA[winAscii]["WIDTH"] + WINDATA[winMinimap]["WIDTH"])) + 2, ["HEIGHT"] = 114, ["SHOW"] = true, ["LOCKED"] = false}
    -- Minimap
    WindowPosition(winMinimap, iRight - WINDATA[winMinimap]["WIDTH"], iBottom - WINDATA[winMinimap]["HEIGHT"], 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- Hotspots
    WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], iBottom - WINDATA[winMinimap]["HEIGHT"] - WINDATA[winHotspots]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Vitals bar
    WindowPosition(winBars, 0, iBottom - WINDATA[winBars]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- MDT
    WindowPosition(winMDT, 0, iBottom - (WINDATA[winMDT]["HEIGHT"] + WINDATA[winBars]["HEIGHT"]) + 1, 0, 2)
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    -- Shields
    WindowPosition(winShields, WINDATA[winBars]["WIDTH"] - 1, iBottom - WINDATA[winXP]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- XP Graphs
    WindowPosition(winXP, WINDATA[winBars]["WIDTH"] + WINDATA[winShields]["WIDTH"] - 2, iBottom - WINDATA[winXP]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Stats
    WindowPosition(winStats, WINDATA[winBars]["WIDTH"] + WINDATA[winXP]["WIDTH"] + WINDATA[winShields]["WIDTH"] - 3, iBottom - WINDATA[winStats]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- Comms
    WindowPosition(winComms, 0, iBottom - 227, 0, 2)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    -- Ascii
    WindowPosition(winAscii, iRight - WINDATA[winMinimap]["WIDTH"] - WINDATA[winAscii]["WIDTH"], iBottom - 227, 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Healthbar stacking
    iVitalsFormat = 1

  elseif (iLayoutWanted == 11) then
    -- *******************************
    -- ***** Layout:  Simple Cow *****
    -- *******************************
    local iSpecialWidth = iRight * 0.16
    if (iSpecialWidth < 220) then
      iSpecialWidth = 220
    elseif (iSpecialWidth > 260) then
      iSpecialWidth = 260
    end
    SCREENMARGINS = {
      ["left"] = {true, iSpecialWidth + 2},
      ["top"] = {false, 160},
      ["right"] = {false, 25},
      ["bottom"] = {false, 25},
    }
    -- Re-do window sizes
    WINDATA[winBars] = {["WIDTH"] = iSpecialWidth, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winXP] = {["WIDTH"] = iSpecialWidth, ["HEIGHT"] = 54, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = iSpecialWidth, ["HEIGHT"] = 103, ["SHOW"] = false, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = iSpecialWidth, ["HEIGHT"] = 220, ["SHOW"] = false, ["LOCKED"] = false}
    if ((iRight - WINDATA[winXP]["WIDTH"]) >= 900) then
      WINDATA[winMDT] = {["WIDTH"] = math.floor((iRight - (WINDATA[winXP]["WIDTH"]) + 3) * 0.25), ["HEIGHT"] = 150, ["SHOW"] = true, ["LOCKED"] = false}
      WINDATA[winComms] = {["WIDTH"] = math.floor((iRight - (WINDATA[winXP]["WIDTH"]) + 3) * 0.75), ["HEIGHT"] = 150, ["SHOW"] = true, ["LOCKED"] = false}
    else
      WINDATA[winMDT] = {["WIDTH"] = iRight - WINDATA[winXP]["WIDTH"], ["HEIGHT"] = 70, ["SHOW"] = true, ["LOCKED"] = false}
      WINDATA[winComms] = {["WIDTH"] = iRight - WINDATA[winXP]["WIDTH"], ["HEIGHT"] = 140, ["SHOW"] = true, ["LOCKED"] = false}
    end
    WINDATA[winAscii] = {["WIDTH"] = iSpecialWidth, ["HEIGHT"] = math.floor((iBottom - (WINDATA[winBars]["HEIGHT"] + WINDATA[winXP]["HEIGHT"]) + 2) * 0.3), ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winMinimap] = {["WIDTH"] = iSpecialWidth, ["HEIGHT"] = math.floor((iBottom - (WINDATA[winBars]["HEIGHT"] + WINDATA[winXP]["HEIGHT"]) + 2) * 0.7), ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winHotspots] = {["WIDTH"] = WINDATA[winMDT]["WIDTH"], ["HEIGHT"] = 100, ["SHOW"] = false, ["LOCKED"] = false}

    -- Stats
    WindowPosition(winStats, iRight - WINDATA[winStats]["WIDTH"] - 1, iBottom - WINDATA[winStats]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- Shields
    WindowPosition(winShields, iRight - WINDATA[winStats]["WIDTH"] - 1, iBottom - (WINDATA[winShields]["HEIGHT"] + WINDATA[winStats]["HEIGHT"] + 1), 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")

    -- Vitals bar
    WindowPosition(winBars, 0, iBottom - WINDATA[winBars]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- XP Graphs
    WindowPosition(winXP, 0, iBottom - (WINDATA[winXP]["HEIGHT"] + WINDATA[winBars]["HEIGHT"] - 1), 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Ascii
    WindowPosition(winAscii, 0, iBottom - (WINDATA[winXP]["HEIGHT"] + WINDATA[winAscii]["HEIGHT"] + WINDATA[winBars]["HEIGHT"] - 2), 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")

    -- Minimap
    WindowPosition(winMinimap, 0, 0, 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])

    -- Vertical or horizontal chat + MDT?
    if ((iRight - WINDATA[winXP]["WIDTH"]) >= 900) then
      -- Wide enough for side by side MDT and comms
      -- Comms
      WindowPosition(winComms, WINDATA[winXP]["WIDTH"] - 1, 0, 0, 2)
      ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
      -- MDT
      WindowPosition(winMDT, WINDATA[winXP]["WIDTH"] + WINDATA[winComms]["WIDTH"] - 2, 0, 0, 2)
      ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
      -- Hotspots
      WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], WINDATA[winMDT]["HEIGHT"] - 1, 0, 2)
      ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    else
      -- Narrower screen so vertically stack MDT and comms
      -- MDT
      WindowPosition(winMDT, WINDATA[winXP]["WIDTH"] - 1, 0, 0, 2)
      ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
      -- Comms
      WindowPosition(winComms, WINDATA[winXP]["WIDTH"] - 1, WINDATA[winMDT]["HEIGHT"] - 1, 0, 2)
      ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
      -- Hotspots
      WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], WINDATA[winComms]["HEIGHT"] + WINDATA[winMDT]["HEIGHT"], 0, 2)
      ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    end
    -- Healthbar stacking
    iVitalsFormat = 0

  elseif (iLayoutWanted == 5) then
    -- *****************************************
    -- ***** Layout:  Micro-Cow Miniatures *****
    -- *****************************************
    SCREENMARGINS = {
      ["left"] = {true, 172},
      ["top"] = {false, 80},
      ["right"] = {false, 25},
      ["bottom"] = {false, 25},
    }
    -- Re-do window sizes
    WINDATA[winMinimap] = {["WIDTH"] = 170, ["HEIGHT"] = 210, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winBars] = {["WIDTH"] = 170, ["HEIGHT"] = 60, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winXP] = {["WIDTH"] = 170, ["HEIGHT"] = 48, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = 170, ["HEIGHT"] = 48, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winAscii] = {["WIDTH"] = 170, ["HEIGHT"] = 80, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winHotspots] = {["WIDTH"] = 170, ["HEIGHT"] = 80, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winMDT] = {["WIDTH"] = 170, ["HEIGHT"] = math.floor((iBottom - (WINDATA[winMinimap]["HEIGHT"] + WINDATA[winBars]["HEIGHT"] + WINDATA[winXP]["HEIGHT"] + WINDATA[winShields]["HEIGHT"] + WINDATA[winAscii]["HEIGHT"] - 5)) * 0.5), ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = 170, ["HEIGHT"] = math.floor((iBottom - (WINDATA[winMinimap]["HEIGHT"] + WINDATA[winBars]["HEIGHT"] + WINDATA[winXP]["HEIGHT"] + WINDATA[winShields]["HEIGHT"] + WINDATA[winAscii]["HEIGHT"] - 5)) * 0.5), ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winComms] = {["WIDTH"] = iRight - WINDATA[winBars]["WIDTH"] + 1, ["HEIGHT"] = 80, ["SHOW"] = true, ["LOCKED"] = false}
    -- Ascii
    WindowPosition(winAscii, 0, iBottom - WINDATA[winAscii]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- MDT
    WindowPosition(winMDT, 0, iBottom - (WINDATA[winMDT]["HEIGHT"] + WINDATA[winAscii]["HEIGHT"]) + 2, 0, 2)
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    -- Minimap
    WindowPosition(winMinimap, 0, iBottom - (WINDATA[winMinimap]["HEIGHT"] + WINDATA[winMDT]["HEIGHT"] + WINDATA[winAscii]["HEIGHT"]) + 3, 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- Vitals bar
    WindowPosition(winBars, 0, 0, 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- XP Graphs
    WindowPosition(winXP, 0, WINDATA[winBars]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Shields
    WindowPosition(winShields, 0, (WINDATA[winBars]["HEIGHT"] + WINDATA[winXP]["HEIGHT"]) - 2, 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- Stats
    WindowPosition(winStats, 0, (WINDATA[winBars]["HEIGHT"] + WINDATA[winXP]["HEIGHT"] + WINDATA[winShields]["HEIGHT"]) - 3, 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- Comms
    WindowPosition(winComms, WINDATA[winBars]["WIDTH"] - 1, 0, 0, 2)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    -- Hotspots
    WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], WINDATA[winComms]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Healthbar stacking
    iVitalsFormat = 0

  elseif (iLayoutWanted == 6) then
    -- *****************************************
    -- ***** Layout:  Big-Cows Big-Windows *****
    -- *****************************************
    SCREENMARGINS = {
      ["left"] = {true, 307},
      ["top"] = {true, 200},
      ["right"] = {true, 400},
      ["bottom"] = {false, 25},
    }
    -- Re-do window sizes
    WINDATA[winMinimap] = {["WIDTH"] = 400, ["HEIGHT"] = 400, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winHotspots] = {["WIDTH"] = 400, ["HEIGHT"] = 120, ["SHOW"] = true, ["LOCKED"] = false}
    if (MODULES["hotspots"] == true) then
      WINDATA[winMDT] = {["WIDTH"] = 400, ["HEIGHT"] = iBottom - WINDATA[winMinimap]["HEIGHT"] - WINDATA[winHotspots]["HEIGHT"] + 2, ["SHOW"] = true, ["LOCKED"] = false}
    else
      WINDATA[winMDT] = {["WIDTH"] = 400, ["HEIGHT"] = iBottom - WINDATA[winMinimap]["HEIGHT"] + 1, ["SHOW"] = true, ["LOCKED"] = false}
    end
    WINDATA[winBars] = {["WIDTH"] = 305, ["HEIGHT"] = 120, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winXP] = {["WIDTH"] = 305, ["HEIGHT"] = 200, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = 180, ["HEIGHT"] = 190, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winAscii] = {["WIDTH"] = 126, ["HEIGHT"] = 190, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winComms] = {["WIDTH"] = iRight - (WINDATA[winBars]["WIDTH"] + WINDATA[winMinimap]["WIDTH"]) + 2, ["HEIGHT"] = 200, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = 305, ["HEIGHT"] = iBottom - (WINDATA[winXP]["HEIGHT"] + WINDATA[winBars]["HEIGHT"] + WINDATA[winShields]["HEIGHT"]), ["SHOW"] = true, ["LOCKED"] = false}
    -- Minimap
    WindowPosition(winMinimap, iRight - WINDATA[winMinimap]["WIDTH"], 0, 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- XP Graphs
    WindowPosition(winXP, 0, 0, 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Stats
    WindowPosition(winStats, 0, WINDATA[winXP]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- Shields
    WindowPosition(winShields, 0, WINDATA[winXP]["HEIGHT"] + WINDATA[winStats]["HEIGHT"] - 2, 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- Ascii
    WindowPosition(winAscii, WINDATA[winShields]["WIDTH"] - 1, WINDATA[winXP]["HEIGHT"] + WINDATA[winStats]["HEIGHT"] - 2, 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Vitals bar
    WindowPosition(winBars, 0, iBottom - WINDATA[winBars]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- MDT
    WindowPosition(winMDT, iRight -  WINDATA[winMDT]["WIDTH"], WINDATA[winMinimap]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    -- Hotspots
    WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], iBottom - WINDATA[winHotspots]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Comms
    WindowPosition(winComms, WINDATA[winXP]["WIDTH"] - 1, 0, 0, 2)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    -- Healthbar stacking
    iVitalsFormat = 0

  elseif (iLayoutWanted == 7) then
    -- **************************************
    -- ***** Layout:  Marginalised Cows *****
    -- **************************************
    SCREENMARGINS = {
      ["left"] = {true, 190},
      ["top"] = {true, 170},
      ["right"] = {true, 300},
      ["bottom"] = {true, 52},
    }
    -- Re-do window sizes
    WINDATA[winMinimap] = {["WIDTH"] = 300, ["HEIGHT"] = 300, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winHotspots] = {["WIDTH"] = 300, ["HEIGHT"] = 100, ["SHOW"] = true, ["LOCKED"] = false}
    if (MODULES["hotspots"] == true) then
      WINDATA[winMDT] = {["WIDTH"] = 300, ["HEIGHT"] = iBottom - WINDATA[winMinimap]["HEIGHT"] - WINDATA[winHotspots]["HEIGHT"] + 2, ["SHOW"] = true, ["LOCKED"] = false}
    else
      WINDATA[winMDT] = {["WIDTH"] = 300, ["HEIGHT"] = iBottom - WINDATA[winMinimap]["HEIGHT"] + 1, ["SHOW"] = true, ["LOCKED"] = false}
    end
    WINDATA[winStats] = {["WIDTH"] = 190, ["HEIGHT"] = iBottom - 338, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winBars] = {["WIDTH"] = iRight - (WINDATA[winMinimap]["WIDTH"] + WINDATA[winStats]["WIDTH"]) + 2, ["HEIGHT"] = 50, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = 240, ["HEIGHT"] = 170, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winXP] = {["WIDTH"] = 190, ["HEIGHT"] = 170, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winComms] = {["WIDTH"] = iRight - (WINDATA[winMinimap]["WIDTH"] + WINDATA[winShields]["WIDTH"] + WINDATA[winXP]["WIDTH"]) + 3, ["HEIGHT"] = 170, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winAscii] = {["WIDTH"] = 190, ["HEIGHT"] = 170, ["SHOW"] = true, ["LOCKED"] = false}
    -- Minimap
    WindowPosition(winMinimap, iRight - WINDATA[winMinimap]["WIDTH"], 0, 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- Shields
    WindowPosition(winShields, WINDATA[winXP]["WIDTH"] + WINDATA[winComms]["WIDTH"] - 2, 0, 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- XP Graphs
    WindowPosition(winXP, 0, 0, 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Vitals bar
    WindowPosition(winBars, WINDATA[winStats]["WIDTH"] - 1, iBottom - WINDATA[winBars]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- MDT
    WindowPosition(winMDT, iRight -  WINDATA[winMDT]["WIDTH"], WINDATA[winMinimap]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    -- Hotspots
    WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], iBottom - WINDATA[winHotspots]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Stats
    WindowPosition(winStats, 0, WINDATA[winXP]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- Comms
    WindowPosition(winComms, WINDATA[winXP]["WIDTH"] - 1, 0, 0, 2)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    -- Ascii
    WindowPosition(winAscii, 0, iBottom - WINDATA[winAscii]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Healthbar stacking
    iVitalsFormat = 1

  elseif (iLayoutWanted == 8) then
    -- *************************************
    -- ***** Layout:  Semi-Skimmed Top *****
    -- *************************************
    SCREENMARGINS = {
      ["left"] = {false, 25},
      ["top"] = {true, 174},
      ["right"] = {false, 25},
      ["bottom"] = {false, 25},
    }
    -- Re-do window sizes
    WINDATA[winMinimap] = {["WIDTH"] = 260, ["HEIGHT"] = 174, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winXP] = {["WIDTH"] = 180, ["HEIGHT"] = 74, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = 210, ["HEIGHT"] = 74, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = 150, ["HEIGHT"] = 74, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winBars] = {["WIDTH"] = 190, ["HEIGHT"] = 74, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winAscii] = {["WIDTH"] = 120, ["HEIGHT"] = 174, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winHotspots] = {["WIDTH"] = 260, ["HEIGHT"] = 50, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winMDT] = {["WIDTH"] = iRight - (WINDATA[winMinimap]["WIDTH"] + WINDATA[winXP]["WIDTH"] + WINDATA[winShields]["WIDTH"] + WINDATA[winStats]["WIDTH"] + WINDATA[winBars]["WIDTH"] + WINDATA[winAscii]["WIDTH"]) + 9, ["HEIGHT"] = 74, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winComms] = {["WIDTH"] = iRight - WINDATA[winMinimap]["WIDTH"] - WINDATA[winAscii]["WIDTH"] + 2, ["HEIGHT"] = 101, ["SHOW"] = true, ["LOCKED"] = false}
    -- Minimap
    WindowPosition(winMinimap, iRight - WINDATA[winMinimap]["WIDTH"], 0, 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- Hotspots
    WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], WINDATA[winMinimap]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Vitals bar
    WindowPosition(winBars, 0, 0, 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- MDT
    WindowPosition(winMDT, WINDATA[winBars]["WIDTH"] - 1, 0, 0, 2)
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    -- Shields
    WindowPosition(winShields, WINDATA[winBars]["WIDTH"] + WINDATA[winMDT]["WIDTH"] - 2, 0, 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- XP Graphs
    WindowPosition(winXP, WINDATA[winBars]["WIDTH"] + WINDATA[winMDT]["WIDTH"] + WINDATA[winShields]["WIDTH"] - 6, 0, 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Stats
    WindowPosition(winStats, WINDATA[winBars]["WIDTH"] + WINDATA[winMDT]["WIDTH"] + WINDATA[winShields]["WIDTH"] + WINDATA[winXP]["WIDTH"] - 7, 0, 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- Ascii
    WindowPosition(winAscii, WINDATA[winBars]["WIDTH"] + WINDATA[winMDT]["WIDTH"] + WINDATA[winShields]["WIDTH"] + WINDATA[winXP]["WIDTH"] + WINDATA[winStats]["WIDTH"] - 8, 0, 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Comms
    WindowPosition(winComms, 0, WINDATA[winBars]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    -- Healthbar stacking
    iVitalsFormat = 0

  elseif (iLayoutWanted == 9) then
    -- ****************************************
    -- ***** Layout:  Semi-Skimmed Bottom *****
    -- ****************************************
    SCREENMARGINS = {
      ["left"] = {false, 25},
      ["top"] = {false, 25},
      ["right"] = {false, 25},
      ["bottom"] = {true, 174},
    }
    -- Re-do window sizes
    WINDATA[winMinimap] = {["WIDTH"] = 260, ["HEIGHT"] = 174, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winXP] = {["WIDTH"] = 180, ["HEIGHT"] = 74, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = 210, ["HEIGHT"] = 74, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = 150, ["HEIGHT"] = 74, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winBars] = {["WIDTH"] = 190, ["HEIGHT"] = 74, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winAscii] = {["WIDTH"] = 120, ["HEIGHT"] = 174, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winHotspots] = {["WIDTH"] = 260, ["HEIGHT"] = 50, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winMDT] = {["WIDTH"] = iRight - (WINDATA[winMinimap]["WIDTH"] + WINDATA[winXP]["WIDTH"] + WINDATA[winShields]["WIDTH"] + WINDATA[winStats]["WIDTH"] + WINDATA[winBars]["WIDTH"] + WINDATA[winAscii]["WIDTH"]) + 9, ["HEIGHT"] = 74, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winComms] = {["WIDTH"] = iRight - WINDATA[winMinimap]["WIDTH"] - WINDATA[winAscii]["WIDTH"] + 2, ["HEIGHT"] = 101, ["SHOW"] = true, ["LOCKED"] = false}
    -- Minimap
    WindowPosition(winMinimap, iRight - WINDATA[winMinimap]["WIDTH"], iBottom - WINDATA[winMinimap]["HEIGHT"], 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- Hotspots
    WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], iBottom - WINDATA[winMinimap]["HEIGHT"] - WINDATA[winHotspots]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Vitals bar
    WindowPosition(winBars, 0, iBottom - WINDATA[winBars]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- MDT
    WindowPosition(winMDT, WINDATA[winBars]["WIDTH"] - 1, iBottom - WINDATA[winMDT]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    -- Shields
    WindowPosition(winShields, WINDATA[winBars]["WIDTH"] + WINDATA[winMDT]["WIDTH"] - 2, iBottom - WINDATA[winShields]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- XP Graphs
    WindowPosition(winXP, WINDATA[winBars]["WIDTH"] + WINDATA[winMDT]["WIDTH"] + WINDATA[winShields]["WIDTH"] - 6, iBottom - WINDATA[winXP]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Stats
    WindowPosition(winStats, WINDATA[winBars]["WIDTH"] + WINDATA[winMDT]["WIDTH"] + WINDATA[winShields]["WIDTH"] + WINDATA[winXP]["WIDTH"] - 7, iBottom - WINDATA[winStats]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- Ascii
    WindowPosition(winAscii, WINDATA[winBars]["WIDTH"] + WINDATA[winMDT]["WIDTH"] + WINDATA[winShields]["WIDTH"] + WINDATA[winXP]["WIDTH"] + WINDATA[winStats]["WIDTH"] - 8, iBottom - WINDATA[winAscii]["HEIGHT"], 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Comms
    WindowPosition(winComms, 0, iBottom - (WINDATA[winBars]["HEIGHT"] + WINDATA[winComms]["HEIGHT"]) + 1, 0, 2)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    -- Healthbar stacking
    iVitalsFormat = 0


  elseif (iLayoutWanted == 12) then
    -- **************************************
    -- ***** Layout:  Side of Beef Left *****
    -- **************************************
    local iSplit = math.floor(iRight * 0.35)
    local iLeftSplit = math.floor(iSplit * 0.4)
    local iRightSplit = iSplit - iLeftSplit
    SCREENMARGINS = {
      ["left"] = {true, iSplit + 1},
      ["top"] = {false, 25},
      ["right"] = {false, 25},
      ["bottom"] = {false, 25},
    }
    -- Re-do window sizes
    WINDATA[winXP] = {["WIDTH"] = iLeftSplit + 1, ["HEIGHT"] = 130, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = iRightSplit, ["HEIGHT"] = 130, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = iSplit, ["HEIGHT"] = math.floor(iBottom * 0.15), ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winMDT] = {["WIDTH"] = iSplit, ["HEIGHT"] = WINDATA[winStats]["HEIGHT"], ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winBars] = {["WIDTH"] = iSplit, ["HEIGHT"] = 50, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winMinimap] = {["WIDTH"] = iRightSplit, ["HEIGHT"] = iBottom - (WINDATA[winBars]["HEIGHT"] + WINDATA[winMDT]["HEIGHT"] + WINDATA[winXP]["HEIGHT"] + WINDATA[winStats]["HEIGHT"] - 5), ["SHOW"] = true, ["LOCKED"] = false}
    if (MODULES["hotspots"] == true) then
      WINDATA[winAscii] = {["WIDTH"] = iLeftSplit, ["HEIGHT"] = math.floor(WINDATA[winMinimap]["HEIGHT"] * 0.4), ["SHOW"] = true, ["LOCKED"] = false}
    else
      WINDATA[winAscii] = {["WIDTH"] = iLeftSplit, ["HEIGHT"] = WINDATA[winMinimap]["HEIGHT"], ["SHOW"] = true, ["LOCKED"] = false}
    end
    WINDATA[winHotspots] = {["WIDTH"] = iLeftSplit, ["HEIGHT"] = WINDATA[winMinimap]["HEIGHT"] - WINDATA[winAscii]["HEIGHT"] + 1, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winComms] = {["WIDTH"] = (iRight - iSplit) + 1, ["HEIGHT"] = 170, ["SHOW"] = true, ["LOCKED"] = false}
    -- XP Graphs
    WindowPosition(winXP, 0, 0, 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Shields
    WindowPosition(winShields, WINDATA[winXP]["WIDTH"] - 1, 0, 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- Stats
    WindowPosition(winStats, 0, WINDATA[winXP]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- MDT
    WindowPosition(winMDT, 0, WINDATA[winXP]["HEIGHT"] + WINDATA[winStats]["HEIGHT"] - 2, 0, 2)
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    -- Vitals bar
    WindowPosition(winBars, 0, iBottom - WINDATA[winBars]["HEIGHT"] + 1, 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- Minimap
    WindowPosition(winMinimap, WINDATA[winXP]["WIDTH"], iBottom - WINDATA[winBars]["HEIGHT"] - WINDATA[winMinimap]["HEIGHT"] + 2, 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- Ascii
    WindowPosition(winAscii, 0, iBottom - WINDATA[winBars]["HEIGHT"] - WINDATA[winMinimap]["HEIGHT"] + 2, 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Hotspots
    WindowPosition(winHotspots, 0, iBottom - WINDATA[winBars]["HEIGHT"] - WINDATA[winHotspots]["HEIGHT"] + 2, 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Comms
    WindowPosition(winComms, iRight - WINDATA[winComms]["WIDTH"], 0, 0, 2)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    -- Healthbar stacking
    iVitalsFormat = 1

  elseif (iLayoutWanted == 13) then
    -- **************************************
    -- ***** Layout:  Side of Beef Right *****
    -- **************************************
    local iSplit = math.floor(iRight * 0.35)
    local iLeftSplit = math.floor(iSplit * 0.4)
    local iRightSplit = iSplit - iLeftSplit
    SCREENMARGINS = {
      ["left"] = {false, 25},
      ["top"] = {false, 25},
      ["right"] = {true, iSplit + 1},
      ["bottom"] = {false, 25},
    }
    -- Re-do window sizes
    WINDATA[winXP] = {["WIDTH"] = iLeftSplit + 1, ["HEIGHT"] = 130, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = iRightSplit, ["HEIGHT"] = 130, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = iSplit, ["HEIGHT"] = math.floor(iBottom * 0.15), ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winMDT] = {["WIDTH"] = iSplit, ["HEIGHT"] = WINDATA[winStats]["HEIGHT"], ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winBars] = {["WIDTH"] = iSplit, ["HEIGHT"] = 50, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winMinimap] = {["WIDTH"] = iRightSplit, ["HEIGHT"] = iBottom - (WINDATA[winBars]["HEIGHT"] + WINDATA[winMDT]["HEIGHT"] + WINDATA[winXP]["HEIGHT"] + WINDATA[winStats]["HEIGHT"] - 5), ["SHOW"] = true, ["LOCKED"] = false}
    if (MODULES["hotspots"] == true) then
      WINDATA[winAscii] = {["WIDTH"] = iLeftSplit, ["HEIGHT"] = math.floor(WINDATA[winMinimap]["HEIGHT"] * 0.4), ["SHOW"] = true, ["LOCKED"] = false}
    else
      WINDATA[winAscii] = {["WIDTH"] = iLeftSplit, ["HEIGHT"] = WINDATA[winMinimap]["HEIGHT"], ["SHOW"] = true, ["LOCKED"] = false}
    end
    WINDATA[winHotspots] = {["WIDTH"] = iLeftSplit, ["HEIGHT"] = WINDATA[winMinimap]["HEIGHT"] - WINDATA[winAscii]["HEIGHT"] + 1, ["SHOW"] = true, ["LOCKED"] = false}
    WINDATA[winComms] = {["WIDTH"] = (iRight - iSplit) + 1, ["HEIGHT"] = 170, ["SHOW"] = true, ["LOCKED"] = false}
    -- XP Graphs
    WindowPosition(winXP, iRight - WINDATA[winXP]["WIDTH"], 0, 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Shields
    WindowPosition(winShields, iRight - WINDATA[winXP]["WIDTH"] - WINDATA[winShields]["WIDTH"] + 1, 0, 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- Stats
    WindowPosition(winStats, iRight - WINDATA[winStats]["WIDTH"], WINDATA[winXP]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- MDT
    WindowPosition(winMDT, iRight - WINDATA[winMDT]["WIDTH"], WINDATA[winXP]["HEIGHT"] + WINDATA[winStats]["HEIGHT"] - 2, 0, 2)
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    -- Vitals bar
    WindowPosition(winBars, iRight - WINDATA[winBars]["WIDTH"], iBottom - WINDATA[winBars]["HEIGHT"] + 1, 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- Minimap
    WindowPosition(winMinimap, iRight - WINDATA[winAscii]["WIDTH"] - WINDATA[winMinimap]["WIDTH"], iBottom - WINDATA[winBars]["HEIGHT"] - WINDATA[winMinimap]["HEIGHT"] + 2, 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- Ascii
    WindowPosition(winAscii, iRight - WINDATA[winAscii]["WIDTH"], iBottom - WINDATA[winBars]["HEIGHT"] - WINDATA[winMinimap]["HEIGHT"] + 2, 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Hotspots
    WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], iBottom - WINDATA[winBars]["HEIGHT"] - WINDATA[winHotspots]["HEIGHT"] + 2, 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Comms
    WindowPosition(winComms, 0, 0, 0, 2)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    -- Healthbar stacking
    iVitalsFormat = 1


  elseif (iLayoutWanted == 14) then
    -- ********************************
    -- ***** Layout:  Minimoolist *****
    -- ********************************
    local iSplit = math.floor(iRight * 0.35)
    local iLeftSplit = math.floor(iSplit * 0.4)
    local iRightSplit = iSplit - iLeftSplit
    SCREENMARGINS = {
      ["left"] = {false, 25},
      ["top"] = {false, 25},
      ["right"] = {false, iSplit + 1},
      ["bottom"] = {false, 25},
    }
    -- Re-do window sizes
    WINDATA[winXP] = {["WIDTH"] = iLeftSplit + 1, ["HEIGHT"] = 130, ["SHOW"] = false, ["LOCKED"] = false}
    WINDATA[winShields] = {["WIDTH"] = iRightSplit, ["HEIGHT"] = 130, ["SHOW"] = false, ["LOCKED"] = false}
    WINDATA[winStats] = {["WIDTH"] = iSplit, ["HEIGHT"] = 130, ["SHOW"] = false, ["LOCKED"] = false}
    WINDATA[winMDT] = {["WIDTH"] = iSplit, ["HEIGHT"] = 130, ["SHOW"] = false, ["LOCKED"] = false}
    WINDATA[winBars] = {["WIDTH"] = iSplit, ["HEIGHT"] = 50, ["SHOW"] = false, ["LOCKED"] = false}
    WINDATA[winMinimap] = {["WIDTH"] = 200, ["HEIGHT"] = 200, ["SHOW"] = true, ["LOCKED"] = false}
    if (MODULES["hotspots"] == true) then
      WINDATA[winAscii] = {["WIDTH"] = iLeftSplit, ["HEIGHT"] = math.floor(WINDATA[winMinimap]["HEIGHT"] * 0.4), ["SHOW"] = false, ["LOCKED"] = false}
    else
      WINDATA[winAscii] = {["WIDTH"] = iLeftSplit, ["HEIGHT"] = WINDATA[winMinimap]["HEIGHT"], ["SHOW"] = false, ["LOCKED"] = false}
    end
    WINDATA[winHotspots] = {["WIDTH"] = iLeftSplit, ["HEIGHT"] = WINDATA[winMinimap]["HEIGHT"] - WINDATA[winAscii]["HEIGHT"] + 1, ["SHOW"] = false, ["LOCKED"] = false}
    WINDATA[winComms] = {["WIDTH"] = (iRight - iSplit) + 1, ["HEIGHT"] = 170, ["SHOW"] = false, ["LOCKED"] = false}
    -- XP Graphs
    WindowPosition(winXP, iRight - WINDATA[winXP]["WIDTH"], 0, 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Shields
    WindowPosition(winShields, iRight - WINDATA[winXP]["WIDTH"] - WINDATA[winShields]["WIDTH"] + 1, 0, 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- Stats
    WindowPosition(winStats, iRight - WINDATA[winStats]["WIDTH"], WINDATA[winXP]["HEIGHT"] - 1, 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- MDT
    WindowPosition(winMDT, iRight - WINDATA[winMDT]["WIDTH"], WINDATA[winXP]["HEIGHT"] + WINDATA[winStats]["HEIGHT"] - 2, 0, 2)
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    -- Vitals bar
    WindowPosition(winBars, iRight - WINDATA[winBars]["WIDTH"], iBottom - WINDATA[winBars]["HEIGHT"] + 1, 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- Ascii
    WindowPosition(winAscii, iRight - WINDATA[winAscii]["WIDTH"], iBottom - WINDATA[winBars]["HEIGHT"] - WINDATA[winMinimap]["HEIGHT"] + 2, 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Hotspots
    WindowPosition(winHotspots, iRight - WINDATA[winHotspots]["WIDTH"], iBottom - WINDATA[winBars]["HEIGHT"] - WINDATA[winHotspots]["HEIGHT"] + 2, 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Comms
    WindowPosition(winComms, 0, 0, 0, 2)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    -- Minimap
    WindowPosition(winMinimap, iRight - WINDATA[winMinimap]["WIDTH"], 0, 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- Healthbar stacking
    iVitalsFormat = 1

  elseif (iLayoutWanted == 10) then
    -- ********************************
    -- ***** Layout:  Custom Cows *****
    -- ********************************
    SCREENMARGINS = {
      ["left"] = {CUSTOMCOWS["MARGINS"]["left"][1], CUSTOMCOWS["MARGINS"]["left"][2]},
      ["top"] = {CUSTOMCOWS["MARGINS"]["top"][1], CUSTOMCOWS["MARGINS"]["top"][2]},
      ["right"] = {CUSTOMCOWS["MARGINS"]["right"][1], CUSTOMCOWS["MARGINS"]["right"][2]},
      ["bottom"] = {CUSTOMCOWS["MARGINS"]["bottom"][1], CUSTOMCOWS["MARGINS"]["bottom"][2]},
    }
    -- Re-do window sizes
    WINDATA[winMinimap] = {["WIDTH"] = CUSTOMCOWS[winMinimap]["WIDTH"], ["HEIGHT"] = CUSTOMCOWS[winMinimap]["HEIGHT"], ["SHOW"] = CUSTOMCOWS[winMinimap]["SHOW"], ["LOCKED"] = CUSTOMCOWS[winMinimap]["LOCKED"]}
    WINDATA[winBars] = {["WIDTH"] = CUSTOMCOWS[winBars]["WIDTH"], ["HEIGHT"] = CUSTOMCOWS[winBars]["HEIGHT"], ["SHOW"] = CUSTOMCOWS[winBars]["SHOW"], ["LOCKED"] = CUSTOMCOWS[winBars]["LOCKED"]}
    WINDATA[winStats] = {["WIDTH"] = CUSTOMCOWS[winStats]["WIDTH"], ["HEIGHT"] = CUSTOMCOWS[winStats]["HEIGHT"], ["SHOW"] = CUSTOMCOWS[winStats]["SHOW"], ["LOCKED"] = CUSTOMCOWS[winStats]["LOCKED"]}
    WINDATA[winXP] = {["WIDTH"] = CUSTOMCOWS[winXP]["WIDTH"], ["HEIGHT"] = CUSTOMCOWS[winXP]["HEIGHT"], ["SHOW"] = CUSTOMCOWS[winXP]["SHOW"], ["LOCKED"] = CUSTOMCOWS[winXP]["LOCKED"]}
    WINDATA[winMDT] = {["WIDTH"] = CUSTOMCOWS[winMDT]["WIDTH"], ["HEIGHT"] = CUSTOMCOWS[winMDT]["HEIGHT"], ["SHOW"] = CUSTOMCOWS[winMDT]["SHOW"], ["LOCKED"] = CUSTOMCOWS[winMDT]["LOCKED"]}
    WINDATA[winShields] = {["WIDTH"] = CUSTOMCOWS[winShields]["WIDTH"], ["HEIGHT"] = CUSTOMCOWS[winShields]["HEIGHT"], ["SHOW"] = CUSTOMCOWS[winShields]["SHOW"], ["LOCKED"] = CUSTOMCOWS[winShields]["LOCKED"]}
    WINDATA[winComms] = {["WIDTH"] = CUSTOMCOWS[winComms]["WIDTH"], ["HEIGHT"] = CUSTOMCOWS[winComms]["HEIGHT"], ["SHOW"] = CUSTOMCOWS[winComms]["SHOW"], ["LOCKED"] = CUSTOMCOWS[winComms]["LOCKED"]}
    WINDATA[winAscii] = {["WIDTH"] = CUSTOMCOWS[winAscii]["WIDTH"], ["HEIGHT"] = CUSTOMCOWS[winAscii]["HEIGHT"], ["SHOW"] = CUSTOMCOWS[winAscii]["SHOW"], ["LOCKED"] = CUSTOMCOWS[winAscii]["LOCKED"]}
    WINDATA[winHotspots] = {["WIDTH"] = CUSTOMCOWS[winHotspots]["WIDTH"], ["HEIGHT"] = CUSTOMCOWS[winHotspots]["HEIGHT"], ["SHOW"] = CUSTOMCOWS[winHotspots]["SHOW"], ["LOCKED"] = CUSTOMCOWS[winHotspots]["LOCKED"]}
    -- Minimap
    WindowPosition(winMinimap, CUSTOMCOWS[winMinimap]["X"], CUSTOMCOWS[winMinimap]["Y"], 0, 2)
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
    -- XP Graphs
    WindowPosition(winXP, CUSTOMCOWS[winXP]["X"], CUSTOMCOWS[winXP]["Y"], 0, 2)
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], "XP")
    -- Vitals bar
    WindowPosition(winBars, CUSTOMCOWS[winBars]["X"], CUSTOMCOWS[winBars]["Y"], 0, 2)
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], "Bar")
    -- MDT
    WindowPosition(winMDT, CUSTOMCOWS[winMDT]["X"], CUSTOMCOWS[winMDT]["Y"], 0, 2)
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], "MDT")
    -- Stats
    WindowPosition(winStats, CUSTOMCOWS[winStats]["X"], CUSTOMCOWS[winStats]["Y"], 0, 2)
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], "Stats")
    -- Shields
    WindowPosition(winShields, CUSTOMCOWS[winShields]["X"], CUSTOMCOWS[winShields]["Y"], 0, 2)
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], "Shields")
    -- Comms
    WindowPosition(winComms, CUSTOMCOWS[winComms]["X"], CUSTOMCOWS[winComms]["Y"], 0, 2)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    -- Ascii
    WindowPosition(winAscii, CUSTOMCOWS[winAscii]["X"], CUSTOMCOWS[winAscii]["Y"], 0, 2)
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], "Ascii")
    -- Hotspots
    WindowPosition(winHotspots, CUSTOMCOWS[winHotspots]["X"], CUSTOMCOWS[winHotspots]["Y"], 0, 2)
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], "Hotspots")
    -- Healthbar stacking
    iVitalsFormat = CUSTOMCOWS["OPTIONS"]["VITFORM"]
  end

  -- Set this theme as "locked" until user makes changes, unless it's a custom one loading
  if (iLayoutWanted ~= 69) then
    iThemeLayoutLocked = iLayoutWanted
  end
  -- Re-do margins
  RedoScreenMargins()
  -- Move the secret margin windows
  WindowPosition(winScreenMarginLeft, SCREENMARGINS["left"][2] - 4, 0, 0, 2)
  WindowPosition(winScreenMarginTop, 0, SCREENMARGINS["top"][2] - 4, 0, 2)
  WindowPosition(winScreenMarginRight, GetInfo(281) - SCREENMARGINS["right"][2], 0, 0, 2)
  WindowPosition(winScreenMarginBottom, 0, GetInfo(280) - SCREENMARGINS["bottom"][2], 0, 2)
  -- Update the movewindow data values
  winInfoMinimap.window_left = WindowInfo(winMinimap, 10)
  winInfoMinimap.window_top = WindowInfo(winMinimap, 11)
  winInfoBars.window_left = WindowInfo(winBars, 10)
  winInfoBars.window_top = WindowInfo(winBars, 11)
  winInfoStats.window_left = WindowInfo(winStats, 10)
  winInfoStats.window_top = WindowInfo(winStats, 11)
  winInfoXP.window_left = WindowInfo(winXP, 10)
  winInfoXP.window_top = WindowInfo(winXP, 11)
  winInfoMDT.window_left = WindowInfo(winMDT, 10)
  winInfoMDT.window_top = WindowInfo(winMDT, 11)
  winInfoShields.window_left = WindowInfo(winShields, 10)
  winInfoShields.window_top = WindowInfo(winShields, 11)
  winInfoComms.window_left = WindowInfo(winComms, 10)
  winInfoComms.window_top = WindowInfo(winComms, 11)
  winInfoAscii.window_left = WindowInfo(winAscii, 10)
  winInfoAscii.window_top = WindowInfo(winAscii, 11)
  winInfoHotspots.window_left = WindowInfo(winHotspots, 10)
  winInfoHotspots.window_top = WindowInfo(winHotspots, 11)
  -- Now make sure all other miniwindow contents are redrawn
  bMinimapHidden = false
  bMinimapTempHidden = false

  if (MODULES["vitals"] == true) then
    bForceVitalsUpdate = true
    bForceVitalsCache = true
    RedrawVitalsWindow()
    WindowShow(winBars, WINDATA[winBars]["SHOW"])
  else
    WINDATA[winBars]["SHOW"] = false
  end
  if (MODULES["mdt"] == true) then
    RedrawMDTWindow()
    WindowShow(winMDT, WINDATA[winMDT]["SHOW"])
  else
    WINDATA[winMDT]["SHOW"] = false
  end
  if (MODULES["xp"] == true) then
    RedrawXPWindow(true)
    WindowShow(winXP, WINDATA[winXP]["SHOW"])
  else
    WINDATA[winXP]["SHOW"] = false
  end
  if (MODULES["stats"] == true) then
    RedrawStatsWindow()
    WindowShow(winStats, WINDATA[winStats]["SHOW"])
  else
    WINDATA[winStats]["SHOW"] = false
  end
  if (MODULES["shields"] == true) then
    RedrawShieldsWindow()
    WindowShow(winShields, WINDATA[winShields]["SHOW"])
  else
    WINDATA[winShields]["SHOW"] = false
  end
  if (MODULES["comms"] == true) then
    bCommsNeedsButtons = true
    RedrawCommsWindow()
    WindowShow(winComms, WINDATA[winComms]["SHOW"])
  else
    WINDATA[winXP]["winComms"] = false
  end
  if (MODULES["ascii"] == true) then
    RedrawAsciiWindow()
    WindowShow(winAscii, WINDATA[winAscii]["SHOW"])
  else
    WINDATA[winAscii]["SHOW"] = false
  end
  if (MODULES["hotspots"] == true) then
    RedrawHotspotsWindow()
    WindowShow(winHotspots, WINDATA[winHotspots]["SHOW"])
  else
    WINDATA[winHotspots]["SHOW"] = false
  end
  WindowShow(winMinimap, WINDATA[winMinimap]["SHOW"])
  if (WINDATA[winMinimap]["SHOW"] == false) then
    bMinimapHidden = true
  end
  iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
  RetitleWindow(winMinimap, sMapWinTitle)
  RedrawMap()
end


-- **************************************
-- *****  Custom Cow Layout Saving  *****
-- **************************************
function QuowSaveCustomCows()
  iThemeLayoutLocked = 10
  CUSTOMCOWS = {
    ["MARGINS"] = {
      ["left"] = {SCREENMARGINS["left"][1], SCREENMARGINS["left"][2]},
      ["top"] = {SCREENMARGINS["top"][1], SCREENMARGINS["top"][2]},
      ["right"] = {SCREENMARGINS["right"][1], SCREENMARGINS["right"][2]},
      ["bottom"] = {SCREENMARGINS["bottom"][1], SCREENMARGINS["bottom"][2]},
    },
    [winMinimap] = { ["WIDTH"] = WINDATA[winMinimap]["WIDTH"], ["HEIGHT"] = WINDATA[winMinimap]["HEIGHT"], ["SHOW"] = WINDATA[winMinimap]["SHOW"], ["LOCKED"] = WINDATA[winMinimap]["LOCKED"], ["X"] = WindowInfo(winMinimap, 10), ["Y"] = WindowInfo(winMinimap, 11) },
    [winMDT] = { ["WIDTH"] = WINDATA[winMDT]["WIDTH"], ["HEIGHT"] = WINDATA[winMDT]["HEIGHT"], ["SHOW"] = WINDATA[winMDT]["SHOW"], ["LOCKED"] = WINDATA[winMDT]["LOCKED"], ["X"] = WindowInfo(winMDT, 10), ["Y"] = WindowInfo(winMDT, 11) },
    [winBars] = { ["WIDTH"] = WINDATA[winBars]["WIDTH"], ["HEIGHT"] = WINDATA[winBars]["HEIGHT"], ["SHOW"] = WINDATA[winBars]["SHOW"], ["LOCKED"] = WINDATA[winBars]["LOCKED"], ["X"] = WindowInfo(winBars, 10), ["Y"] = WindowInfo(winBars, 11) },
    [winStats] = { ["WIDTH"] = WINDATA[winStats]["WIDTH"] , ["HEIGHT"] = WINDATA[winStats]["HEIGHT"], ["SHOW"] = WINDATA[winStats]["SHOW"], ["LOCKED"] = WINDATA[winStats]["LOCKED"], ["X"] = WindowInfo(winStats, 10), ["Y"] = WindowInfo(winStats, 11) },
    [winXP] = { ["WIDTH"] = WINDATA[winXP]["WIDTH"], ["HEIGHT"] = WINDATA[winXP]["HEIGHT"], ["SHOW"] = WINDATA[winXP]["SHOW"], ["LOCKED"] = WINDATA[winXP]["LOCKED"], ["X"] = WindowInfo(winXP, 10), ["Y"] = WindowInfo(winXP, 11) },
    [winShields] = { ["WIDTH"] = WINDATA[winShields]["WIDTH"], ["HEIGHT"] = WINDATA[winShields]["HEIGHT"], ["SHOW"] = WINDATA[winShields]["SHOW"], ["LOCKED"] = WINDATA[winShields]["LOCKED"], ["X"] = WindowInfo(winShields, 10), ["Y"] = WindowInfo(winShields, 11) },
    [winComms] = { ["WIDTH"] = WINDATA[winComms]["WIDTH"], ["HEIGHT"] = WINDATA[winComms]["HEIGHT"], ["SHOW"] = WINDATA[winComms]["SHOW"], ["LOCKED"] = WINDATA[winComms]["LOCKED"], ["X"] = WindowInfo(winComms, 10), ["Y"] = WindowInfo(winComms, 11) },
    [winAscii] = { ["WIDTH"] = WINDATA[winAscii]["WIDTH"], ["HEIGHT"] = WINDATA[winAscii]["HEIGHT"], ["SHOW"] = WINDATA[winAscii]["SHOW"], ["LOCKED"] = WINDATA[winAscii]["LOCKED"], ["X"] = WindowInfo(winAscii, 10), ["Y"] = WindowInfo(winAscii, 11) },
    [winHotspots] = { ["WIDTH"] = WINDATA[winHotspots]["WIDTH"], ["HEIGHT"] = WINDATA[winHotspots]["HEIGHT"], ["SHOW"] = WINDATA[winHotspots]["SHOW"], ["LOCKED"] = WINDATA[winHotspots]["LOCKED"], ["X"] = WindowInfo(winHotspots, 10), ["Y"] = WindowInfo(winHotspots, 11) },
    ["OPTIONS"] = { ["VITFORM"] = iVitalsFormat, },
  }
end

-- Import a stringified scaled layout
function QuowLayoutImport()
  local sLayoutImport = utils.inputbox("Please paste a FULL layout data starting with and including LAYOUT:\n\nWARNING: This will overwrite all of your current window positions and sizes!\n", "Import Layout", "", "", 12)
  if (sLayoutImport ~= nil) then
    if (string.sub(sLayoutImport, 1, 7) == "LAYOUT:") then
      sLayoutImport = string.sub(sLayoutImport, 8)
      local objImportedLayout = json.decode(sLayoutImport)
      if (objImportedLayout ~= nil and objImportedLayout["M"] ~= nil and objImportedLayout["W"] ~= nil and objImportedLayout["O"] ~= nil) then
        local iTotalWidth, iTotalHeight = GetInfo(281), GetInfo(280)
        SCREENMARGINS["left"][1] = ((objImportedLayout["M"]["l"]["l"] == true) and true or false)
        SCREENMARGINS["right"][1] = ((objImportedLayout["M"]["r"]["l"] == true) and true or false)
        SCREENMARGINS["top"][1] = ((objImportedLayout["M"]["t"]["l"] == true) and true or false)
        SCREENMARGINS["bottom"][1] = ((objImportedLayout["M"]["b"]["l"] == true) and true or false)
        SCREENMARGINS["left"][2] = RoundQuow(iTotalWidth * tonumber(objImportedLayout["M"]["l"]["s"]))
        SCREENMARGINS["right"][2] = RoundQuow(iTotalWidth * tonumber(objImportedLayout["M"]["r"]["s"]))
        SCREENMARGINS["top"][2] = RoundQuow(iTotalHeight * tonumber(objImportedLayout["M"]["t"]["s"]))
        SCREENMARGINS["bottom"][2] = RoundQuow(iTotalHeight * tonumber(objImportedLayout["M"]["b"]["s"]))
        bLockMargins = true
        -- New vitals format value
        if (objImportedLayout["O"]["V"] ~= nil) then
          iVitalsFormat = tonumber(objImportedLayout["O"]["V"])
        elseif (objImportedLayout["O"]["S"] ~= nil) then
          -- Old vitals stacking option pre 4.06
          if (objImportedLayout["O"]["S"] == true) then
            iVitalsFormat = 0
          else
            iVitalsFormat = 1
          end
        end
        -- Store the Z-positions in advance
        local iWinToZ, bDoZOrdering = {}, false
        for iN = 1, #iWinZOrders do
          iWinToZ[iWinZOrders[iN][2]] = iN
        end
        for sThisWin, sWinData in pairs(objWindows) do
          WINDATA[sThisWin]["WIDTH"] = RoundQuow(iTotalWidth * tonumber(objImportedLayout["W"][sWinData.iNum]["W"]))
          WINDATA[sThisWin]["HEIGHT"] = RoundQuow(iTotalHeight * tonumber(objImportedLayout["W"][sWinData.iNum]["H"]))
          WINDATA[sThisWin]["LOCKED"] = ((objImportedLayout["W"][sWinData.iNum]["L"] == true) and true or false)
          WINDATA[sThisWin]["SHOW"] = ((objImportedLayout["W"][sWinData.iNum]["S"] == true) and true or false)
          -- Do the positioning
          WindowPosition(sThisWin, RoundQuow(iTotalWidth * tonumber(objImportedLayout["W"][sWinData.iNum]["X"])), RoundQuow(iTotalHeight * tonumber(objImportedLayout["W"][sWinData.iNum]["Y"])), 0, 2)
             -- Minimap
          if (sThisWin == winMinimap) then
            ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
          else
            ResizeRedrawWindowGeneric(sThisWin, WINDATA[sThisWin]["WIDTH"], WINDATA[sThisWin]["HEIGHT"], sWinData.sShort)
          end
          -- Optional Z-Layering
          if (objImportedLayout["W"][sWinData.iNum]["Z"] ~= nil) then
            -- Change THIS window's Z-Value, before a major re-sort
            iWinZOrders[iWinToZ[sThisWin]][1] = tonumber(objImportedLayout["W"][sWinData.iNum]["Z"])
            bDoZOrdering = true
          end
        end -- Loop through windows
        -- Now call the heavy layout refresher
        QuowLayoutTheme(69)
        -- And finally if we need it, re-order the windows
        if (bDoZOrdering == true) then
          ReorderWindows()
        end
        -- Set the current-selected layout to "off" (0) 
        iThemeLayoutLocked = 0
        bMinimapHidden = false
        bMinimapTempHidden = false
        if (WINDATA[winMinimap]["SHOW"] == false) then
          bMinimapHidden = true
        end
        ColourNote(sCOLOUR.orange, "", "Your window layouts and screen margins have been imported, scaled to your screen size.")
      else
        Note("That wasn't a valid layout import, it should begin with 'LAYOUT:' and end in two curly brackets '}}'")
      end -- Valid data
    else -- Did the data start with layout?
      Note("That wasn't a valid layout import, it should begin with 'LAYOUT:' and end in two curly brackets '}}'")
    end
  end -- Did we get any input?
end -- Import layout

-- Export a stringified scaled layout
function QuowLayoutExport()
  local iTotalWidth, iTotalHeight = GetInfo(281), GetInfo(280)
  local Lay = {}
  -- M for Margins
  Lay["M"] = {
    ["l"] = {["l"] = SCREENMARGINS["left"][1],   ["s"] = string.format("%.5f", (SCREENMARGINS["left"][2] / iTotalWidth))},
    ["r"] = {["l"] = SCREENMARGINS["right"][1],  ["s"] = string.format("%.5f", (SCREENMARGINS["right"][2] / iTotalWidth))},
    ["t"] = {["l"] = SCREENMARGINS["top"][1],    ["s"] = string.format("%.5f", (SCREENMARGINS["top"][2] / iTotalHeight))},
    ["b"] = {["l"] = SCREENMARGINS["bottom"][1], ["s"] = string.format("%.5f", (SCREENMARGINS["bottom"][2] / iTotalHeight))},
  }
  -- Store the Z-positions in advance
  local iWinToZ = {}
  for iN = 1, #iWinZOrders do
    iWinToZ[iWinZOrders[iN][2]] = iN
  end
  -- W for Windows
  Lay["W"] = {}
  for sThisWin, sWinData in pairs(objWindows) do
    Lay["W"][sWinData.iNum] = {["W"] = string.format("%.5f", (WINDATA[sThisWin]["WIDTH"] / iTotalWidth)), ["H"] = string.format("%.5f", (WINDATA[sThisWin]["HEIGHT"] / iTotalHeight)),
      ["X"] = string.format("%.5f", (WindowInfo(sThisWin, 10) / iTotalWidth)), ["Y"] = string.format("%.5f", (WindowInfo(sThisWin, 11) / iTotalHeight)),
      ["L"] = WINDATA[sThisWin]["LOCKED"], ["S"] = WINDATA[sThisWin]["SHOW"], ["Z"] = iWinToZ[sThisWin],
    }
  end
  iWinToZ = nil
  -- O for Options
  Lay["O"] = {["V"] = tostring(iVitalsFormat)}
  -- What about sending to old-users?
  if (iVitalsFormat == 0) then
    Lay["O"]["S"] = true
  else
    Lay["O"]["S"] = false
  end
  SetClipboard("LAYOUT:" .. json.encode(Lay))
  ColourNote(sCOLOUR.orange, "", "Your current window layout and screen margins, scaled for any screen size, have been copied to your clipboard for you to backup or to 'paste' to others, for example through tells or group chat.")
end

-- Simple rounding
function RoundQuow(x)
  if x%2 ~= 0.5 then
    return math.floor(x+0.5)
  end
  return x-0.5
end


-- **********************************************
-- *****  "minimap" command alias handling  *****
-- **********************************************
sMinimapSearchResults = {}
sMinimapItemResults = {}
sMinimapNPCResults = {}
-- Handle all the possible command arguments the user can send using the "minimap xyz" commands
function QuowMapCommand (sName, sLine, wildcards)
  -- First split off any possible arguments
  local sArgument = string.sub(sLine, 9)
  if (sArgument == "") then
    return
  end
  local sOriginalArgument = sArgument
  sArgument = string.lower(sArgument)
  local iAlternator = 1

  -- Fail out if mushclient connection not currently active/window not highlight (this helps fix freeze-ups)
  if (not ACR) then
    return
  end

  -- Fake movement to shift the minimap around in a grid-pattern
  if (sQuowTrackMoves[sArgument] ~= nil and sQuowTrackMoves[sArgument][1] ~= 6) then
    MinimapHandleMovement(string.lower(wildcards[1]), false)
    Repaint()

  -- Display client-side options and current settings
  elseif (sArgument == "combat brief") then
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar hiding misses/absorbed baseround hits (brief mode).")
    sUSER_OPTIONS["omit_special_prep"] = "n"
    sUSER_OPTIONS["omit_special_fail"] = "n"
    sUSER_OPTIONS["omit_special_out_fail"] = "n"
    sUSER_OPTIONS["omit_special_out_success"] = "n"
    sUSER_OPTIONS["omit_melee_out_fail"] = "y"
    sUSER_OPTIONS["omit_melee_out_success"] = "n"
    sUSER_OPTIONS["omit_melee_out_kill"] = "n"
    sUSER_OPTIONS["omit_special_inc_fail"] = "n"
    sUSER_OPTIONS["omit_special_inc_success"] = "n"
    sUSER_OPTIONS["omit_melee_inc_fail"] = "y"
    sUSER_OPTIONS["omit_melee_inc_success"] = "n"
    sUSER_OPTIONS["omit_melee_inc_kill"] = "n"
    sUSER_OPTIONS["omit_special_third_fail"] = "n"
    sUSER_OPTIONS["omit_special_third_success"] = "n"
    sUSER_OPTIONS["omit_melee_third_fail"] = "y"
    sUSER_OPTIONS["omit_melee_third_success"] = "n"
    sUSER_OPTIONS["omit_melee_third_kill"] = "n"
    assert(dbUserData:execute("UPDATE user_options SET option_value='n' WHERE option_id LIKE 'omit_%'"))
    assert(dbUserData:execute("UPDATE user_options SET option_value='y' WHERE option_id='omit_melee_out_fail' OR option_id='omit_melee_inc_fail' OR option_id='omit_melee_third_fail'"))
    TriggersShowHide()

  -- Display client-side options and current settings
  elseif (sArgument == "combat verbose") then
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar showing ALL combat messages (verbose mode).")
    sUSER_OPTIONS["omit_special_prep"] = "n"
    sUSER_OPTIONS["omit_special_fail"] = "n"
    sUSER_OPTIONS["omit_special_out_fail"] = "n"
    sUSER_OPTIONS["omit_special_out_success"] = "n"
    sUSER_OPTIONS["omit_melee_out_fail"] = "n"
    sUSER_OPTIONS["omit_melee_out_success"] = "n"
    sUSER_OPTIONS["omit_melee_out_kill"] = "n"
    sUSER_OPTIONS["omit_special_inc_fail"] = "n"
    sUSER_OPTIONS["omit_special_inc_success"] = "n"
    sUSER_OPTIONS["omit_melee_inc_fail"] = "n"
    sUSER_OPTIONS["omit_melee_inc_success"] = "n"
    sUSER_OPTIONS["omit_melee_inc_kill"] = "n"
    sUSER_OPTIONS["omit_special_third_fail"] = "n"
    sUSER_OPTIONS["omit_special_third_success"] = "n"
    sUSER_OPTIONS["omit_melee_third_fail"] = "n"
    sUSER_OPTIONS["omit_melee_third_success"] = "n"
    sUSER_OPTIONS["omit_melee_third_kill"] = "n"
    assert(dbUserData:execute("UPDATE user_options SET option_value='n' WHERE option_id LIKE 'omit_%'"))
    TriggersShowHide()

  -- Display client-side options and current settings
  elseif (sArgument == "bookmarks") then
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar Location Bookmarks:")
    local iAnyBookmarks = QuowBookmarkList("", 0)
    if (iAnyBookmarks == 0) then
      Note("You have no bookmarked rooms.  You can create these by left-clicking a room on the map, and then selecting Bookmark in the right-click menu.")
    end
  -- Show roominfo of last-clicked room
  elseif (sArgument == "roomshow") then
    if (sClickedRoomID ~= "") then
      QuowJumpToRoomID(sClickedRoomID)
    end
    return
  -- Show roominfo of last-clicked room
  elseif (sArgument == "roominfo") then
    if (sClickedRoomID ~= "") then
      QuowShowRoomInfo(sClickedRoomID)
    end
    return
  -- Show roominfo of specific search result room
  elseif (string.sub(sArgument, 1, 9) == "roominfo ") then
    sArgument = string.sub(sArgument, 10)
    -- See if this is a valid npc result number
    if (tonumber(sArgument) ~= nil and sMinimapSearchResults[tonumber(sArgument)] ~= nil) then
      QuowShowRoomInfo(sMinimapSearchResults[tonumber(sArgument)])
    end
    return

  -- Show npcinfo of specific search result npc
  elseif (string.sub(sArgument, 1, 8) == "npcinfo ") then
    sArgument = string.sub(sArgument, 9)
    -- See if this is a valid npc result number
    if (tonumber(sArgument) ~= nil and sMinimapNPCResults[tonumber(sArgument)] ~= nil) then
      QuowShowNPCDetails(sMinimapNPCResults[tonumber(sArgument)])
    end
    return

  -- Show iteminfo of specific search result item
  elseif (string.sub(sArgument, 1, 9) == "iteminfo ") then
    sArgument = string.sub(sArgument, 10)
    -- See if this is a valid item result number
    if (tonumber(sArgument) ~= nil and sMinimapItemResults[tonumber(sArgument)] ~= nil) then
      QuowItemDetails(sMinimapItemResults[tonumber(sArgument)])
    end
    return

  -- Bookmark room player is currently stood in
  elseif (sArgument == "bookmark") then
    if (sCurrentRoomID ~= "") then
      QuowCreateBookmark(sCurrentRoomID)
    end
    return

  -- Delete a matching bookmark
  elseif (string.sub(sArgument, 1, 16) == "delete bookmark ") then
    sArgument = string.sub(sOriginalArgument, 17)
    local sDelBookmarkID = ""
    local sDelBookmarkCompare = ""
    local sDelMatchBookmark = string.lower(sArgument)
    -- Loop through all bookmarks, try for an exact match otherwise a partial match
    for sBookmarkedRoomID, sBookmarkNote in pairs(sQuowUserBookmarks) do
      sDelBookmarkCompare = string.lower(sBookmarkNote)
      if (sDelMatchBookmark == sDelBookmarkCompare or (sDelBookmarkID == "" and string.find(sDelBookmarkCompare, sDelMatchBookmark, 1, true) ~= nil)) then
        sDelBookmarkID = sBookmarkedRoomID
      end
    end
    if (sDelBookmarkID ~= "") then
      QuowDeleteBookmark(sDelBookmarkID)
    else
      ColourTell(sCOLOUR.silver, "", "Cannot find a bookmark matching '")
      ColourTell(sCOLOUR.orange, "", sArgument)
      ColourNote(sCOLOUR.silver, "", "' to delete.")
    end

  -- Display help file
  elseif (sArgument == "help") then
    DisplayHelpFile()

  -- Shift the minimap window to the top-left and force-show it
  elseif (sArgument == "reset") then
    -- Different reset options depending on screenreader option
    if (bScreenreader == false) then
      QuowLayoutTheme(2)
      bMinimapHidden = false
      bMinimapTempHidden = false    
      bHideOnTerrain = false
      bShowDiscDate = true
      bAsciiMapOmitted = false
      bAutoShowHideAscii = false
      bDrawSkeletonMode = false
      bPredictiveMoves = false
      bDrawOrbs = true
      bShowGhost = true
    else
      QuowLayoutTheme(14)
      bMinimapHidden = false
      bMinimapTempHidden = false    
      bHideOnTerrain = false
      bShowDiscDate = true
      bAsciiMapOmitted = false
      bAutoShowHideAscii = false
      bDrawSkeletonMode = false
      bPredictiveMoves = false
      bDrawOrbs = true
      bShowGhost = true
    end
    QuowClearQueues()
    QuowOldSnap()
    ColourNote(sCOLOUR.orange, "", "Resetting the CowBar window and basic settings...")

  -- Change the map zoom levels for the graphical map
  elseif (string.sub(sArgument, 1, 5) == "zoom ") then
    sArgument = string.sub(sArgument, 6)
    iUseZoom = tonumber(sArgument)
    if (iUseZoom == nil) then
      iUseZoom = 0
    end
    if (iUseZoom < 1) then
      iUseZoom = 1
    end
    if (iUseZoom > 7) then
      iUseZoom = 7
    end
    WindowResize(winMapRender, MINIMAP_WIDTH*iZoomData[iUseZoom][2], MINIMAP_HEIGHT*iZoomData[iUseZoom][2], iCOLOUR.black)
    if (iUseZoom == 3) then
      sMapWinTitle = sQuowMapfiles[iUseMap][2]
    else
      sMapWinTitle = sQuowMapfiles[iUseMap][2] .. " @ " .. iZoomData[iUseZoom][4]
    end
    iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
    RetitleWindow(winMinimap, sMapWinTitle)
    RedrawMap()
    --ColourNote(sCOLOUR.orange, "", "Minimap zoom level changed: " .. iZoomData[iUseZoom][4] .. " [option " .. iUseZoom .. "]")


  -- Shift the minimap window to the top-left and force-show it
  elseif (string.sub(sArgument, 1, 11) == "brightness ") then
    sArgument = string.sub(sArgument, 12)
    iMinimapBrightness = tonumber(sArgument)
    if (iMinimapBrightness < 20) then
      iMinimapBrightness = 20
    end
    if (iMinimapBrightness > 100) then
      iMinimapBrightness = 100
    end
    RedrawMap()
    ColourNote(sCOLOUR.orange, "", "Minimap window brightness now set to: " .. iMinimapBrightness .. "%")
  -- Command to hide the ascii map from mud output
  elseif (sArgument == "omitmap") then
    if (bAsciiMapOmitted == true) then
      bAsciiMapOmitted = false
      ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will NOT try to omit (or hide) the ascii map from your mud output.")
    else
      bAsciiMapOmitted = true
      ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar WILL now try to omit (or hide) the ascii map from your mud output.")
    end

  -- Screenreader mode
  elseif (sArgument == "screenreader") then
    if (bScreenreader == false) then
      -- Mindspace plugin screenreader mode
      local sAddition = ""
      if (PluginSupports("bff25338e014986ba3b56e2c", "ScreenreaderForceOn") == 0) then
        CallPlugin ("bff25338e014986ba3b56e2c", "ScreenreaderForceOn")
        sAddition = "and mindspace plugin "
      end 
      -- Set screenreader mode true
      bScreenreader = true
      ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar " .. sAddition .. "is now set to screenreader mode, this changes some commands and outputs.")
    else
      -- Mindspace plugin screenreader mode
      local sAddition = ""
      if (PluginSupports("bff25338e014986ba3b56e2c", "ScreenreaderForceOn") == 0) then
        CallPlugin ("bff25338e014986ba3b56e2c", "ScreenreaderForceOff")
        sAddition = "and mindspace plugin "
      end 
      -- Set screenreader mode false
      bScreenreader = false
      ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar " .. sAddition .. "is now set to regular mode.")
    end

  -- Special command to rename last bookmark
  elseif (string.sub(sArgument, 1, 11) == "renamelast " and sLastCreatedBookmarkID ~= "") then
    local sNewBookmarkName = string.sub(sOriginalArgument, 12)
    QuowRenameCommandBookmark(sLastCreatedBookmarkID, sNewBookmarkName)

  -- Command to delete specified bookmark NUMBER
  elseif (string.sub(sArgument, 1, 15) == "bookmarkrename ") then
    local sHandleBookmarkRename = string.sub(sOriginalArgument, 16)
    local iSplitSpace = string.find(sHandleBookmarkRename, " ")
    if (iSplitSpace == nil or iSplitSpace == 0) then
      -- They didn't give a new name at all, JUST a bookmark ID, maybe, so let's let them rename with "renamelast"
      local iTempBookmarkID = tonumber(sHandleBookmarkRename)
      if (iTempBookmarkID ~= nil and iTempBookmarkID > 0 and sQuowUserBookmarks[sSortedBookmarkRoomID[iTempBookmarkID]] ~= nil) then
        sLastCreatedBookmarkID = sSortedBookmarkRoomID[iTempBookmarkID]
      end
      return
    end
    local iDoBookmarkID = string.sub(sHandleBookmarkRename, 1, iSplitSpace - 1)
    local sNewBookmarkName = string.sub(sHandleBookmarkRename, iSplitSpace + 1)
    if (iDoBookmarkID == nil or sNewBookmarkName == nil) then
      return
    end
    iDoBookmarkID = tonumber(iDoBookmarkID)
    if (iDoBookmarkID == nil or iDoBookmarkID < 1) then
      return
    end
    if (sSortedBookmarkRoomID ~= nil and sSortedBookmarkRoomID[iDoBookmarkID] ~= nil and sQuowUserBookmarks[sSortedBookmarkRoomID[iDoBookmarkID]] ~= nil) then
      QuowRenameCommandBookmark(sSortedBookmarkRoomID[iDoBookmarkID], sNewBookmarkName)
    end

  -- Command to delete specified bookmark NUMBER
  elseif (string.sub(sArgument, 1, 15) == "bookmarkdelete ") then
    local iDoBookmarkID = string.sub(sOriginalArgument, 16)
    if (iDoBookmarkID == nil) then
      return
    end
    iDoBookmarkID = tonumber(iDoBookmarkID)
    if (iDoBookmarkID == nil or iDoBookmarkID < 1) then
      return
    end
    if (sSortedBookmarkRoomID ~= nil and sSortedBookmarkRoomID[iDoBookmarkID] ~= nil and sQuowUserBookmarks[sSortedBookmarkRoomID[iDoBookmarkID]] ~= nil) then
      QuowDeleteBookmark(sSortedBookmarkRoomID[iDoBookmarkID])
    end

  -- Chat big/small
  elseif (sArgument == "chat") then
    QuowCommsDoubleclick()

  -- Chat big/small
  elseif (sArgument == "commands") then
    DisplayCommands()

  -- Reset a hotspot timer
  elseif (string.sub(sArgument, 1, 8) == "hotspot ") then
    sArgument = string.sub(sArgument, 9)
    local sHotspotUniqueNames = {}
    for iHotspotID, objHotspot in pairs(sHotspotData) do
      sHotspotUniqueNames[string.lower(objHotspot["hotspot_name"])] = iHotspotID
    end
    if (sHotspotUniqueNames[string.lower(sArgument)] ~= nil) then
      local iResetHotspot = sHotspotUniqueNames[string.lower(sArgument)]
      if (sHotspotData[iResetHotspot] ~= nil) then
        local iNowTime = os.time()
        sHotspotData[iResetHotspot]["time_seen"] = iNowTime
        if (sHotspotData[iResetHotspot]["timeafter_notify"] > 0) then
          sHotspotData[iResetHotspot]["notified"] = 0
        else
          sHotspotData[iResetHotspot]["notified"] = 1
        end
        ReSortHotspots()
        RedrawHotspotsWindow()
        ColourTell(sCOLOUR.silver, "", "Cow Bar timer for hotspot '")
        ColourTell(RGBColourToName(sHotspotData[iResetHotspot]["colour"]), "", sHotspotData[iResetHotspot]["hotspot_name"])
        ColourNote(sCOLOUR.silver, "", "' has been reset to 0.")
      end
    end
  -- Output all hotspots to main mud output
  elseif (sArgument == "hotspots") then
    HotspotOutputList()
  -- Group sync timers
  elseif (sArgument == "group hotspots") then
    HotspotGroupSyncSend()
  -- Group report XP rate
  elseif (sArgument == "group xp") then
    QuowGroupReportXP()
  -- Group report kill stats
  elseif (sArgument == "group kills") then
    QuowGroupReportKills()
  -- Reset group status and members etc.
  elseif (sArgument == "group reset") then
    QuowGroupResetRefresh()
  -- Reset XP rates and graph
  elseif (sArgument == "xp reset") then
    QuowResetXPRates()

  -- Change current gp-regeneration-rate
  elseif (string.sub(sArgument, 1, 8) == "gpregen ") then
    sArgument = string.sub(sArgument, 9)
    local iGPRegen = tonumber(sArgument)
    if (iGPRegen == nil) then
      iGPRegen = 0
    end
    if (iGPRegen < 0) then
      iGPRegen = 0
    elseif (iGPRegen > 5) then
      iGPRegen = 5
    end
    if (iGPRegen == 0 or iGPRegen == 1 or iGPRegen == 2 or iGPRegen == 3 or iGPRegen == 4 or iGPRegen == 5) then
      if (iGPRegen ~= iQuowCombatStats[iCurrentCombatStatSet]["gp_regen"]) then
        iQuowCombatStats[iCurrentCombatStatSet]["gp_regen"] = iGPRegen
        ColourNote(sCOLOUR.orange, "", "The GP Regeneration rate of this set is now " .. iGPRegen .. " GP per heartbeat tick")
      end
    end

  -- Clear current statset, no confirmation
  elseif (sArgument == "clearstatset") then
    if (iQuowCombatStats[iCurrentCombatStatSet] ~= nil) then
      for sColumn, sData in pairs(iQuowCombatStats[iCurrentCombatStatSet]) do
        if (sColumn ~= "set_name" and sColumn ~= "gp_regen") then
          iQuowCombatStats[iCurrentCombatStatSet][sColumn] = 0
        end
      end
      RedrawStatsWindow()
      ColourNote(sCOLOUR.orange, "", "All of your combat sets for the currently selected set '" .. iQuowCombatStats[iCurrentCombatStatSet]["set_name"] .. "' have been reset to 0.")
    end

  -- Statset create
  elseif (string.sub(sArgument, 1, 11) == "statcreate ") then
    sArgument = string.sub(sOriginalArgument, 12)
    CombatSetSwitchToName(sArgument)

  -- Switch statset
  elseif (string.sub(sArgument, 1, 8) == "statset ") then
    sArgument = string.sub(sOriginalArgument, 9)
    -- Switch to name, else to ID
    if (iQuowSetNameID[sArgument] ~= nil) then
      QuowSwitchStatSet(iQuowSetNameID[sArgument], false)
    else
      local iChangeStatSet = tonumber(sArgument)
      if (iChangeStatSet ~= nil) then
        if (iChangeStatSet < 1) then
          iChangeStatSet = 1
        elseif (iChangeStatSet > 100) then
          iChangeStatSet = 100
        end
        if (iQuowCombatStats[iChangeStatSet] ~= nil) then
          QuowSwitchStatSet(iChangeStatSet, false)
        end
      end
    end

  -- Skeleton map mode
  elseif (sArgument == "skeleton") then
    local sModeResult = ""
    if (bDrawSkeletonMode == true) then
      bDrawSkeletonMode = false
      sModeResult = "OFF [graphical map]"
    else
      bDrawSkeletonMode = true
      sModeResult = "ON [no graphical map]"
    end
    RedrawMap()
    ColourNote(sCOLOUR.orange, "", "Switching skeleton map mode to: " .. sModeResult)
  -- Report current position in the UU Library
  elseif (sArgument == "position") then
    local sShowDir = sMovementPositionShow[sLastDir]
    if (sShowDir == nil) then
      sShowDir = sLastDir
    end
    if (sThisRoomTitle == "Library" or sThisRoomTitle == "UULibraryExit" or sThisRoomTitle == "UULibraryGap") then
      local iLibraryThaums = math.floor((((4850 - iMyY) - 10)/ 30) * 5)
      local iLibraryColumn = math.floor((iMyX - 15) / 30)
      local iLibraryRow = math.floor(iLibraryThaums / 5)
      ColourNote(sCOLOUR.orange, "", "Cow Bar thinks you are in the University Library, facing " .. sShowDir .. ".  Your depth is " .. 
                 iLibraryThaums .. " thaums.  You are " .. iLibraryRow .. " rows back, at column " .. iLibraryColumn .. ".")
    elseif (sCurrentRoomID == "SandelfonMaze") then
      ColourNote(sCOLOUR.orange, "", "Cow Bar thinks you are wandering in the Endless Halls Maze.")
    elseif (sCurrentRoomID == "AbandonedMine") then
      ColourNote(sCOLOUR.orange, "", "Cow Bar thinks you are delving in the Copperhead mines.")
    elseif (sQuowLocationsByRoomID[sCurrentRoomID] ~= nil) then
      ColourNote(sCOLOUR.orange, "", "Cow Bar thinks you are in map region " .. sQuowMapfiles[sQuowLocationsByRoomID[sCurrentRoomID][1]][2] .. 
                 ", room titled " .. sQuowLocationsByRoomID[sCurrentRoomID][4] .. ", facing " .. sShowDir .. ".")
    elseif (sQuowMapfiles[iCurMap] ~= nil) then
      if (iCurMap < 99) then
        if (sThisRealRoomTitle ~= "") then
          ColourNote(sCOLOUR.orange, "", "Cow Bar thinks you are in map region " .. sQuowMapfiles[iCurMap][2] .. ", in '" .. 
                     sThisRealRoomTitle .. "', facing " .. sShowDir .. ".")
        else
          ColourNote(sCOLOUR.orange, "", "Cow Bar thinks you are in map region " .. sQuowMapfiles[iCurMap][2] .. ", facing " .. 
                     sShowDir .. ".")
        end
      else
        ColourNote(sCOLOUR.orange, "", "Cow Bar thinks you are somewhere in the terrains, possibly at X " .. iMyX .. " and Y " .. 
                   iMyY .. ", facing " .. sShowDir .. ".")
      end
    else
      ColourNote(sCOLOUR.orange, "", "Cow Bar is not sure of your current location.")
    end

  -- Force a fake direction-face, useful for the UU library to let it know which way you are ACTUALLY facing if you get lost
  elseif (string.sub(sArgument, 1, 7) == "setdir ") then
    sArgument = string.sub(sArgument, 8)
    -- Trim spaces
    sArgument = sArgument:match'^%s*(.*%S)' or ''
    if (sMovementShort[sArgument] ~= nil) then
      sLastDir = sMovementShort[sArgument]
    end
    RedrawMap()
    ColourNote(sCOLOUR.orange, "", "Attempting to re-align your last known direction to: '" .. sArgument .. "'")

  -- Clear the minimap AND any queued movements
  elseif (sArgument == "clear") then
    ColourNote(sCOLOUR.orange, "", "Clearing minimap and any stored movement command queues and resetting the visible map.")
    QuowClearQueues()
    sCurrentMap = ""
    sLoadedMap = ""
    ClearMinimapWindow()

  -- Clear any waiting queued movements
  elseif (sArgument == "queue") then
    ColourNote(sCOLOUR.orange, "", "Clearing any stored/waiting movement queues expected by the minimap.")
    QuowClearQueues()
    RedrawMap()

  elseif (sArgument == "discworldconfig") then
    Send("alias QuowBarOptions options mxp enabled=on;options mxp objectmenus=off;options mxp livingmenus=off;options output map frame=off;options output map glance=top;options output map glancecity=top;options output map look=top;options output map lookcity=top;options output map plain=off;options output map reversecolour=off;options output map written=off;options output map mxp=off;options combat monitor state=on;options output combat=verbose;options output prompt=off;options output shortinlong=on;options output usercolour=on;options combat monitor state=on;options output skills=branched;cols 80;term ansi;term network;frimble === Disc Config Done! ===")
    Send("QuowBarOptions")
    ColourNote(sCOLOUR.red, "", "NOTE:  Quow's Cow Bar is now re-configuring some of your Discworld options to match those Quow uses himself.  This includes no command prompt (the '> '), verbose combat, and other settings.")
    ColourNote(sCOLOUR.orange, "", "Browse 'options' and the sub-options such as 'options output', 'options mxp', 'options output map' etc. and tweak to suit yourself!")

  elseif (sArgument == "mushconfig") then
    SetOption ("alt_arrow_recalls_partial", 0)
    SetOption ("always_record_command_history", 0)
    SetOption ("arrows_change_history", 1)
    SetOption ("arrow_keys_wrap", 0)
    SetOption ("arrow_recalls_partial", 0)
    SetOption ("auto_pause", 1)
    SetOption ("auto_resize_command_window", 0)
    SetOption ("auto_resize_minimum_lines", 1)
    SetOption ("auto_resize_maximum_lines", 20)
    SetOption ("auto_wrap_window_width", 1)
    SetOption ("detect_pueblo", 1)
    SetOption ("do_not_add_macros_to_command_history", 0)
    SetOption ("do_not_show_outstanding_lines", 0)
    SetOption ("do_not_translate_iac_to_iac_iac", 0)
    SetOption ("disable_compression", 0)
    SetOption ("enable_aliases", 1)
    SetOption ("enable_auto_say", 0)
    SetOption ("enable_scripts", 1)
    SetOption ("enable_spam_prevention", 0)
    SetOption ("enable_speed_walk", 0)
    SetOption ("enable_timers", 1)
    SetOption ("enable_triggers", 1)
    SetOption ("enable_trigger_sounds", 1)
    SetOption ("ignore_mxp_colour_changes", 0)
    SetOption ("mud_can_change_link_colour", 1)
    SetOption ("mud_can_remove_underline", 0)
    SetOption ("mud_can_change_options", 1)
    SetOption ("mxp_debug_level", 0)
    SetOption ("play_sounds_in_background", 1)
    SetOption ("re_evaluate_auto_say", 0)
    SetOption ("save_deleted_command", 1)
    SetOption ("save_world_automatically", 1)
    SetOption ("send_echo", 0)
    SetOption ("send_keep_alives", 0)
    SetOption ("send_mxp_afk_response", 1)
    SetOption ("show_connect_disconnect", 1)
    SetOption ("spam_line_count", 20)
    SetOption ("speed_walk_delay", 0)
    SetOption ("spell_check_on_send", 0)
    SetOption ("start_paused", 0)
    SetOption ("translate_backslash_sequences", 0)
    SetOption ("treeview_triggers", 1)
    SetOption ("treeview_aliases", 1)
    SetOption ("treeview_timers", 1)
    SetOption ("underline_hyperlinks", 1)
    SetOption ("unpause_on_send", 1)
    SetOption ("use_mxp", 0)
    SetOption ("utf_8", 0)
    SetOption ("wrap", 0)
    SetOption ("wrap_input", 0)
    SetOption ("wrap_column", 168)
    ColourNote(sCOLOUR.red, "", "NOTE:  Quow's Cow Bar has re-configured some of your world options to match those Quow uses himself.")

  -- Insta-route to an NPC or numbered result
  elseif (string.sub(sArgument, 1, 9) == "routenpc ") then
    sArgument = string.sub(sArgument, 10)
    local sMatchBookmark = string.lower(sArgument)
    local sUseBookmarkID = ""
    local sBookmarkCompare = ""
    -- First of all see if this is a number
    if (tonumber(sMatchBookmark) ~= nil and sMinimapNPCResults[tonumber(sMatchBookmark)] ~= nil) then
      local sThisNPCID = sMinimapNPCResults[tonumber(sMatchBookmark)]
      if (sNPCs[sThisNPCID] ~= nil) then
        if (sQuowLocationsByRoomID[sNPCs[sThisNPCID]["roomid"]] ~= nil) then
          QuowRouteToRoomID(sNPCs[sThisNPCID]["roomid"], true, true)
        else
          Note("Unable to route to the given NPC search result number '" .. sMatchBookmark .. "'")
        end
      else
        Note("Unable to route to the given NPC search result number '" .. sMatchBookmark .. "'")
      end
    else
      Note("You can only use the routenpc command to match a given numbered result from an NPC search.")
    end

  -- Insta-route to a named bookmark or numbered result
  elseif (string.sub(sArgument, 1, 6) == "route ") then
    sArgument = string.sub(sArgument, 7)
    local sMatchBookmark = string.lower(sArgument)
    local sUseBookmarkID = ""
    local sBookmarkCompare = ""
    -- First of all see if this is a number
    if (tonumber(sMatchBookmark) ~= nil and sMinimapSearchResults[tonumber(sMatchBookmark)] ~= nil) then
      QuowRouteToRoomID(sMinimapSearchResults[tonumber(sMatchBookmark)], true, true)
    else

      -- Loop through all bookmarks, try for an exact match otherwise a partial match
      for sBookmarkedRoomID, sBookmarkNote in pairs(sQuowUserBookmarks) do
        sBookmarkCompare = string.lower(sBookmarkNote)
        if (sMatchBookmark == sBookmarkCompare or (sUseBookmarkID == "" and string.find(sBookmarkCompare, sMatchBookmark, 1, true) ~= nil)) then
          sUseBookmarkID = sBookmarkedRoomID
        end
      end
      if (sUseBookmarkID ~= "") then
        if (sQuowLocationsByRoomID[sUseBookmarkID] ~= nil) then
          QuowRouteToRoomID(sUseBookmarkID, true, true)
        else
          ColourNote(sCOLOUR.silver, "", "Unable to find a route to the selected bookmark.  There may be an error with your bookmarks or a path may be impossible.")
        end
      else 
        ColourNote(sCOLOUR.silver, "", "Unable to find a bookmark with the name '" .. sArgument .. "' to speedwalk to.")
      end
    end

  elseif (sArgument == "route") then
    iMyX = iOldMX
    iMyY = iOldMY
    iCurMap = iOldMap
    sCurrentMap = sOldMap
    RedrawMap()
    Repaint()
    if (sClickedRoomID ~= "") then
      if (sQuowLocationsByRoomID[sClickedRoomID] ~= nil) then
        QuowRouteToRoomID(sClickedRoomID, true, false)
      else
        Note("Unable to find a route - ensure you click on a recognised room on the map first, or have clicked the 'show' link on a location result.")
      end
    else
      Note("Unable to find a route - ensure you click on a recognised room on the map first, or have clicked the 'show' link on a location result.")
    end

  -- Special Quow admin edit mode for creating database entries of rooms
  elseif (sArgument == "hotzonerecord") then
    bRecordingHotzones = true
    QuowHotspotStart()
  -- Special Quow admin edit mode for NOT creating new rooms in editmode
  elseif (sArgument == "norooms") then
    if (bCreatingActualNewRooms == true) then
      bCreatingActualNewRooms = false
      ColourNote(sCOLOUR.orange, "", "Will *NOT* create brand new rooms in the database")
    else
      bCreatingActualNewRooms = true
      ColourNote(sCOLOUR.orange, "", "*WILL* create brand new rooms in the database")
    end
  -- Special Quow admin edit mode for creating database entries of rooms
  elseif (sArgument == "editmode") then
    if (bCreatingRooms == true) then
      bCreatingRooms = false
      ColourNote(sCOLOUR.orange, "", "Disabling admin-only editor mode")
      EnableAlias("QuowShortMM", false)
      EnableAlias("QuowShopList", false)
      EnableAlias("QuowAppraiseItems", false)
      EnableAlias("QuowNPCCommand", false)
      EnableAlias("QuowItemCommand", false)
      EnableAlias("QuowBrowseCommand", false)
      EnableTrigger("QuowItemWeight", false)
      EnableTrigger("QuowAccurateWeight", false)
      EnableAlias("QuowWeighBalance", false)
      EnableTrigger("ShopStandardInventory", false)
      EnableTrigger("ShopRestaurantInventory", false)
      EnableTrigger("ShopPrepareBrowse", false)
      EnableTrigger("ShopCaptureBrowse", false)
      EnableTriggerGroup ("module_npcloot", false)
      EnableTrigger("NPCShopStockPrice", false)
      EnableTrigger("NPCShopStockPrice2", false)
      EnableTrigger("NPCShopStockPrimeDescription", false)
      EnableTrigger("NPCShopStockDescription", false)
      EnableTrigger("ShopManualBrowsePrime", false)
      EnableTrigger("ShopManualBrowseGather", false)
      EnableTrigger("NPCShopItemPrimeList", false)
      EnableTrigger("NPCShopItemGather", false)
      EnableTrigger("NPCShopItemFinal", false)
      --EnableTrigger("QuowScavengeItem", false)
    else
      bCreatingRooms = true
      --sCurrentRoomID = ""
      sOldRoomID = ""
      bLastRoomFailGMCP = true
      SendNoEcho("l")
      ColourNote(sCOLOUR.orange, "", "ENABLING admin-only room and shop-inventory edit mode.")
      ColourNote(sCOLOUR.red, "", "WARNINGS: Do NOT queue movements, go slowly, and be aware you may corrupt your room database!")
      EnableAlias("QuowShortMM", true)
      EnableAlias("QuowShopList", true)
      EnableAlias("QuowAppraiseItems", true)
      EnableAlias("QuowNPCCommand", true)
      EnableAlias("QuowItemCommand", true)
      EnableAlias("QuowBrowseCommand", true)
      EnableAlias("QuowWeighBalance", true)
      EnableTrigger("QuowItemWeight", true)
      --EnableTrigger("QuowScavengeItem", true)
    end
  -- Additional to above, used for recording how two rooms connect to eachother
  elseif (sArgument == "routemode") then
    if (bIgnoreExits == true and bCreatingRooms == true) then
      bIgnoreExits = false
      ColourNote(sCOLOUR.orange, "", "ENABLING admin-only, room-link and route-pathing creation mode.")
      ColourNote(sCOLOUR.red, "", "WARNINGS: Do NOT queue movements, wait for the MUD each move, and ensure you do not use aliases to move!")
    else
      bIgnoreExits = true
      ColourNote(sCOLOUR.orange, "", "Disabling admin-only route editor mode")
    end

  -- Hide the minimap window
  elseif (sArgument == "hide") then
    ColourNote(sCOLOUR.orange, "", "Hiding the minimap window.  Use '", sCOLOUR.cyan, "", "minimap show", sCOLOUR.orange, "", "' to display again.")
    ColourNote(sCOLOUR.silver, "", "Note:  MANY options and features of Cow Bar are controlled through the minimap window menu!")
    WindowShow(winMinimap, false)
    WINDATA[winMinimap]["SHOW"] = false
    iThemeLayoutLocked = 0
    bMinimapHidden = true
    bMinimapTempHidden = false

  -- Show the minimap window
  elseif (sArgument == "show") then
    ColourNote(sCOLOUR.orange, "", "Showing the minimap window.  Use '", sCOLOUR.cyan, "", "minimap hide", sCOLOUR.orange, "", "' to hide again.")
    WindowShow(winMinimap, true)
    WINDATA[winMinimap]["SHOW"] = true
    iThemeLayoutLocked = 0
    bMinimapHidden = false
    bMinimapTempHidden = false
    RedrawMap()

  -- Jump to an exact co-ordinate in curly bracers
  elseif (string.sub(sArgument, 1, 1) == "{" and string.sub(sArgument, -1) == "}") then
    -- Let a user send co-ordinates to the minimap command in curly brackets
    sClickedRoomID = ""
    MapJumptoCoordinates(string.sub(sArgument, 2, string.find(sArgument, "}") - 1))
    -- get a room ID if one matches this exact co-ordinate
    sSQL = "SELECT room_id, map_id, xpos, ypos, room_short, room_type FROM rooms WHERE map_id=" .. iCurMap .. " AND xpos=" .. iMyX .. " AND ypos=" .. iMyY
    for row in dbMap:nrows(sSQL) do
      sClickedRoomID = row.room_id
      break
    end
    if (sClickedRoomID ~= "" and string.sub(sArgument, -6) == " route" and sQuowLocationsByRoomID[sClickedRoomID] ~= nil) then
      QuowRouteToRoomID(sClickedRoomID, true, false)
    end

  elseif (sArgument == "debug") then
    -- Paste this output to Quow to help with some types of error, version numbers, GMCP buffer-counts etc.
    Note("{MM DEBUG|" .. tostring(TACR) .. "|" .. tostring(TCBL) .. "|" .. tostring(GetInfo(72)) .. "|" .. tostring(GetPluginInfo("bfe35205f026786ea1d56e3b", 19)) .. "}")

  -- Old desc handler now defunct, may make a re-appearance in the future
  elseif (string.sub(sArgument, 1, 9) == "roomdesc " and bHandlerDesc ~= nil and bHandlerDesc == true) then
    sArgument = string.sub(sOriginalArgument, 10)
    DescHandling("", sArgument)

  -- Delete an entire room ID
  elseif (string.sub(sArgument, 1, 12) == "delete room " and bDebugMode == true and bCreatingRooms == true) then
    sArgument = string.sub(sOriginalArgument, 13)
    sSQL = "DELETE FROM room_exits WHERE room_id='" .. EscapeSQL(sArgument) .. "'"
    assert(dbMap:execute(sSQL))
    sSQL = "DELETE FROM room_exits WHERE connect_id='" .. EscapeSQL(sArgument) .. "'"
    assert(dbMap:execute(sSQL))
    sSQL = "DELETE FROM rooms WHERE room_id='" .. EscapeSQL(sArgument) .. "'"
    assert(dbMap:execute(sSQL))
    sQuowExitsByID[sArgument] = {}
    sQuowExitsByExit[sArgument] = {}
    for sRoomExitKey, sRoomExitData in pairs(sQuowExitsByID) do
      for sExitRoomKey, sExitDir in pairs(sRoomExitData) do
        if (sExitRoomKey == sArgument) then
          sQuowExitsByExit[sRoomExitKey][sExitDir] = nil
          sQuowExitsByID[sRoomExitKey][sExitRoomKey] = nil
        end
      end
    end
    sQuowLocationsByRoomID[sArgument] = nil
    Note("Room " ..  sArgument .. " removed, including all exits to and from the room.")

  -- Delete room connections to/from this room ID
  elseif (string.sub(sArgument, 1, 13) == "delete exits " and bDebugMode == true and bCreatingRooms == true) then
    sArgument = string.sub(sOriginalArgument, 14)
    sSQL = "DELETE FROM room_exits WHERE room_id='" .. EscapeSQL(sArgument) .. "'"
    assert(dbMap:execute(sSQL))
    sSQL = "DELETE FROM room_exits WHERE connect_id='" .. EscapeSQL(sArgument) .. "'"
    assert(dbMap:execute(sSQL))
    for sRoomExitKey, sRoomExitData in pairs(sQuowExitsByID) do
      for sExitRoomKey, sExitDir in pairs(sRoomExitData) do
        if (sExitRoomKey == sArgument) then
          sQuowExitsByExit[sRoomExitKey][sExitDir] = nil
          sQuowExitsByID[sRoomExitKey][sExitRoomKey] = nil
        end
      end
    end
    sQuowExitsByID[sArgument] = {}
    sQuowExitsByExit[sArgument] = {}
    Note("The exits to and from room ID " ..  sArgument .. " have been removed.")

  -- Search shop-stock inventory lines
  elseif (string.sub(sArgument, 1, 12) == "delete hash " and bDebugMode == true and bCreatingRooms == true and bHandlerDesc ~= nil and bHandlerDesc == true) then
    -- Try find a shop-based item
    sArgument = string.sub(sArgument, 13)
    DeleteDescriptionHash(string.upper(sArgument))

  elseif (string.sub(sArgument, 1, 4) == "mdt ") then
    -- Map-Door-Text replacement/Imported commands
    sArgument = string.sub(sArgument, 5)
    if (sArgument == "enable") then
      -- Enable parsing
      bMDTParsingEnabled = true
      ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar WILL re-parse and highlight/score the written-maps and 'map door text' outputs for you [recommended].")
    elseif (sArgument == "disable") then
      -- Disable parsing
      bMDTParsingEnabled = false
      ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will NOT give any advanced parsing or output for the written-maps or 'map door text' commands [not recommended].")
    elseif (string.sub(sArgument, 1, 6) == "limit ") then
      -- Score limit
      local iNewScoreLimit = tonumber(string.sub(sArgument, 7))
      if (iNewScoreLimit == nil) then
        iNewScoreLimit = 0
      end
      if (iNewScoreLimit == nil) then
        iNewScoreLimit = 1
      end
      if (iNewScoreLimit < -500) then
        iNewScoreLimit = -500
      end
      if (iNewScoreLimit > 500) then
        iNewScoreLimit = 500
      end
      iMDTMinimumScore = iNewScoreLimit
      ReSortMDTRooms()
      ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will now hide written-map MDT rooms that have a total-room-score below " .. tostring(iMDTMinimumScore) .. ".")   
    else
      -- Category - try to find a category match
      local sCatMatch = ""
      for sCatKey, sCatData in pairs(sMDTCategories) do
        if (string.lower(sCatKey) == sArgument) then
          sCatMatch = sCatKey
          if (sCatData[1] == true) then
            sMDTCategories[sCatKey][1] = false
            Note("MDT matches in the category '" .. sCatMatch .. "' are now DISABLED")
          else
            sMDTCategories[sCatKey][1] = true
            Note("MDT matches in the category '" .. sCatMatch .. "' are now ENABLED")
          end
        end
      end
      if (sCatMatch == "") then
        Note("No MDT category with the name '" .. sArgument .. "' was found.")
      end
    end


  -- Limit of results
  elseif (string.sub(sArgument, 1, 6) == "limit ") then
    sArgument = string.sub(sArgument, 7)
    local iNewResultLimit = tonumber(sArgument)
    if (iNewResultLimit == nil) then iNewResultLimit = 100 end
    if (iNewResultLimit < 10) then iNewResultLimit = 10 end
    if (iNewResultLimit > 2000) then iNewResultLimit = 2000 end
    iSearchResultLimit = iNewResultLimit
    ColourNote(sCOLOUR.orange, "", "Search results from the minimap will now be limited to ", sCOLOUR.cyan, "", iSearchResultLimit, sCOLOUR.orange, "", " results.  This affects location, item, npc, appraise and description search results, and can be set between 10-2000. [default 100]")
  -- Show item values by default
  elseif (sArgument == "values") then
    if (bShowItemValues == true) then
      bShowItemValues = false    
      ColourNote(sCOLOUR.orange, "", "NPC details will no longer show item values for known items in their listings.")
    else
      bShowItemValues = true
      ColourNote(sCOLOUR.orange, "", "NPC details will now show item values for known items in their listings.")
    end

  -- Search core item database by item appraise
  elseif (string.sub(sArgument, 1, 9) == "appraise ") then
    -- Try find a shop-based item
    sArgument = string.sub(sArgument, 10)
    -- See if we are limiting by area
    local iBracerLeft = string.find(sArgument, "{")
    local iBracerRight = string.find(sArgument, "}")
    local iSearchMapMatch = 0
    if (iBracerLeft and iBracerRight and iBracerLeft < iBracerRight) then
      local sLimitArea = string.sub(sArgument, iBracerLeft + 1, iBracerRight - 1)
      -- Space between right bracer and text?
      if (string.sub(sArgument, iBracerRight + 1, iBracerRight + 1) ~= " ") then
        iBracerRight = iBracerRight - 1
      end
      -- Break out the bracer data
      sArgument = string.sub(sArgument, 1, iBracerLeft - 1) .. string.sub(sArgument, iBracerRight + 2)
      if (sQuowPlaceLookups[sLimitArea] ~= nil) then
        iSearchMapMatch = sQuowPlaceLookups[sLimitArea][1]
      end
      Note("You cannot search the full item database with a location-limit, omitting your area-search...")
    end
    -- Trim spaces
    sArgument = sArgument:match'^%s*(.*%S)' or ''

    local iAnyFinds = 0
    local bSuperShort = false
    ColourNote(sCOLOUR.orange, "", "Searching CowBar item appraisals for '" .. sArgument .. "'...")
    if (string.len(sArgument) < 3) then
      Note("(your search string is too short to search item appraisals for, try a longer search!)")
    else
      local sItemData
      local sItemDataResults = {}
      for sKey, sItemData in pairs(sItemDBItems) do
        if (string.find(string.lower(sItemData["appraise_text"]), sArgument, 1, true) ~= nil) then
          table.insert(sItemDataResults, {sKey, string.lower(sKey)})
        end
      end
      -- Attempt to sort the table
      table.sort(sItemDataResults, QuowSearchCompare)

      for _, sKey in pairs(sItemDataResults) do
        sItemData = sItemDBItems[sKey[1]]
        iAnyFinds = iAnyFinds + 1
        if (iAnyFinds > iSearchResultLimit) then
          Note("  [cutting list at " .. iSearchResultLimit .. " matches, " .. #sItemDataResults .. " total appraisals found]")
          iAnyFinds = iAnyFinds - 1
          break
        end
        if (iAnyFinds == 1) then
          sMinimapItemResults = {}
        end
        iAlternator = 1 - iAlternator
        if (iAlternator == 0) then
          sAlternatingColour = ""
        else
          sAlternatingColour = sCOLOUR.offblack
        end

        ColourTell(sCOLOUR.grey, sAlternatingColour, string.format("%2d", iAnyFinds))
        sMinimapItemResults[iAnyFinds] = sKey[1]
        ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowItemDetails(" .. sKey[1] .. ")", "Details", "Show detailed info such as where item might be found, appraise info etc. for this item.", sCOLOUR.orange, sAlternatingColour, 0)
        -- Links for editing the items in editing debug mode
        if (bDebugMode == true and bCreatingRooms == true) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowAddShopStockItem(" .. sKey[1] .. ")", "AddShop", "Add this item to current shop", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          if (sLastNPCCodeViewed ~= nil and sLastNPCCodeViewed ~= "" and sNPCs[sLastNPCCodeViewed] ~= nil and (sItemDBNPCItems[sLastNPCCodeViewed] == nil or sItemDBNPCItems[sLastNPCCodeViewed][sKey[1]] == nil)) then
            Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowAddNPCStockItem(" .. sKey[1] .. ")", "NPCSell", "Add this item to NPC " .. sLastNPCCodeViewed, sCOLOUR.orange, sAlternatingColour, 0)
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          end
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteItem(" .. sKey[1] .. ")", "Delete", "Delete this item from the database", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sKey[1] .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sKey[1] .. ")", "Edit", "Edit this item data in the database", sCOLOUR.orange, sAlternatingColour, 0)
        end
        ColourTell(sCOLOUR.grey, sAlternatingColour, "] ")
        ColourTell(sCOLOUR.cyan, sAlternatingColour, sKey[1])
        Note("")
      end
      sItemDataResults = nil
    end
    if (iAnyFinds == 0) then
      Tell("Unable to find any known ")
      ColourTell(sCOLOUR.orange, "", "items")
      Note(" containing '" .. sArgument .. "' in the appraise information.")
      Note("")
    elseif (iAnyFinds == 1) then
      --Note("Automatically showing single result item details...")
      --QuowItemDetails(sMinimapItemResults[1])
    end
    -- End of appraisal searching

  -- Search core item database by item description
  elseif (string.sub(sArgument, 1, 12) == "description ") then
    -- Try find a shop-based item
    sArgument = string.sub(sArgument, 13)

    -- See if we are limiting by area
    local iBracerLeft = string.find(sArgument, "{")
    local iBracerRight = string.find(sArgument, "}")
    local iSearchMapMatch = 0
    if (iBracerLeft and iBracerRight and iBracerLeft < iBracerRight) then
      local sLimitArea = string.sub(sArgument, iBracerLeft + 1, iBracerRight - 1)
      -- Space between right bracer and text?
      if (string.sub(sArgument, iBracerRight + 1, iBracerRight + 1) ~= " ") then
        iBracerRight = iBracerRight - 1
      end
      -- Break out the bracer data
      sArgument = string.sub(sArgument, 1, iBracerLeft - 1) .. string.sub(sArgument, iBracerRight + 2)
      if (sQuowPlaceLookups[sLimitArea] ~= nil) then
        iSearchMapMatch = sQuowPlaceLookups[sLimitArea][1]
      end
      Note("You cannot search the full item database with a location-limit, omitting your area-search...")
    end
    -- Trim spaces
    sArgument = sArgument:match'^%s*(.*%S)' or ''

    local iAnyFinds = 0
    local bSuperShort = false
    ColourNote(sCOLOUR.orange, "", "Searching CowBar item descriptions for '" .. sArgument .. "'...")
    if (string.len(sArgument) < 3) then
      Note("(your search string is too short to search item descriptions for, try a longer search!)")
    else
      local sItemData
      local sItemDataResults = {}
      -- First build a list of results
      for sKey, sItemData in pairs(sItemDBItems) do
        if (string.find(string.lower(sItemData["description"]), sArgument, 1, true) ~= nil) then
          table.insert(sItemDataResults, {sKey, string.lower(sKey)})
        end
      end
      -- Attempt to sort the table
      table.sort(sItemDataResults, QuowSearchCompare)

      for _, sKey in pairs(sItemDataResults) do
        sItemData = sItemDBItems[sKey[1]]
        iAnyFinds = iAnyFinds + 1
        if (iAnyFinds > iSearchResultLimit) then
          Note("  [cutting list at " .. iSearchResultLimit .. ", " .. #sItemDataResults .. " matching descriptions found]")
          iAnyFinds = iAnyFinds - 1
          break
        end
        if (iAnyFinds == 1) then
          sMinimapItemResults = {}
        end
        iAlternator = 1 - iAlternator
        if (iAlternator == 0) then
          sAlternatingColour = ""
        else
          sAlternatingColour = sCOLOUR.offblack
        end

        ColourTell(sCOLOUR.grey, sAlternatingColour, string.format("%2d", iAnyFinds))
        sMinimapItemResults[iAnyFinds] = sKey[1]
        ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowItemDetails(" .. sKey[1] .. ")", "Details", "Show detailed info such as where item might be found, appraise info etc. for this item.", sCOLOUR.orange, sAlternatingColour, 0)
        -- Links for editing the items in editing debug mode
        if (bDebugMode == true and bCreatingRooms == true) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowAddShopStockItem(" .. sKey[1] .. ")", "AddShop", "Add this item to current shop", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          if (sLastNPCCodeViewed ~= nil and sLastNPCCodeViewed ~= "" and sNPCs[sLastNPCCodeViewed] ~= nil and (sItemDBNPCItems[sLastNPCCodeViewed] == nil or sItemDBNPCItems[sLastNPCCodeViewed][sKey[1]] == nil)) then
            Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowAddNPCStockItem(" .. sKey[1] .. ")", "NPCSell", "Add this item to NPC " .. sLastNPCCodeViewed, sCOLOUR.orange, sAlternatingColour, 0)
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          end
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteItem(" .. sKey[1] .. ")", "Delete", "Delete this item from the database", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sKey[1] .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sKey[1] .. ")", "Edit", "Edit this item data in the database", sCOLOUR.orange, sAlternatingColour, 0)
        end
        ColourTell(sCOLOUR.grey, sAlternatingColour, "] ")
        ColourTell(sCOLOUR.cyan, sAlternatingColour, sKey[1])
        Note("")
      end
      sItemDataResults = nil
    end
    if (iAnyFinds == 0) then
      Tell("Unable to find any known ")
      ColourTell(sCOLOUR.orange, "", "items")
      Note(" containing '" .. sArgument .. "' in the item descriptions.")
      Note("")
    elseif (iAnyFinds == 1) then
      --Note("Automatically showing single result item details...")
      --QuowItemDetails(sMinimapItemResults[1])
    end
    -- End of description searching

  -- Search core item database by item name
  elseif (string.sub(sArgument, 1, 5) == "item ") then
    -- Try find a shop-based item
    sArgument = string.sub(sArgument, 6)

    -- First of all see if this is a number
    if (tonumber(sArgument) ~= nil and sMinimapItemResults[tonumber(sArgument)] ~= nil) then
      QuowItemDetails(sMinimapItemResults[tonumber(sArgument)])
    else
      -- See if we are limiting by area
      local iBracerLeft = string.find(sArgument, "{")
      local iBracerRight = string.find(sArgument, "}")
      local iSearchMapMatch = 0
      if (iBracerLeft and iBracerRight and iBracerLeft < iBracerRight) then
        local sLimitArea = string.sub(sArgument, iBracerLeft + 1, iBracerRight - 1)
        -- Space between right bracer and text?
        if (string.sub(sArgument, iBracerRight + 1, iBracerRight + 1) ~= " ") then
          iBracerRight = iBracerRight - 1
        end
        -- Break out the bracer data
        sArgument = string.sub(sArgument, 1, iBracerLeft - 1) .. string.sub(sArgument, iBracerRight + 2)
        if (sQuowPlaceLookups[sLimitArea] ~= nil) then
          iSearchMapMatch = sQuowPlaceLookups[sLimitArea][1]
        end
        Note("You cannot search the full item database with a location-limit, omitting your area-search...")
      end
      -- Exact match only
      local bExactMatchOnly = false
      if (string.sub(sArgument, 1, 1) == '"' and string.sub(sArgument, -1) == '"') then
        bExactMatchOnly = true
        sArgument = string.sub(sArgument, 2, -2)
      end

      -- Trim spaces
      sArgument = sArgument:match'^%s*(.*%S)' or ''

      local iAnyFinds = 0
      local bSuperShort = false
      if (bExactMatchOnly == true) then
        ColourNote(sCOLOUR.orange, "", "Checking for item named EXACTLY in full '" .. sArgument .. "'...")
        if (bScreenreader == true) then
          ColourNote(sCOLOUR.silver, "", "Use command 'minimap item <number>' for details")
        end
      else
        ColourNote(sCOLOUR.orange, "", "Searching CowBar item database for '" .. sArgument .. "'...")
        if (bScreenreader == true) then
          ColourNote(sCOLOUR.silver, "", "Use command 'minimap item <number>' for details")
        end
      end
      if (string.len(sArgument) < 3) then
        bSuperShort = true
      end
      if (bSuperShort == true and sItemDBItems[sArgument] == nil) then
        Note("(your search string is too short to search the item database, try a longer search!)")
      else
        if (bSuperShort == true) then
          Note("(your search string is too short to search the item database, but an exact match was found)")
        end
        -- Treat exact match as supershort, same functionality
        if (bExactMatchOnly == true) then
          bSuperShort = true
        end
        local sItemData
        local sItemDataResults = {}
        -- First build a list of results
        for sKey, sItemData in pairs(sItemDBItems) do
          if ((bSuperShort == false and string.find(string.lower(sKey), sArgument, 1, true) ~= nil) or (bSuperShort == true and sArgument == sKey)) then
            table.insert(sItemDataResults, {sKey, string.lower(sKey)})
          end
        end
        -- Attempt to sort the table
        table.sort(sItemDataResults, QuowSearchCompare)

        for _, sKey in pairs(sItemDataResults) do
          sItemData = sItemDBItems[sKey[1]]
          iAnyFinds = iAnyFinds + 1
          if (iAnyFinds > iSearchResultLimit) then
            Note("  [cutting list at " .. iSearchResultLimit .. ", " .. #sItemDataResults .. " matching items found]")
            iAnyFinds = iAnyFinds - 1
            break
          end
          if (iAnyFinds == 1) then
            sMinimapItemResults = {}
          end
          iAlternator = 1 - iAlternator
          if (iAlternator == 0) then
            sAlternatingColour = ""
          else
            sAlternatingColour = sCOLOUR.offblack
          end

          ColourTell(sCOLOUR.silver, sAlternatingColour, string.format("%2d", iAnyFinds))
          sMinimapItemResults[iAnyFinds] = sKey[1]
          if (bScreenreader == false) then
            ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
            Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowItemDetails(" .. sKey[1] .. ")", "Details", "Show detailed info such as where item might be found, appraise info etc. for this item.", sCOLOUR.orange, sAlternatingColour, 0)
          else
            ColourTell(sCOLOUR.silver, sAlternatingColour, ": ")
          end
          -- Links for editing the items in editing debug mode
          if (bDebugMode == true and bCreatingRooms == true) then
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
            Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowAddShopStockItem(" .. sKey[1] .. ")", "AddShop", "Add this item to current shop", sCOLOUR.orange, sAlternatingColour, 0)
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
            if (sLastNPCCodeViewed ~= nil and sLastNPCCodeViewed ~= "" and sNPCs[sLastNPCCodeViewed] ~= nil and (sItemDBNPCItems[sLastNPCCodeViewed] == nil or sItemDBNPCItems[sLastNPCCodeViewed][sKey[1]] == nil)) then
              Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowAddNPCStockItem(" .. sKey[1] .. ")", "NPCSell", "Add this item to NPC " .. sLastNPCCodeViewed, sCOLOUR.orange, sAlternatingColour, 0)
              ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
            end
            Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteItem(" .. sKey[1] .. ")", "Delete", "Delete this item from the database", sCOLOUR.orange, sAlternatingColour, 0)
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
            Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sKey[1] .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, sAlternatingColour, 0)
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
            Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sKey[1] .. ")", "Edit", "Edit this item data in the database", sCOLOUR.orange, sAlternatingColour, 0)
          end
          if (bScreenreader == false) then
            ColourTell(sCOLOUR.grey, sAlternatingColour, "] ")
          end
          ColourTell(sCOLOUR.cyan, sAlternatingColour, sKey[1])
          Note("")
        end
        sItemDataResults = nil
      end
      if (iAnyFinds == 0) then
        Tell("Unable to find any known ")
        ColourTell(sCOLOUR.orange, "", "items")
        Note(" containing '" .. sArgument .. "', try a less specific search, or remove a specific colour and try '[colour]'.")
        Note("")
      elseif (iAnyFinds == 1) then
        --Note("Automatically showing single result item details...")
        --QuowItemDetails(sMinimapItemResults[1])
      end
    end

  -- Search NPC names
  elseif (string.sub(sArgument, 1, 4) == "npc ") then
    -- Try find an NPC by name
    sArgument = string.sub(sArgument, 5)

    -- First of all see if this is a number
    if (tonumber(sArgument) ~= nil and sMinimapNPCResults[tonumber(sArgument)] ~= nil) then
      QuowShowNPCDetails(sMinimapNPCResults[tonumber(sArgument)])
    else
      -- See if we are limiting by area
      local iBracerLeft = string.find(sArgument, "{")
      local iBracerRight = string.find(sArgument, "}")
      local iSearchMapMatch = 0
      if (iBracerLeft and iBracerRight and iBracerLeft < iBracerRight) then
        local sLimitArea = string.sub(sArgument, iBracerLeft + 1, iBracerRight - 1)
        -- Space between right bracer and text?
        if (string.sub(sArgument, iBracerRight + 1, iBracerRight + 1) ~= " ") then
          iBracerRight = iBracerRight - 1
        end
        -- Break out the bracer data
        sArgument = string.sub(sArgument, 1, iBracerLeft - 1) .. string.sub(sArgument, iBracerRight + 2)
        if (sQuowPlaceLookups[sLimitArea] ~= nil) then
          iSearchMapMatch = sQuowPlaceLookups[sLimitArea][1]
        end
      end
      -- Trim spaces
      sArgument = sArgument:match'^%s*(.*%S)' or ''

      local iAnyFinds = 0
      if (iSearchMapMatch == 0) then
        ColourNote(sCOLOUR.orange, "", "Searching CowBar NPC names for '" .. sArgument .. "'...")
        if (bScreenreader == true) then
          ColourNote(sCOLOUR.silver, "", "Use command 'minimap npc <number>' for details or 'minimap routenpc <number>' to try speedwalk")
        end
      else
        ColourNote(sCOLOUR.orange, "", "Searching CowBar NPC names in " .. sQuowMapfiles[iSearchMapMatch][2].. " for '" .. sArgument .. "'...")
        if (bScreenreader == true) then
          ColourNote(sCOLOUR.silver, "", "Use command 'minimap npc <number>' for details or 'minimap routenpc <number>' to try speedwalk")
        end
      end
      if (string.len(sArgument) < 3) then
        Note("(your search string is too short to search the npc database, try a longer search!)")
      else
        local sNPCData
        local sNPCDataResults = {}
        local iLongestPlace = 0
        -- First build a list of results
        for sKey, sNPCData in pairs(sNPCs) do
          if (string.find(string.lower(sNPCData["npc_name"]), sArgument, 1, true) ~= nil and (iSearchMapMatch == 0 or sNPCData["map_id"] == iSearchMapMatch or (sRegionLinkGroups[iSearchMapMatch] ~= nil and sRegionLinkGroups[iSearchMapMatch][sNPCData["map_id"]] == true))) then
            table.insert(sNPCDataResults, {sKey, string.lower(sNPCData["npc_name"])})
            if (string.len(sQuowMapfiles[sNPCData["map_id"]][2]) > iLongestPlace) then
              iLongestPlace = string.len(sQuowMapfiles[sNPCData["map_id"]][2])
            end
          end
        end
        -- Attempt to sort the table
        table.sort(sNPCDataResults, QuowSearchCompare)
        -- Now render that list
        for _, sKey in ipairs(sNPCDataResults) do
          sNPCData = sNPCs[sKey[1]]
          iAnyFinds = iAnyFinds + 1
          if (iAnyFinds > iSearchResultLimit) then
            Note("  [cutting list at " .. iSearchResultLimit .. ", " .. #sNPCDataResults .. " matching NPC names found]")
            iAnyFinds = iAnyFinds - 1
            break
          end
          if (iAnyFinds == 1) then
            sMinimapNPCResults = {}
          end
          iAlternator = 1 - iAlternator
          if (iAlternator == 0) then
            sAlternatingColour = ""
          else
            sAlternatingColour = sCOLOUR.offblack
          end
          ColourTell(sCOLOUR.silver, sAlternatingColour, string.format("%2d", iAnyFinds))
          sMinimapNPCResults[iAnyFinds] = sKey[1]
          if (bScreenreader == false) then
            ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
            Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowNPCDetails(" .. sKey[1] .. ")", "Details", "Show details of this NPC (" .. sNPCData["npc_name"] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
            -- A valid room in the database?  Show and route links!
            if (sQuowLocationsByRoomID[sNPCData["roomid"]] ~= nil) then
              ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
              Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowJumpToRoomID(" .. sNPCData["roomid"] .. ")", "Show", "Display this location (" .. sQuowLocationsByRoomID[sNPCData["roomid"]][1] .. "," .. sQuowLocationsByRoomID[sNPCData["roomid"]][2] .. "," .. sQuowLocationsByRoomID[sNPCData["roomid"]][3] .. ") on the minimap", sCOLOUR.orange, sAlternatingColour, 0)
              ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
              Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRouteToRoomID(" .. sNPCData["roomid"] .. ")", "Route", "Attempt to find a speedwalk to this location (" .. sQuowLocationsByRoomID[sNPCData["roomid"]][1] .. "," .. sQuowLocationsByRoomID[sNPCData["roomid"]][2] .. "," .. sQuowLocationsByRoomID[sNPCData["roomid"]][3] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
            else
              -- Could be a terrain map location?
              if (string.sub(sNPCData["roomid"], 1, 1) == "{") then
                ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
                Hyperlink ("!!bfe35205f026786ea1d56e3b:MapJumptoCoordinates(" .. string.sub(sNPCData["roomid"] , 2, string.find(sNPCData["roomid"] , "}") - 1) .. ")", "Show", "Display this location on the minimap", sCOLOUR.orange, sAlternatingColour, 0)
                ColourTell(sCOLOUR.grey, sAlternatingColour, " | Route")
              end
            end
          else
            ColourTell(sCOLOUR.silver, sAlternatingColour, ": ")
          end
          -- Links for editing the items in editing debug mode
          if (bDebugMode == true and bCreatingRooms == true) then
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
            Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowAdminNPCCommand(" .. sNPCs[sKey[1]]["npc_name"] .. ")", "NPC", "Snap to this NPC for database updating", sCOLOUR.orange, sAlternatingColour, 0)
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
            Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteNPC(" .. sKey[1] .. ")", "Delete", "Delete this npc from the database", sCOLOUR.orange, sAlternatingColour, 0)
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
            Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameNPC(" .. sKey[1] .. ")", "Rename", "Rename this npc in the database", sCOLOUR.orange, sAlternatingColour, 0)
            ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
            --if ((sQuowLocationsByRoomID[sNPCData["roomid"]] ~= nil and iCurMap ~= sQuowLocationsByRoomID[sNPCData["roomid"]][1]) or (iCurMap == 99 and string.sub(sNPCData["roomid"], 1, 1) == "{")) then
              Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowMoveNPC(" .. sKey[1] .. ")", "Move", "Move this npc to your map", sCOLOUR.orange, sAlternatingColour, 0)
            --else
            --  Tell("Move")
            --end
          end
          if (bScreenreader == false) then
            ColourTell(sCOLOUR.grey, sAlternatingColour, "] ")
          end
          ColourTell(sCOLOUR.grey, sAlternatingColour, string.format("%-" .. iLongestPlace .. "s", sQuowMapfiles[sNPCData["map_id"]][2]))
          ColourTell(sCOLOUR.grey, sAlternatingColour, " : ")
          ColourTell(sCOLOUR.cyan, sAlternatingColour, sNPCData["npc_name"])
          Note("")
        end
        sNPCDataResults = nil
        if (iAnyFinds == 0) then
          Tell("Unable to find any known ")
          ColourTell(sCOLOUR.orange, "", "NPCs")
          if (iSearchMapMatch ~= 0) then
            Tell(" in ")
            ColourTell(sCOLOUR.cyan, "", sQuowMapfiles[iSearchMapMatch][2])
          end
          Note(" with a name containing '" .. sArgument .. "'.")
        elseif (iAnyFinds == 1) then
          --Note("Automatically showing single result NPC details...")
          --QuowShowNPCDetails(sMinimapNPCResults[1])
        end
      end
    end

  -- Search shop-stock inventory lines
  elseif (string.sub(sArgument, 1, 5) == "shop ") then
    -- Try find a shop-based item
    sArgument = string.sub(sArgument, 6)

    -- See if we are limiting by area
    local iBracerLeft = string.find(sArgument, "{")
    local iBracerRight = string.find(sArgument, "}")
    local iSearchMapMatch = 0
    if (iBracerLeft and iBracerRight and iBracerLeft < iBracerRight) then
      local sLimitArea = string.sub(sArgument, iBracerLeft + 1, iBracerRight - 1)
      -- Space between right bracer and text?
      if (string.sub(sArgument, iBracerRight + 1, iBracerRight + 1) ~= " ") then
        iBracerRight = iBracerRight - 1
      end
      -- Break out the bracer data
      sArgument = string.sub(sArgument, 1, iBracerLeft - 1) .. string.sub(sArgument, iBracerRight + 2)
      if (sQuowPlaceLookups[sLimitArea] ~= nil) then
        iSearchMapMatch = sQuowPlaceLookups[sLimitArea][1]
      end
    end

    -- Exact match only
    local bExactMatchOnly = false
    if (string.sub(sArgument, 1, 1) == '"' and string.sub(sArgument, -1) == '"') then
      bExactMatchOnly = true
      sArgument = string.sub(sArgument, 2, -2)
    end

    -- Trim spaces
    sArgument = sArgument:match'^%s*(.*%S)' or ''
    local iAnyFinds = 0
    if (iSearchMapMatch == 0) then
      ColourTell(sCOLOUR.orange, "", "Searching CowBar shop-stocked items for '")
    else
      ColourTell(sCOLOUR.orange, "", "Searching CowBar shop-stocked items in " .. sQuowMapfiles[iSearchMapMatch][2] .. " for '")
    end

    local iAnyFinds = 0
    if (bScreenreader == false) then
      Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowItemDetails(" .. sArgument .. ")", sArgument, "Show detailed info such as where item might be found, appraise info etc. for this item.", sCOLOUR.orange, "", 0)
    else
      ColourTell(sCOLOUR.cyan, "", sArgument)
    end
    ColourNote(sCOLOUR.orange, "", "'...")
    if (string.len(sArgument) < 3) then
      Note("(your search string is too short to search the shop database, try a longer search!)")
    else

      local sShoplistData
      local sShoplistDataResults = {}
      -- First build a list of results
      for sKey, sItemData in pairs(sItemDBShopItems) do
        if (iSearchMapMatch == 0 or sQuowLocationsByRoomID[sKey][1] == iSearchMapMatch or (sRegionLinkGroups[iSearchMapMatch] ~= nil and sRegionLinkGroups[iSearchMapMatch][sQuowLocationsByRoomID[sKey][1]] == true)) then
          for sItemName, sItemPrice in pairs(sItemDBShopItems[sKey]) do
            if ((bExactMatchOnly == false and string.find(string.lower(sItemName), sArgument, 1, true) ~= nil) or (bExactMatchOnly == true and sArgument == string.lower(sItemName))) then
              table.insert(sShoplistDataResults, {sKey, string.lower(sItemName) .. " " .. string.lower(sQuowMapfiles[sQuowLocationsByRoomID[sKey][1]][2] .. " " .. string.lower(sQuowLocationsByRoomID[sKey][4])), sItemName})
            end
          end
        end
      end
      -- Attempt to sort the table
      table.sort(sShoplistDataResults, QuowSearchCompare)

      -- Now render that list
      for _, sKeyData in ipairs(sShoplistDataResults) do
        local sKey = sKeyData[1]
        local sItemName = sKeyData[3]
        local sItemPrice = sItemDBShopItems[sKey][sItemName]
        iAnyFinds = iAnyFinds + 1
        if (iAnyFinds == 1) then
          sMinimapSearchResults = {}
        end
        if (iAnyFinds > iSearchResultLimit) then
          Note("  [cutting list at " .. iSearchResultLimit .. ", " .. #sShoplistDataResults .. " shops selling item found]")
          iAnyFinds = iAnyFinds - 1
          break
        end
        iAlternator = 1 - iAlternator
        if (iAlternator == 0) then
          sAlternatingColour = ""
        else
          sAlternatingColour = sCOLOUR.offblack
        end

        ColourTell(sCOLOUR.silver, sAlternatingColour, string.format("%2d", iAnyFinds))
        -- Shop results are special, we fill item AND place results as each can be different
        sMinimapSearchResults[iAnyFinds] = sKey
        sMinimapItemResults[iAnyFinds] = sItemName
        if (bScreenreader == false) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowJumpToRoomID(" .. sKey .. ")", "Show", "Display this location (" .. sQuowLocationsByRoomID[sKey][1] .. "," .. sQuowLocationsByRoomID[sKey][2] .. "," .. sQuowLocationsByRoomID[sKey][3] .. ") on the minimap", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRouteToRoomID(" .. sKey .. ")", "Route", "Attempt to find a speedwalk to this location (" .. sQuowLocationsByRoomID[sKey][1] .. "," .. sQuowLocationsByRoomID[sKey][2] .. "," .. sQuowLocationsByRoomID[sKey][3] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, "] ")
        else
          ColourTell(sCOLOUR.silver, sAlternatingColour, ": ")
        end
        ColourTell(sCOLOUR.cyan, sAlternatingColour, sItemName)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " @ ")
        ColourTell(sCOLOUR.cyan, sAlternatingColour, sItemPrice)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " in " .. sQuowMapfiles[sQuowLocationsByRoomID[sKey][1]][2] .. " : " .. sQuowLocationsByRoomID[sKey][4])
        Note("")
      end
      sShoplistDataResults = nil
    end
    if (iAnyFinds == 0) then
      Tell("Unable to find any known ")
      ColourTell(sCOLOUR.orange, "", "shop-stocked items")
      if (iSearchMapMatch ~= 0) then
        Tell(" in ")
        ColourTell(sCOLOUR.cyan, "", sQuowMapfiles[iSearchMapMatch][2])
      end
      Note(" containing '" .. sArgument .. "'.")
      Note("")
      Note("Try a full item search with:")
      Hyperlink ("minimap item " .. sArgument, "minimap item " .. sArgument, "Attempt a full item search for " .. sArgument, sCOLOUR.orange, "", 0)
      Note("")
    end

  -- Search location databases for string
  else
    -- Is this a forced place search with "place" in the argument (to avoid minimap commands interfering with searches)
    if (string.sub(sArgument, 1, 6) == "place ") then
      sArgument = string.sub(sArgument, 7)
      sOriginalArgument = string.sub(sOriginalArgument, 7)
    end

    -- First of all see if this is a number, and show room details for it
    if (tonumber(sArgument) ~= nil and sMinimapSearchResults[tonumber(sArgument)] ~= nil) then
      QuowShowRoomInfo(sMinimapSearchResults[tonumber(sArgument)])
      sClickedRoomID = sMinimapSearchResults[tonumber(sArgument)]
      return
    end

    -- Try searching the ID database and shotcut-name database
    ColourNote(sCOLOUR.orange, "", "Searching CowBar location database for '" .. sOriginalArgument .. "'")
    if (bScreenreader == true) then
      ColourNote(sCOLOUR.silver, "", "Use command 'minimap <number>' for details or 'minimap route <number>' to try speedwalk")
    end
    -- See if we are limiting by area
    local iBracerLeft = string.find(sArgument, "{")
    local iBracerRight = string.find(sArgument, "}")
    local iSearchMapMatch = 0
    if (iBracerLeft and iBracerRight and iBracerLeft < iBracerRight) then
      local sLimitArea = string.sub(sArgument, iBracerLeft + 1, iBracerRight - 1)
      -- Space between right bracer and text?
      if (string.sub(sArgument, iBracerRight + 1, iBracerRight + 1) ~= " ") then
        iBracerRight = iBracerRight - 1
      end
      -- Break out the bracer data
      sArgument = string.sub(sArgument, 1, iBracerLeft - 1) .. string.sub(sArgument, iBracerRight + 2)
      if (sQuowPlaceLookups[sLimitArea] ~= nil) then
        iSearchMapMatch = sQuowPlaceLookups[sLimitArea][1]
      end
    end
    -- Trim spaces
    sArgument = sArgument:match'^%s*(.*%S)' or ''

    local iAnyFinds = 0

    if (string.len(sArgument) < 4) then
      Note("(your search string is too short to search the full location database, try a longer search!)")
    else
      if (iSearchMapMatch ~= 0) then
        ColourNote(sCOLOUR.orange, "", "Limiting location search to region " .. sQuowMapfiles[iSearchMapMatch][2] .. "...")
      end

      local sLocData
      local sLocDataResults = {}
      local iLongestPlace = 0
      -- First build a list of results
      for sKey, sFindLoc in pairs(sQuowLocationsByRoomID) do
        if (sFindLoc[4] == nil) then
          if (bDebugMode == true) then
            Note("Error, FindLoc4 is nil, that is room short, room ID=" .. sKey)
          end
        elseif (string.find(string.lower(sFindLoc[4]), sArgument, 1, true) ~= nil and sFindLoc[1] ~= 99 and (iSearchMapMatch == 0 or sFindLoc[1] == iSearchMapMatch or (sRegionLinkGroups[iSearchMapMatch] ~= nil and sRegionLinkGroups[iSearchMapMatch][sFindLoc[1]] == true))) then
          table.insert(sLocDataResults, {sKey, sQuowMapfiles[sFindLoc[1]][2] .. " " .. string.lower(sFindLoc[4])})
          if (string.len(sQuowMapfiles[sFindLoc[1]][2]) > iLongestPlace) then
            iLongestPlace = string.len(sQuowMapfiles[sFindLoc[1]][2])
          end
        end
      end
      -- Attempt to sort the table
      table.sort(sLocDataResults, QuowSearchCompare)

      for _, sKeyData in pairs(sLocDataResults) do
        local sKey = sKeyData[1]
        sFindLoc = sQuowLocationsByRoomID[sKey]
        iAnyFinds = iAnyFinds + 1

        if (iAnyFinds > iSearchResultLimit) then
          Note("  [cutting list at " .. iSearchResultLimit .. ", " .. #sLocDataResults .. " matches found]")
          iAnyFinds = iAnyFinds - 1
          break
        end

        if (iAnyFinds == 1) then
          sMinimapSearchResults = {}
        end
        iAlternator = 1 - iAlternator
        if (iAlternator == 0) then
          sAlternatingColour = ""
        else
          sAlternatingColour = sCOLOUR.offblack
        end

        ColourTell(sCOLOUR.silver, sAlternatingColour, string.format("%2d", iAnyFinds))
        sMinimapSearchResults[iAnyFinds] = sKey
        if (bScreenreader == false) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowJumpToRoomID(" .. sKey .. ")", "Show", "Display this location (" .. sFindLoc[1] .. "," .. sFindLoc[2] .. "," .. sFindLoc[3] .. ") on the minimap", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRouteToRoomID(" .. sKey .. ")", "Route", "Attempt to find a speedwalk to this location (" .. sFindLoc[1] .. "," .. sFindLoc[2] .. "," .. sFindLoc[3] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, "] ")
        else
          ColourTell(sCOLOUR.silver, sAlternatingColour, ": ")
        end
        ColourTell(sCOLOUR.grey, sAlternatingColour, string.format("%-" .. iLongestPlace .. "s", sQuowMapfiles[sFindLoc[1]][2]) .. " : " .. sFindLoc[4])
        Note("")
      end
      sLocDataResults = nil
      -- Search user bookmarks too
      iAnyFinds = iAnyFinds + QuowBookmarkList(string.lower(sArgument), iAnyFinds)
    end
    if (sQuowPlaceLookups[sArgument] ~= nil) then
      Note("")
      ColourNote(sCOLOUR.orange, "", "A shortcut location was found, perhaps you were looking for:")
      local iPossMap = sQuowPlaceLookups[sArgument][1]
      local iPossX = 0
      local iPossY = 0
      iAnyFinds = iAnyFinds + 1
      if (sQuowPlaceLookups[sArgument][3] ~= nil) then
        iPossX = sQuowPlaceLookups[sArgument][3]
      else
        iPossX = sQuowMapfiles[iPossMap][5]
      end
      if (sQuowPlaceLookups[sArgument][4] ~= nil) then
        iPossY = sQuowPlaceLookups[sArgument][4]
      else
        iPossY = sQuowMapfiles[iPossMap][6]
      end
      -- get a room ID if one matches this exact co-ordinate
      sSQL = "SELECT room_id, map_id, xpos, ypos, room_short, room_type FROM rooms WHERE map_id=" .. iPossMap .. " AND xpos=" .. iPossX .. " AND ypos=" .. iPossY
      local sTempRouteRoute = ""
      for row in dbMap:nrows(sSQL) do
        sTempRouteRoute = row.room_id
        break
      end
      local sLocString = iPossMap .. "," .. iPossX .. "," .. iPossY
      if (sTempRouteRoute ~= "") then
        sMinimapSearchResults[iAnyFinds] = sTempRouteRoute
      end
      if (bScreenreader == false) then
        Tell("[")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:MapJumptoCoordinates(" .. sLocString .. ")", "Show", "Display this location (" .. sLocString .. ") on the minimap", sCOLOUR.orange, "", 0)
        if (sTempRouteRoute ~= "") then
          Tell(" | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRouteToRoomID(" .. sTempRouteRoute .. ")", "Route", "Attempt to find a speedwalk to this location (" .. iPossMap .. "," .. iPossX .. "," .. iPossY .. ")", sCOLOUR.orange, "", 0)
        end
        Tell("] ")
      else
        ColourTell(sCOLOUR.silver, sAlternatingColour, iAnyFinds .. ": ")
      end
      Tell(sQuowPlaceLookups[sArgument][2] .. " - " .. sQuowMapfiles[iPossMap][2])
      Note("")
    end
    if (iAnyFinds == 0) then
      Tell("Unable to find any known ")
      ColourTell(sCOLOUR.orange, "", "locations")
      if (iSearchMapMatch ~= 0) then
        Tell(" in ")
        ColourTell(sCOLOUR.cyan, "", sQuowMapfiles[iSearchMapMatch][2])
      end
      Note(" with a [short name] containing '" .. sArgument .. "'.")
    end
  end  
end -- End of "minimap" command handling


-- If user types "minimap" alone with no arguments
function MinimapCommandHandler(sName, sLine, wildcards)
  local iThisX = iMyX
  local iThisY = iMyY
  local sThisLine = 'minimap {' .. tostring(iCurMap) .. ', ' .. tostring(iThisX) .. ', ' .. tostring(iThisY) .. '}'

  Note("Your current minimap-position can be snapped to by another CowBar user typing: '" .. sThisLine .. "'")
  if (bDebugMode == true) then
    Tell("Debug: Current Room ID = " .. sCurrentRoomID)
    if (sQuowLocationsByRoomID[sCurrentRoomID] ~= nil) then
      Tell(" [in DB]")
    else
      Tell(" [NO DB]")
    end
    Tell(" Clicked Room ID = " .. sClickedRoomID)
    if (sQuowLocationsByRoomID[sClickedRoomID] ~= nil) then
      Note(" [in DB]")
    else
      Note(" [NO DB]")
    end
  end

  -- Handy when editing the room database, auto-clipboard this command
  if (bCreatingRooms == true) then
    SetClipboard(sThisLine)
  end

  -- If in admin edit mode, re-position the database position of our current room ID
  if (sCurrentRoomID ~= "" and bCreatingRooms == true and sCurrentRoomID ~= "AMShades" and sCurrentRoomID ~= "BPMedina" and sCurrentRoomID ~= "UULibrary" and sCurrentRoomID ~= "LSpace" and sCurrentRoomID ~= "UnknownRoom") then
    if (sQuowLocationsByRoomID[sCurrentRoomID] == nil) then
      sQuowLocationsByRoomID[sCurrentRoomID] = {iCurMap, iThisX, iThisY, sThisRealRoomTitle, sThisRoomType}
      sSQL = "INSERT INTO rooms VALUES ('" .. sCurrentRoomID .. "', " .. iCurMap ..", " .. iThisX .. ", " .. iThisY .. ", '" .. EscapeSQL(sThisRealRoomTitle) .. "', '" .. EscapeSQL(sThisRoomType) .. "')"
      assert(dbMap:execute(sSQL))
      ColourNote(sCOLOUR.orange, "", sSQL)
    else
      if (sQuowLocationsByRoomID[sCurrentRoomID][1] ~= iCurMap or sQuowLocationsByRoomID[sCurrentRoomID][2] ~= iThisX or sQuowLocationsByRoomID[sCurrentRoomID][3] ~= iThisY or sQuowLocationsByRoomID[sCurrentRoomID][4] ~= sThisRoomTitle or sQuowLocationsByRoomID[sCurrentRoomID][5] ~= sThisRoomType) then
        sQuowLocationsByRoomID[sCurrentRoomID][1] = iCurMap
        sQuowLocationsByRoomID[sCurrentRoomID][2] = iThisX
        sQuowLocationsByRoomID[sCurrentRoomID][3] = iThisY
        sQuowLocationsByRoomID[sCurrentRoomID][4] = sThisRealRoomTitle
        sQuowLocationsByRoomID[sCurrentRoomID][5] = sThisRoomType
        sSQL = "UPDATE rooms SET map_id=" .. iCurMap ..", xpos=" .. iThisX .. ", ypos=" .. iThisY .. ", room_short='" .. EscapeSQL(sThisRealRoomTitle) .. "', room_type='" .. EscapeSQL(sThisRoomType) .. "' WHERE room_id='" .. sCurrentRoomID .. "'"
        assert(dbMap:execute(sSQL))
        ColourNote(sCOLOUR.cyan, "", sSQL)
      else
        ColourNote(sCOLOUR.cyan, "", "No change!")
      end
    end
  end
end


-- Distortion seen, draw a square
iDistortionHere = 0
function UULibraryDistortion (sName, sLine, wildcards)
  iDistortDir = 0
  if (wildcards[1] == "up ahead of") then
    if (sLastDir == "n" or sLastDir == "north") then
      iDistortDir = 1
    elseif (sLastDir == "e" or sLastDir == "east") then
      iDistortDir = 2
    elseif (sLastDir == "s" or sLastDir == "south") then
      iDistortDir = 3
    elseif (sLastDir == "w" or sLastDir == "west") then
      iDistortDir = 4
    end
  elseif (wildcards[1] == "to the right of") then
    if (sLastDir == "n" or sLastDir == "north") then
      iDistortDir = 2
    elseif (sLastDir == "e" or sLastDir == "east") then
      iDistortDir = 3
    elseif (sLastDir == "s" or sLastDir == "south") then
      iDistortDir = 4
    elseif (sLastDir == "w" or sLastDir == "west") then
      iDistortDir = 1
    end
  elseif (wildcards[1] == "behind") then
    if (sLastDir == "n" or sLastDir == "north") then
      iDistortDir = 3
    elseif (sLastDir == "e" or sLastDir == "east") then
      iDistortDir = 4
    elseif (sLastDir == "s" or sLastDir == "south") then
      iDistortDir = 1
    elseif (sLastDir == "w" or sLastDir == "west") then
      iDistortDir = 2
    end
  elseif (wildcards[1] == "to the left of") then
    if (sLastDir == "n" or sLastDir == "north") then
      iDistortDir = 4
    elseif (sLastDir == "e" or sLastDir == "east") then
      iDistortDir = 1
    elseif (sLastDir == "s" or sLastDir == "south") then
      iDistortDir = 2
    elseif (sLastDir == "w" or sLastDir == "west") then
      iDistortDir = 3
    end
  end 
  iDistortionHere = iDistortDir
  RedrawMap()
end


-- Check this Room ID is in our room ID database
sPreviousApparentRoomID, iScaleX, iScaleY, iHubX, iHubY = "", 103488, 103488, 2840, 3639

function RoomIDMapFind()
  -- Pop the first element from our movement queue
  local iShiftMove = table.remove (iMapShiftQueue, 1)
  -- Count this as a valid move (though we may just have glanced/looked...)
  iTimeSinceLastMove = OST()
  -- Store last probably valid direction
  sOldDir = sLastDir
  -- Store real room title before we start changing it for special handlers
  sThisRealRoomTitle = sThisRoomTitle
  -- Object for quick reference of data
  local objHere

  -- Do we recognise this room in our database?
  if (sQuowLocationsByRoomID[sCurrentRoomID] ~= nil and sCurrentRoomID ~= "UnknownRoom") then
    iSRoom = 0
    objHere = sQuowLocationsByRoomID[sCurrentRoomID]
    -- Check this map ID exists
    if (sQuowMapfiles[objHere[1]] ~= nil) then
      sCurrentMap = sQuowMapfiles[objHere[1]][1]
      iCurMap = objHere[1]
      if (bReBroadcastData == true) then
        BroadcastPlugin(1, "minimap.mapid {" .. iCurMap .. "}")
      end
      iCharLocMap = iCurMap
      iMyX = objHere[2]
      iMyY = objHere[3]
      iOldMX = iMyX
      iOldMY = iMyY
      sOldMap = sCurrentMap
      iOldMap = iCurMap
      iCatchupX = iMyX
      iCatchupY = iMyY

      if (bCreatingRooms == true and sThisRoomTitle ~= objHere[4]) then
        ColourNote(sCOLOUR.orange,"","Updated room short, from |" .. objHere[4] .. "| to |" .. sThisRealRoomTitle .. "|")
        sQuowLocationsByRoomID[sCurrentRoomID][4] = sThisRealRoomTitle
        sQuowLocationsByRoomID[sCurrentRoomID][5] = sThisRoomType
        sSQL = "UPDATE rooms SET room_short='" .. EscapeSQL(sThisRealRoomTitle) .. "', room_type='" .. EscapeSQL(sThisRoomType) .. "' WHERE room_id='" .. sCurrentRoomID .. "'"
        assert(dbMap:execute(sSQL))
        ColourNote(sCOLOUR.cyan, "", sSQL)
      end
      if (iThisRoomTerrain == 1 and iCurMap == 99 and iTerrainX ~= nil and iTerrainY ~= nil) then
        -- We're in a RECOGNISED spot, that also happens to be terrain, auto-adjust our position for a while
        iTerrainShiftX = iMyX - (iHubX + math.floor(iTerrainX / iScaleX))
        iTerrainShiftY = iMyY - (iHubY - math.floor(iTerrainY / iScaleY))
      end
    end
    -- Unhide the minimap if we're temporarily hidden
    if (bMinimapHidden == true and bMinimapTempHidden == true) then
      bMinimapHidden = false
      bMinimapTempHidden = false
      WindowShow(winMinimap, true)
      WINDATA[winMinimap]["SHOW"] = true
    end
    -- Hide the ASCII map if needed
    if (bAutoShowHideAscii == true and MODULES["ascii"] == true and WINDATA[winAscii]["SHOW"] == true) then
      WindowShow(winAscii, false)
      WINDATA[winAscii]["SHOW"] = false
    end

  else
    if (iShiftMove ~= nil) then
      iMyX = iMyX + iShiftMove[1]
      iMyY = iMyY + iShiftMove[2]
      iOldMX = iMyX
      iOldMY = iMyY
    end
    -- See if this is a "special id" instead
    MinimapCheckSpecialID(sCurrentRoomID, sThisRoomTitle)
  end

  -- Edit-mode to create database entries
  if (bCreatingRooms == true and bCreatingActualNewRooms == true) then
    if (sCurrentRoomID ~= sOldRoomID) then
      if (sQuowLocationsByRoomID[sCurrentRoomID] == nil and sCurrentRoomID ~= "AMShades" and sCurrentRoomID ~= "BPMedina" and sCurrentRoomID ~= "UULibrary" and sCurrentRoomID ~= "LSpace") then
        local iThisX = iMyX
        local iThisY = iMyY
        sQuowLocationsByRoomID[sCurrentRoomID] = {iCurMap, iThisX, iThisY, sThisRealRoomTitle, sThisRoomType}
        sSQL = "INSERT INTO rooms VALUES ('" .. sCurrentRoomID .. "', " .. iCurMap ..", " .. iThisX .. ", " .. iThisY .. ", '" .. EscapeSQL(sThisRealRoomTitle) .. "', '" .. EscapeSQL(sThisRoomType) .. "')"
        assert(dbMap:execute(sSQL))
        ColourNote(sCOLOUR.orange, "", sSQL)
        if (sQuowExitsByID[sCurrentRoomID] == nil) then
          sQuowExitsByID[sCurrentRoomID] = {}
        end
        if (sQuowExitsByExit[sCurrentRoomID] == nil) then
          sQuowExitsByExit[sCurrentRoomID] = {}
        end
      end
      if (sOldRoomID ~= "" and bLastRoomFailGMCP == false and bIgnoreExits == false and sCurrentRoomID ~= "AMShades" and sCurrentRoomID ~= "BPMedina" and sCurrentRoomID ~= "UULibrary" and sCurrentRoomID ~= "LSpace") then
        local sThisDir = DirectionConvert(sLastSentCommand)
        if (sThisDir ~= nil and sThisDir ~= "") then
          ColourNote(sCOLOUR.cyan, "", " [room_exits='" .. sOldRoomID .. "'='" .. sCurrentRoomID .. "' using '" .. sThisDir .. "']")
          sSQL = "INSERT INTO room_exits VALUES ('" .. sOldRoomID .. "', '" .. sCurrentRoomID .."', '" .. sThisDir .. "', 0)"
          assert(dbMap:execute(sSQL))

          -- Double update to overwrite possible guess-returns
          sSQL = "UPDATE room_exits SET exit='" .. sThisDir .. "', guessed=0 WHERE room_id='" .. sOldRoomID .. "' AND connect_id='" .. sCurrentRoomID .."'"
          assert(dbMap:execute(sSQL))

          if (sQuowExitsByID[sOldRoomID] == nil) then
            sQuowExitsByID[sOldRoomID] = {}
          end
          sQuowExitsByID[sOldRoomID][sCurrentRoomID] = sThisDir
          if (sQuowExitsByExit[sOldRoomID] == nil) then
            sQuowExitsByExit[sOldRoomID] = {}
          end
          sQuowExitsByExit[sOldRoomID][sThisDir] = sCurrentRoomID
          -- Guess reverse moves, only inserted so never overwriting
          if (sReverseMove[sThisDir] ~= nil) then
            sSQL = "INSERT INTO room_exits VALUES ('" .. sCurrentRoomID .. "', '" .. sOldRoomID .."', '" .. sReverseMove[sThisDir] .. "', 1)"
            assert(dbMap:execute(sSQL))
            if (sQuowExitsByID[sCurrentRoomID] == nil) then
              sQuowExitsByID[sCurrentRoomID] = {}
            end
            if (sQuowExitsByID[sCurrentRoomID][sOldRoomID] == nil) then
              sQuowExitsByID[sCurrentRoomID][sOldRoomID] = sReverseMove[sThisDir]
              if (sQuowExitsByExit[sCurrentRoomID] == nil) then
                sQuowExitsByExit[sCurrentRoomID] = {}
              end
              sQuowExitsByExit[sCurrentRoomID][sReverseMove[sThisDir]] = sOldRoomID
            end
          end
        end
      end
      bLastRoomFailGMCP = false
    else
      --bLastRoomFailGMCP = true
      Note("  [debug:  this room has no GMCP data or we haven't moved]")
    end
  end
  sOldRoomID = sCurrentRoomID

  -- Finally redraw the graphical map
  RedrawMap()
end


sExitGuessType = ""
function MinimapCheckSpecialID(sApparentRoomID, sApparentRoomTitle)
  -- Since this is not a recognised unique room ID, it might be an unwanted room - eg terrains - hide the minimap for these
  --if (sQuowTerrainRooms[sApparentRoomTitle] ~= nil) then
  --if (iThisRoomTerrain == 1 and sQuowRoadRooms[sApparentRoomTitle] == nil) then
  if (iThisRoomTerrain == 1) then
    -- IN a terrain, NOT on a recognised road
    -- Auto show-hide ASCII map?
    if (bAutoShowHideAscii == true and MODULES["ascii"] == true and WINDATA[winAscii]["SHOW"] == false) then
      WindowShow(winAscii, true)
      WINDATA[winAscii]["SHOW"] = true
    end
    -- Auto-hide the main minimap in terrains
    if (bHideOnTerrain == true and bMinimapHidden == false) then
      bMinimapHidden = true
      bMinimapTempHidden = true
      WindowShow(winMinimap, false)
    end
    -- If the minimap is *NOT* hidden, we want to show the terrain overview map instead
    if (bMinimapHidden == false and bTerrainsTracking == true and iTerrainX ~= nil and iTerrainY ~= nil) then
      -- 1 pixel left/right = 300000
      -- 1 pixel up/down = 338000
      -- The higher (more negative) y gets ,the further south (higher pixel) we need
      -- 2450, 2350 = 0
      iCurMap = 99
      sCurrentMap = sQuowMapfiles[iCurMap][1]
      iMyX = iHubX + math.floor(iTerrainX / iScaleX)
      iMyY = iHubY - math.floor(iTerrainY / iScaleY)
      iMyX = iMyX + iTerrainShiftX
      iMyY = iMyY + iTerrainShiftY
      -- Lock within range
      if (iMyX < 0) then iMyX = 0 elseif (iMyX > 5809) then iMyX = 5809 end
      if (iMyY > 5000) then iMyY = 5000 
      elseif (iMyY < 2800 and iMyX < 1600) then iMyY = 2800
      elseif (iMyY < 3200 and iMyX > 1599 and iMyX < 3400) then iMyY = 3200
      elseif (iMyY < 0 and iMyX > 3399) then iMyY = 0 end
      iCatchupX = iMyX
      iCatchupY = iMyY
      iCharLocMap = iCurMap
      iOldMX = iMyX
      iOldMY = iMyY
      sOldMap = sCurrentMap
      iOldMap = iCurMap
    end
    return
  else
    -- NOT in a terrain
    -- Auto show-hide ASCII map?
    if (bAutoShowHideAscii == true and MODULES["ascii"] == true and WINDATA[winAscii]["SHOW"] == true) then
      WindowShow(winAscii, false)
      WINDATA[winAscii]["SHOW"] = false
    end
    -- Auto-hide the main minimap in terrains
    if (bHideOnTerrain == true and bMinimapHidden == true and bMinimapTempHidden == true) then
      bMinimapHidden = false
      bMinimapTempHidden = false
      WindowShow(winMinimap, true)
    end
  end
  if (sCurrentRoomID == "BPMedina") then
    -- Need to map out the exits
    if (sApparentRoomID == "MedinaGuess") then
      sExitGuessType = sApparentRoomID
      EnableTrigger("RoomExitMapping", true)
    elseif (sApparentRoomID == "BPMedina") then
      bRealMove = true
    elseif (sApparentRoomID ~= "BPMedina" and bRealMove == true) then
      -- We should ONLY set previous room ID if we ACTUALLY moved - eg our last real ID is the base value
      sPreviousApparentRoomID = sApparentRoomID
      bRealMove = false
    end
  elseif (sCurrentRoomID == "AMShades") then
    -- Shades mapping
    if (sApparentRoomID == "ShadesGuess1") then
      sExitGuessType = sApparentRoomID
      EnableTrigger("RoomExitMapping", true)
    elseif (sApparentRoomID == "ShadesGuess2") then
      sExitGuessType = sApparentRoomID
      EnableTrigger("RoomExitMapping", true)
    elseif (sApparentRoomID == "AMShades") then
      bRealMove = true
    elseif (sApparentRoomID ~= "AMShades" and bRealMove == true) then
      -- We should ONLY set previous room ID if we ACTUALLY moved - eg our last real ID is the base value
      sPreviousApparentRoomID = sApparentRoomID
      bRealMove = false
    end
  end
  -- Special handler
  --iSRoom = 0
  if (sCurrentRoomID == "01bbd8b887e71314d8e358cbaf4f585391206bc4" or sCurrentRoomID == "AMShades") then
    -- Prepare by letting handlers know we need to locate the exact shades room
    if (iSRoom == 0) then
      iSRoom = 18
    end
    iCatchupX = iMyX
    iCatchupY = iMyY
    iOldMX = iMyX
    iOldMY = iMyY
    sOldMap = sCurrentMap
    iOldMap = iCurMap
  -- Library handler
  elseif (sApparentRoomID == "UULibrary") then
    -- Already in the Library but must have been looking at another map/moving around the map?
    if (iCurMap ~= 47 and iCharLocMap == 47) then
      --Note("Were already in map 47?  Rest back to catchup?")
      iOldMX = iCatchupX
      iOldMY = iCatchupY
      iMyX = iCatchupX
      iMyY = iCatchupY
      sCurrentMap = sQuowMapfiles[iCharLocMap][1]
      iCurMap = iCharLocMap
      sOldMap = sCurrentMap
      iOldMap = iCurMap
      return
    end
    -- Ok so wasn't in the Library previously, just update our current locations to MyX/MyY
    iCatchupX = iMyX
    iCatchupY = iMyY
    iOldMX = iMyX
    iOldMY = iMyY
    sOldMap = sCurrentMap
    iOldMap = iCurMap
    iCharLocMap = iCurMap
    return
  -- L-Space detector from room-title
  elseif (iCurMap == 47 and (sApparentRoomID == "LSpaceDepths" or sApparentRoomID == "UnknownRoom")) then
    -- Did we just go south and into darkness?
    if (iMyX == 165 and iMyY == 4810) then
      sCurrentRoomID = "d67e7fc940fa14ae6356389ec1c96cc27ad81391"
      --Note("moving from uu library southmost point into darkness?")
      iCurMap = 12
      iMyX = 278
      iMyY = 393
      iCatchupX = iMyX
      iCatchupY = iMyY
      iCharLocMap = iCurMap
      iOldMX = iMyX
      iOldMY = iMyY
      sOldMap = sCurrentMap
      iOldMap = iCurMap
      return
    end
  end

  -- Try to find ourselves based on a short title/fake room ID
  if (sQuowLocationsByShort[sApparentRoomID] ~= nil) then
    local objHere = nil
    objHere = sQuowLocationsByShort[sApparentRoomID]
    if (sQuowMapfiles[objHere[1]] ~= nil) then
      -- Timing these lengthy custom room finds - can we find a faster way for long-description matches???
      if (ProfilerLong) then
        ProfilerLong(sApparentRoomID)
      end
      -- Special Shades handler if we still don't know which shades room we're in
      if (iSRoom == 18) then
        if (sApparentRoomID == "ShadesEntrance") then
          iSRoom = 17
        else
          -- Get the S-Room from our short
          iSRoom = tonumber(string.sub(sApparentRoomID, 7))
        end
      end
      sCurrentMap = sQuowMapfiles[objHere[1]][1]
      iCurMap = objHere[1]
      if (iCurMap == 47 and iOldMap == 12 and iCharLocMap ~= 47) then
        -- Outside UU Library to inside UU Library
        sLastDir = "n"
      end
      iCharLocMap = iCurMap
      iMyX = objHere[2]
      iMyY = objHere[3]
      iOldMX = iMyX
      iOldMY = iMyY
      sOldMap = sCurrentMap
      iOldMap = iCurMap
      iCatchupX = iMyX
      iCatchupY = iMyY
      sFutureRoomID = "ShortID-" .. sApparentRoomID
    end
  end
end

-- Exit mapper
function QuowRoomExitMapper(sName, sLine, sWildcards)
  EnableTrigger("RoomExitMapping", false)
  local iExitCount = sQuowNums[sWildcards[1]]
  if (iExitCount == nil) then
    iExitCount = 0
  end
  if (string.find(sLine, "enter door") ~= nil) then
    iExitCount = iExitCount - 1
  end
  local sNewShort, sNewTitle = "", ""
  if (sExitGuessType == "MedinaGuess") then
    -- Medina guesswork
    sNewTitle = "somewhere in an alleyway"
    if (iExitCount == 5) then
      sNewShort = "Medina05"
    elseif (iExitCount == 4) then
      sNewShort = "Medina13"
    elseif (iExitCount == 3) then
      if (sPreviousApparentRoomID == "Medina10" or sPreviousApparentRoomID == "Medina11" or sPreviousApparentRoomID == "Medina13" or sPreviousApparentRoomID == "Medina14" or sPreviousApparentRoomID == "Medina16" or sPreviousApparentRoomID == "Medina17" or sPreviousApparentRoomID == "Medina18") then
        sNewShort = "Medina14"
      else
        sNewShort = "Medina08"
      end
    elseif (iExitCount == 2) then
      sNewShort = "Medina15"
    end
  elseif (sExitGuessType == "ShadesGuess1") then
    -- Shades guesswork for 01, 10, 11, 13, 14
    sNewTitle = "somewhere in the Shades"
    if (iExitCount == 5) then
      sNewShort = "Shades01"
      iSRoom = 1
    elseif (iExitCount == 6) then
      sNewShort = "Shades10"
      iSRoom = 10
    elseif (iExitCount == 8) then
      sNewShort = "Shades13"
      iSRoom = 13
    elseif (iExitCount == 7) then
      -- 11, 14   -- can't be 15
      if (sPreviousApparentRoomID == "Shades01" or sPreviousApparentRoomID == "Shades02" or sPreviousApparentRoomID == "Shades03" or sPreviousApparentRoomID == "Shades10" or sPreviousApparentRoomID == "Shades12") then
        sNewShort = "Shades11"
        iSRoom = 11
      elseif (sPreviousApparentRoomID == "Shades06" or sPreviousApparentRoomID == "Shades05" or sPreviousApparentRoomID == "Shades07" or sPreviousApparentRoomID == "Shades08" or sPreviousApparentRoomID == "Shades15") then
        sNewShort = "Shades14"
        iSRoom = 14
      else
        -- Fallback
        if (iSRoom < 10) then
          sNewShort = "Shades0" .. iSRoom
        else
          sNewShort = "Shades" .. iSRoom
        end
      end
    end
  elseif (sExitGuessType == "ShadesGuess2") then
    -- Shades guesswork for 03, 04, 06, 07, 15
    sNewTitle = "somewhere in the Shades"
    if (iExitCount == 7) then
      sNewShort = "Shades15"
      iSRoom = 15
    elseif (iExitCount == 4) then
      -- 3, 4, 6, 7
      if (sPreviousApparentRoomID == "Shades11" or sPreviousApparentRoomID == "Shades02") then
        sNewShort = "Shades03"
        iSRoom = 3
      elseif (sPreviousApparentRoomID == "Shades08" or sPreviousApparentRoomID == "Shades15") then
        sNewShort = "Shades07"
        iSRoom = 7
      else
        -- Fallback
        if (iSRoom < 10) then
          sNewShort = "Shades0" .. iSRoom
        else
          sNewShort = "Shades" .. iSRoom
        end
      end
    end
  end
  -- Finalise our guessing
  if (sNewShort ~= "") then
    if (bRealMove == true) then
      sPreviousApparentRoomID = sNewShort
    end
    MinimapCheckSpecialID(sNewShort, sNewTitle)
  end
  RedrawMap()
end

-- Try to predict movement from player commands sent for map-tracking
function MinimapHandleMovement(sMovement, bAddQueue)
  if (sQuowTrackMoves[sMovement] ~= nil and iCurMap > 0) then
    -- Guesstimated movement tracking if we are waiting for a movement
    if (sQuowTrackMoves[sMovement][1] == 0 and sQuowTrackMoves[sMovement][2] == 0 and sQuowTrackMoves[sMovement][3] == 0) then
      -- Try to compass convert a library movement to accurately render where we are moving
      if (sMovement == "fw" or sMovement == "forward") then
        if (sLastDir == "n" or sLastDir == "north") then
          sMovement = "n"
        elseif (sLastDir == "e" or sLastDir == "east") then
          sMovement = "e"
        elseif (sLastDir == "s" or sLastDir == "south") then
          sMovement = "s"
        elseif (sLastDir == "w" or sLastDir == "west") then
          sMovement = "w"
        end
      elseif (sMovement == "bw" or sMovement == "backward") then
        if (sLastDir == "n" or sLastDir == "north") then
          sMovement = "s"
        elseif (sLastDir == "e" or sLastDir == "east") then
          sMovement = "w"
        elseif (sLastDir == "s" or sLastDir == "south") then
          sMovement = "n"
        elseif (sLastDir == "w" or sLastDir == "west") then
          sMovement = "e"
        end
      elseif (sMovement == "lt" or sMovement == "left") then
        if (sLastDir == "n" or sLastDir == "north") then
          sMovement = "w"
        elseif (sLastDir == "e" or sLastDir == "east") then
          sMovement = "n"
        elseif (sLastDir == "s" or sLastDir == "south") then
          sMovement = "e"
        elseif (sLastDir == "w" or sLastDir == "west") then
          sMovement = "s"
        end
      elseif (sMovement == "rt" or sMovement == "right") then
        if (sLastDir == "n" or sLastDir == "north") then
          sMovement = "e"
        elseif (sLastDir == "e" or sLastDir == "east") then
          sMovement = "s"
        elseif (sLastDir == "s" or sLastDir == "south") then
          sMovement = "w"
        elseif (sLastDir == "w" or sLastDir == "west") then
          sMovement = "n"
        end
      -- Rotational turning while in the Library, not actually MOVING per-se, just pretending we came from another direction
      elseif (sMovement == "turn around") then
        if (sLastDir == "n" or sLastDir == "north") then
          sLastDir = "s"
          RedrawMap()
          return
        elseif (sLastDir == "e" or sLastDir == "east") then
          sLastDir = "w"
          RedrawMap()
          return
        elseif (sLastDir == "s" or sLastDir == "south") then
          sLastDir = "n"
          RedrawMap()
          return
        elseif (sLastDir == "w" or sLastDir == "west") then
          sLastDir = "e"
          RedrawMap()
          return
        end
      elseif (sMovement == "turn rt" or sMovement == "turn right") then
        if (sLastDir == "n" or sLastDir == "north") then
          sLastDir = "e"
          RedrawMap()
          return
        elseif (sLastDir == "e" or sLastDir == "east") then
          sLastDir = "s"
          RedrawMap()
          return
        elseif (sLastDir == "s" or sLastDir == "south") then
          sLastDir = "w"
          RedrawMap()
          return
        elseif (sLastDir == "w" or sLastDir == "west") then
          sLastDir = "n"
          RedrawMap()
          return
        end
      elseif (sMovement == "turn lt" or sMovement == "turn left") then
        if (sLastDir == "n" or sLastDir == "north") then
          sLastDir = "w"
          RedrawMap()
          return
        elseif (sLastDir == "e" or sLastDir == "east") then
          sLastDir = "n"
          RedrawMap()
          return
        elseif (sLastDir == "s" or sLastDir == "south") then
          sLastDir = "e"
          RedrawMap()
          return
        elseif (sLastDir == "w" or sLastDir == "west") then
          sLastDir = "s"
          RedrawMap()
          return
        end
      end
    end
    -- Special Shades directions
    if (iSRoom >= 1 and iSRoom <= 17) then
      if (iSRoom == 17 and sMovement == "w") then
        sLastDir = "w"
        sFutureRoomID = "874493e57dff36b786fa5dcf7d82208560872561"
        iMyX, iMyY = sQuowLocationsByRoomID[sFutureRoomID][2], sQuowLocationsByRoomID[sFutureRoomID][3]
        iOldMX, iOldMY = iMyX, iMyY
        iCurMap = sQuowLocationsByRoomID[sFutureRoomID][1]
        sCurrentMap = sQuowMapfiles[iCurMap][1]
        table.insert (iMapShiftQueue, {0, 0, false, iCurMap})
        iTimeSinceLastMove = OST()
        RedrawMap()
        --RoomIDMapFind
        return
      end
      bAddQueue = false
      local sNewShort = ""
      -- Shades numbers input, so calculate new position
      if (sQuowTrackMoves[sMovement][1] == 6 and sQuowTrackMoves[sMovement][2] == 6) then
        if (sQSDir[iSRoom][sMovement]) then
          if (iSRoom < 10) then
            sPreviousApparentRoomID = "Shades0" .. iSRoom
          else
            sPreviousApparentRoomID = "Shades" .. iSRoom
          end
          iSRoom = sQSDir[iSRoom][sMovement][1]
          if (iSRoom < 10) then
            sNewShort = "Shades0" .. iSRoom
          else
            sNewShort = "Shades" .. iSRoom
          end
          MinimapCheckSpecialID(sNewShort, "somewhere in the Shades")
          RedrawMap()
        end
      end
      return
    end

    -- Now handle the movement in relative map-shift terms
    sLastDir = sMovement

    -- Shift the map as appropriate
    local iShiftX = (sQuowTrackMoves[sMovement][1] * sQuowMapfiles[iCurMap][3])
    local iShiftY = (sQuowTrackMoves[sMovement][2] * sQuowMapfiles[iCurMap][4])
    -- Special UU library wraparound clause
    if (iCurMap == 47) then
      if ((iMyX + iShiftX) >= 262) then
        iShiftX = iShiftX - 240
      elseif ((iMyX + iShiftX) <= 37) then
        iShiftX = iShiftX + 240
      end
    end
    -- Are we queueing this move, or doing an instant-shift?
    if (bAddQueue == true) then
      table.insert (iMapShiftQueue, {iShiftX, iShiftY, true, iCurMap}) 
      iTimeSinceLastMove = OST()
    else
      iMyX = iMyX + iShiftX
      iMyY = iMyY + iShiftY
    end
    -- Now redraw the map in the new location
    RedrawMap()
  end
end

-- Clear any predicted-movement queues and map shifts
function QuowClearQueues()
  for sKey, sShiftData in ipairs(iMapShiftQueue) do
    iMapShiftQueue[sKey] = nil
  end
  iMapShiftQueue = {}
  if (sQuowLocationsByRoomID[sCurrentRoomID] ~= nil) then
    sFutureRoomID = sCurrentRoomID
    iMyX = sQuowLocationsByRoomID[sCurrentRoomID][2]
    iMyY = sQuowLocationsByRoomID[sCurrentRoomID][3]
    iOldMX = iMyX
    iOldMY = iMyY
    if (iCurMap ~= sQuowLocationsByRoomID[sCurrentRoomID][1]) then
      iCurMap = sQuowLocationsByRoomID[sCurrentRoomID][1]
      iOldMap = iCurMap
      iCharLocMap = iCurMap
      sCurrentMap = sQuowMapfiles[iCurMap][1]
    end
  end
end


-- Window resizing to auto-shift minimap window around
bPreInstalled = false
iLastRedrew = 0
iRedrawsLastSecond = 1
function OnPluginWorldOutputResized ()
  -- Safety to prevent mass-spam on first launch due to Mushclient still loading and resizing windows, would cause crashes
  if (bPreInstalled == true) then
    if (iRedrawsLastSecond < 2 or (os.time() - iLastRedrew) > 1) then
      iRedrawsLastSecond = iRedrawsLastSecond + 1
      if ((os.time() - iLastRedrew) > 2) then
        iRedrawsLastSecond = 1
      end
      iLastRedrew = os.time()
      if (iThemeLayoutLocked > 0) then
        QuowLayoutTheme(iThemeLayoutLocked)
      else
        RedoScreenMargins()
      end
    else
      if (iThemeLayoutLocked > 0) then
        AddTimer("RedrawTimer", 0, 0, 0.5, "", 17445, "QuowLayoutTheme")
      else
        AddTimer("RedrawTimer", 0, 0, 0.5, "", 17445, "RedoScreenMargins")
      end
    end
  end
end -- function
    

-- Database editing stuff
function QuowItemUpdateOrCreate(sItemName)
  if (sItemDBItems[sItemName] ~= nil) then
    local sSaveSQL = "INSERT OR REPLACE INTO items (item_name, description, appraise_text, weight, dollar_value, searchable, special_find_note) VALUES " ..
      "('" .. EscapeSQL(sItemName) .. "', '" .. EscapeSQL(sItemDBItems[sItemName]["description"]) .. "', '" ..
      EscapeSQL(sItemDBItems[sItemName]["appraise_text"]) .. "', '" .. EscapeSQL(sItemDBItems[sItemName]["weight"]) .. "', " ..
      sItemDBItems[sItemName]["dollar_value"] .. ", " .. sItemDBItems[sItemName]["searchable"].. ", '" .. EscapeSQL(sItemDBItems[sItemName]["special_find_note"]) .. "')"
    assert(dbMap:execute(sSaveSQL))
  end
end

function QuowAdminNPCCommand(sNPCName)
  if (sNPCs[iCurMap .. "_" .. sNPCName] ~= nil) then
    QuowNPCCommand("QuowAdminNPCCommand", "npc " .. sNPCName)
  else
    ColourNote(sCOLOUR.red, "", "Safety - you mis-clicked, that NPC is not in this map... ignoring!")
  end
end

-- User typed "npc <name>"
sLastNPCID = ""
sLastNPCShort = ""
function QuowNPCCommand(sName, sLine, wildcards)
  local sThisNPCName = string.sub(sLine, 5)
  local sThisNPCID = iCurMap .. "_" .. sThisNPCName
  sLastNPCShort = sThisNPCName
  local sTempRoomID = sCurrentRoomID
  Note("Current Room ID=" .. sCurrentRoomID)
  if (sQuowLocationsByRoomID[sTempRoomID] == nil) then
    -- Room of this NPC doesn't exist in DB, check if we're in terrains
    if (iCurMap == 99) then
      sTempRoomID = "{" .. iCurMap .. "," .. iMyX .. "," .. iMyY .. "}"
      Note("Using temporary Room ID Location:" .. sTempRoomID)
    else
      ColourNote("red", "", "Warning, this npc is in a room that doesn't exist in the DB?")
    end
  end
  if (sNPCs[sThisNPCID] == nil) then
    -- This NPC doesn't currently exist, make a new one at this location
    sNPCs[sThisNPCID] = {["map_id"] = iCurMap, ["npc_name"] = sThisNPCName, ["roomid"] = sTempRoomID }
    local sSaveSQL = "INSERT OR REPLACE INTO npc_info (npc_id, map_id, npc_name, room_id) VALUES " ..
      "('" .. EscapeSQL(sThisNPCID) .. "', " .. iCurMap .. ", '" .. EscapeSQL(sThisNPCName) .. "', '" .. sTempRoomID .. "')"
    assert(dbMap:execute(sSaveSQL))
    ColourTell(sCOLOUR.red, "", "New NPC ")
    Note("'" .. sThisNPCName .. "' added, ID=" .. sThisNPCID .. " (mapid=" .. tostring(iCurMap) .. ") [DB Updated]")
  elseif (sNPCs[sThisNPCID]["roomid"] ~= sTempRoomID) then
    -- This NPC exists but at a different location, move it
    assert(dbMap:execute("UPDATE npc_info SET room_id='" .. sTempRoomID .. "' WHERE npc_id='" .. EscapeSQL(sThisNPCID) .. "'"))
    Note("NPC '" .. sThisNPCName .. "' already exists, updated roomID. [DB Updated]")
    sNPCs[sThisNPCID]["roomid"] = sTempRoomID
  else
    -- This NPC exists AND is already in this same location, no change!
    Note("NPC '" .. sThisNPCName .. "' totally unchanged.")
  end
  EnableTriggerGroup ("module_npcloot", true)
  sLastNPCID = sThisNPCID
  sLastNPCCodeViewed = sThisNPCID
  Note("Now waiting for you to look at the NPC in question, and/or browse appraise their goods one by one")
  EnableTrigger("NPCShopStockPrice", true)
  EnableTrigger("NPCShopStockPrice2", true)
  EnableTrigger("NPCShopStockPrimeDescription", false)
  EnableTrigger("NPCShopStockDescription", false)
  EnableTrigger("NPCShopItemPrimeList", true)
  EnableTrigger("NPCShopItemGather", false)
  EnableTrigger("NPCShopItemFinal", false)
end
function NPCShopItemPrimeList(sName, sLine, wildcards)
  EnableTrigger("NPCShopItemPrimeList", false)
  EnableTrigger("NPCShopItemGather", true)
  EnableTrigger("NPCShopItemFinal", true)
end
function NPCShopItemGather(sName, sLine, wildcards)
  EnableTrigger("NPCShopItemPrimeList", false)
end
function NPCShopItemFinal(sName, sLine, wildcards)
  EnableTrigger("NPCShopItemPrimeList", false)
  EnableTrigger("NPCShopItemGather", false)
  EnableTrigger("NPCShopItemFinal", false)
  Note("NPC list of items ready to nappraise")
end

sLastNPCItem = ""
function NPCShopStockPrice(sName, sLine, wildcards)
  sThisItem = FilterItemName(wildcards[1])
  sItemPrice = FilterItemName(wildcards[2])
  sLastNPCItem = sThisItem
  if (sItemDBItems[sThisItem] == nil) then
    ColourTell(sCOLOUR.red, "", "New item created (awaiting auto description): [")
    Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteItem(" .. sThisItem .. ")", "Delete", "Delete this item from the database", sCOLOUR.orange, "", 0)
    ColourTell(sCOLOUR.grey, "", " | ")
    Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sThisItem .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, "", 0)
    ColourTell(sCOLOUR.grey, "", " | ")
    Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sThisItem .. ")", "Edit", "Edit this item data in the database", sCOLOUR.red, "", 0)
    sItemDBItems[sThisItem] = {["description"] = "", ["appraise_text"] = "", ["weight"] = "", ["dollar_value"] = -1.0, ["searchable"] = 0, ["special_find_note"] = ""}
    Note("] " .. sThisItem .. " [DB Updated]")
    QuowItemUpdateOrCreate(sThisItem)
  else
    if (sItemDBNPCItems[sLastNPCID] ~= nil and sItemDBNPCItems[sLastNPCID][sThisItem] ~= nil and sItemDBNPCItems[sLastNPCID][sThisItem] ~= "") then
      Note("NPC already has this item")
    else
      Note("Item added to NPC stock [DB Updated]")
    end
  end
  if (sItemDBItems[sThisItem]["description"] == "") then
    EnableTrigger("NPCShopStockPrimeDescription", true)
  end
  if (sItemDBNPCItems[sLastNPCID] == nil) then
    sItemDBNPCItems[sLastNPCID] = {}
  end
  sItemDBNPCItems[sLastNPCID][sThisItem] = sItemPrice
  local sSaveSQL = "INSERT OR REPLACE INTO npc_items (npc_id, item_name, sale_price) VALUES " ..
    "('" .. EscapeSQL(sLastNPCID) .. "', '" .. EscapeSQL(sThisItem) .. "', '" .. EscapeSQL(sItemPrice) .. "')"
  assert(dbMap:execute(sSaveSQL))
end
function NPCShopStockPrimeDescription(sName, sLine, wildcards)
  EnableTrigger("NPCShopStockPrimeDescription", false)
  EnableTrigger("NPCShopStockDescription", true)
end
function NPCShopStockDescription(sName, sLine, wildcards)
  if (sItemDBItems[sLastNPCItem]["description"] == "") then
    sItemDBItems[sLastNPCItem]["description"] = sLine
    QuowItemUpdateOrCreate(sLastNPCItem)
  end
  EnableTrigger("NPCShopStockDescription", false)
  Note("Description harvested! [DB Updated]")
end

-- Parses loot seen when looking at an NPC
function NPCLootParse(sName, sLine, wildcards, objStyles)
  local sThisItem = ""
  local sNoBuryItems = ""
  for _, objThisStyle in pairs(objStyles) do
    if (objThisStyle ~= nil and objThisStyle["style"] ~= nil and objThisStyle["style"] == 2 and objThisStyle["length"] > 0 and string.sub(objThisStyle["text"], 1, 10) ~= "corpse of ") then
      sThisItem = FilterItemName(objThisStyle["text"])

      -- Look for special NPC items with same name as other items (eg imperial guard with katana/wakizashi)
      if (sNPCObjectConvert[sLastNPCID] ~= nil and sNPCObjectConvert[sLastNPCID][sThisItem] ~= nil) then
        sThisItem = sNPCObjectConvert[sLastNPCID][sThisItem]
      end

      if (sItemDBItems[sThisItem] == nil) then
        ColourTell(sCOLOUR.red, "", "New item created : [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteItem(" .. sThisItem .. ")", "Delete", "Delete this item from the database", sCOLOUR.orange, "", 0)
        ColourTell(sCOLOUR.grey, "", " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sThisItem .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, "", 0)
        ColourTell(sCOLOUR.grey, "", " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sThisItem .. ")", "Edit", "Edit this item data in the database", sCOLOUR.red, "", 0)
        sItemDBItems[sThisItem] = {["description"] = "", ["appraise_text"] = "", ["weight"] = "", ["dollar_value"] = -1.0, ["searchable"] = 0, ["special_find_note"] = ""}
        Tell("] " .. sThisItem)
        if (sName == "NPCLoot_DeathLoot") then
          Tell(" ")
          Hyperlink ("l " .. sThisItem .. "#appraise " .. sThisItem .. "#weigh " .. sThisItem .. "#bury " .. sThisItem .. " on me", "look", "", sCOLOUR.red, "", 0)
          sNoBuryItems = sNoBuryItems .. "&" .. objThisStyle["text"]
        end
        Note(" [DB Updated]")
        QuowItemUpdateOrCreate(sThisItem)
      else
        if (sItemDBItems[sThisItem]["appraise_text"] == "" or sItemDBItems[sThisItem]["weight"] == "" or sItemDBItems[sThisItem]["dollar_value"] == -1) then
          ColourTell(sCOLOUR.orange, "", "   ['")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sThisItem .. ")", sThisItem, "Edit this item data", sCOLOUR.cyan, "", 0)
          ColourTell(sCOLOUR.orange, "", "'] missing ")
        end
        if (sItemDBItems[sThisItem]["appraise_text"] == "") then
          -- Missing appraise from item off an NPC corpse
          Tell("(appraise)")
        end
        if (sItemDBItems[sThisItem]["weight"] == "") then
          -- Missing weight from item off an NPC corpse
          Tell("(weight)")
        end
        if (sItemDBItems[sThisItem]["dollar_value"] == -1) then
          -- Missing weight from item off an NPC corpse
          Tell("(value)")
        end
        if (sItemDBItems[sThisItem]["appraise_text"] == "" or sItemDBItems[sThisItem]["weight"] == "" or sItemDBItems[sThisItem]["dollar_value"] == -1) then
          Note("")
        end
      end
      if (sItemDBNPCItems[sLastNPCID] == nil) then
        sItemDBNPCItems[sLastNPCID] = {}
      end
      if (sItemDBNPCItems[sLastNPCID][sThisItem] == nil) then
        sItemDBNPCItems[sLastNPCID][sThisItem] = ""
        local sSaveSQL = "INSERT OR REPLACE INTO npc_items (npc_id, item_name, sale_price) VALUES " ..
          "('" .. EscapeSQL(sLastNPCID) .. "', '" .. EscapeSQL(sThisItem) .. "', '')"
        assert(dbMap:execute(sSaveSQL))
        Tell("  Added: " .. sThisItem .. " | to NPC " .. sLastNPCID .. " [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteNPCItem(" .. sThisItem .. ")", "DeleteNPC", "Delete this item from this NPC", sCOLOUR.orange, "", 0)
        Note("] [DB Updated]")
        sLastNPCCodeViewed = sLastNPCID
      end
    end
  end -- Loop through everything
  if (sName == "NPCLoot_DeathLoot") then
    if (sNoBuryItems ~= "") then
      Tell("Bury all EXCEPT new things: ")
      Hyperlink ("bcjunk" .. sNoBuryItems, "bcjunk" .. sNoBuryItems, "", sCOLOUR.cyan, "", 0)
      Note("")
    else
      Tell("Bury the junk: ")
      Hyperlink ("bcjunk", "bcjunk", "", sCOLOUR.cyan, "", 0)
      Note("")
    end
    --EnableTriggerGroup ("module_npcloot", false)
  end
end


sWaitingItemList = {}
sWaitingWeightList = {}
sCapturedLines = {}
iNeedCaptures = 0
iNeedWeights = 0
sAppraiseItem = ""
-- User typed "shopappraise"
function QuowAppraiseItems(sName, sLine, wildcards)
  if (bCreatingRooms ~= true or sItemDBShopItems[sCurrentRoomID] == nil) then
    return
  end
  iNeedCaptures = 0
  iNeedWeights = 0
  sWaitingItemList = {}
  sWaitingWeightList = {}
  sCapturedLines = {}
  sItemRenaming = {}
  local iRealItemsFound = 0
  sAppraiseItem = ""
  local sAllAppraise = "alias bappraise "
  local sAllWeight = "alias bappweight "
  for sItemName, sItemPrice in pairs(sItemDBShopItems[sCurrentRoomID]) do
    iRealItemsFound = iRealItemsFound + 1
    if (sItemDBItems[sItemName]["description"] == "" or sItemDBItems[sItemName]["appraise_text"] == "") then
      if (sItemDBItems[sItemName]["stock_code"] ~= nil and sItemDBItems[sItemName]["stock_code"] ~= "") then
        sAllAppraise = sAllAppraise .. "browse appraise " .. sItemDBItems[sItemName]["stock_code"] .. ";frimble ==endapp==;"
        iNeedCaptures = iNeedCaptures + 1
        table.insert(sWaitingItemList, sItemName)
      else
        --sAllAppraise = sAllAppraise .. "browse appraise " .. sItemName .. ";"
        Note("Warning, no stock code found for item: " .. sItemName .. " ?")
      end
    end
  end
  for sItemName, sItemPrice in pairs(sItemDBShopItems[sCurrentRoomID]) do
    if (sItemDBItems[sItemName]["weight"] == "") then
      if (sItemDBItems[sItemName]["stock_code"] ~= nil and sItemDBItems[sItemName]["stock_code"] ~= "") then
        sAllWeight = sAllWeight .. "browse and weigh " .. sItemDBItems[sItemName]["stock_code"] .. ";"
        iNeedWeights = iNeedWeights + 1
        table.insert(sWaitingWeightList, sItemName)
      else
        --sAllWeight = sAllWeight .. "browse and weigh " .. sItemName .. ";"
      end
    end
  end
  if (iNeedCaptures > 0) then
    if (sAllWeight == "") then
      Send(sAllAppraise .. ";frimble ==== ALL DONE ====")
      Send("alias bappweight sb")
    else
      Send(sAllAppraise)
      Send(sAllWeight .. ";frimble ==== ALL DONE ====")
    end
    Send("bappraise")
    Send("bappweight")
    EnableTrigger("ShopPrepareBrowse", true)
    EnableTrigger("ShopCaptureBrowse", false)
  elseif (iNeedWeights > 0) then
    Send(sAllWeight  .. ";frimble ==== ALL DONE ====")
    Send("bappweight")
    Note("All captured, weights next...")
    EnableTrigger("ShopCaptureBrowse", false)
    EnableTrigger("ShopPrepareBrowse", false)
    --EnableTrigger("QuowItemWeight", true)
  else
    Note("No new item details/specifics needed from this shop...!?")
  end
end
-- Prime appraise
function ShopPrepareBrowse(sName, sLine, wildcards, styles)
  EnableTrigger("ShopCaptureBrowse", true)
  sAppraiseItem = wildcards[1]
  sAppraiseItem = table.remove(sWaitingItemList, 1)
end
-- Ignore lines
sCaptureIgnoreLines = {
  ["It is in excellent condition."] = 1,
  ["It is in very good condition."] = 1,
  ["It is in good condition."] = 1,
  ["It is in decent condition."] = 1,
  ["It is in fairly good condition."] = 1,
  ["It is in fairly poor condition."] = 1,
  ["It is in poor condition."] = 1,
  ["It is in really poor condition."] = 1,
  ["It is in very poor condition."] = 1,
  ["It is in atrocious condition."] = 1,
  ["It is a complete wreck."] = 1,
  ["They are in excellent condition."] = 1,
  ["They are in very good condition."] = 1,
  ["They are in good condition."] = 1,
  ["They are in decent condition."] = 1,
  ["They are in fairly good condition."] = 1,
  ["They are in fairly poor condition."] = 1,
  ["They are in poor condition."] = 1,
  ["They are in really poor condition."] = 1,
  ["They are in very poor condition."] = 1,
  ["They are in atrocious condition."] = 1,
  ["They are a complete wreck."] = 1,
  ["It appears to have something written on it."] = 1,
  ["It has a small label stuck on it."] = 1,
  ["There is a quiet sound of distant thunder, and a small bolt of lightning strikes the ground under the cloud."] = 1,
  ["Your Klein bottle erupts with sudden turbulence, then quickly settles down again."] = 1,
  ["Your Klein bottle rattles vigorously from side to side."] = 1,
  ["The energies inside your Klein bottle writhe and twist, seeking escape."] = 1,
}

sItemRenaming = {}
-- Capture appraise
function ShopCaptureBrowse(sName, sLine, wildcards, styles)
  if (sLine == nil or sLine == "" or sCaptureIgnoreLines[sLine] ~= nil or styles == nil or styles[1] == nil or styles[1]["textcolour"] ~= 12632256 or string.sub(sLine, 1, 1) == "[" or (styles[2] ~= nil and styles[2]["length"] ~= nil and tonumber(styles[2]["length"]) > 0 and styles[2]["textcolour"] ~= 12632256)) then
    return
  end
  local bFinished = false
  if (sLine == "==endapp==" or (#sCapturedLines > 1 and string.find(sCapturedLines[#sCapturedLines], "long") ~= nil and string.find(sCapturedLines[#sCapturedLines], "wide") ~= nil and string.find(sCapturedLines[#sCapturedLines], "made of") ~= nil)) then
    bFinished = true
  end
  if (#sCapturedLines > 1 and sCapturedLines[#sCapturedLines] == "Don't play with your food!") then
    bFinished = true
  end
  if (bFinished == false) then
    sLine = string.gsub(sLine, "  It is in excellent condition.", "")
    sLine = string.gsub(sLine, "  It is in very good condition.", "")
    sLine = string.gsub(sLine, "  It is in good condition.", "")
    sLine = string.gsub(sLine, "  It is in decent condition.", "")
    sLine = string.gsub(sLine, "  It is in fairly good condition.", "")
    sLine = string.gsub(sLine, "  It is in fairly poor condition.", "")
    sLine = string.gsub(sLine, "  It is in poor condition.", "")
    sLine = string.gsub(sLine, "  It is in really poor condition.", "")
    sLine = string.gsub(sLine, "  It is in very poor condition.", "")
    sLine = string.gsub(sLine, "  It is in atrocious condition.", "")
    sLine = string.gsub(sLine, "  It is a complete wreck.", "")
    sLine = string.gsub(sLine, "  They are in excellent condition.", "")
    sLine = string.gsub(sLine, "  They are in very good condition.", "")
    sLine = string.gsub(sLine, "  They are in good condition.", "")
    sLine = string.gsub(sLine, "  They are in decent condition.", "")
    sLine = string.gsub(sLine, "  They are in fairly good condition.", "")
    sLine = string.gsub(sLine, "  They are in fairly poor condition.", "")
    sLine = string.gsub(sLine, "  They are in poor condition.", "")
    sLine = string.gsub(sLine, "  They are in really poor condition.", "")
    sLine = string.gsub(sLine, "  They are in very poor condition.", "")
    sLine = string.gsub(sLine, "  They are in atrocious condition.", "")
    sLine = string.gsub(sLine, "  They are a complete wreck.", "")
    table.insert(sCapturedLines, sLine)
  else
    local sAppraiseDescription = ""
    for iN = 1, #sCapturedLines do
      if (iN < #sCapturedLines) then
        if (sAppraiseDescription ~= "") then
          sAppraiseDescription = sAppraiseDescription .. "  "
        end
        sAppraiseDescription = sAppraiseDescription .. sCapturedLines[iN]
      else
        sAppraiseData = sCapturedLines[iN]
      end
    end
    sCapturedLines = {}
    EnableTrigger("ShopCaptureBrowse", false)
    if (sItemDBItems[sAppraiseItem] == nil) then
      Note("Strange... item '" .. sAppraiseItem .. "' doesn't even exist?  Why/how are we browsing it?")
      sItemDBItems[sAppraiseItem] = {}
      Note("Turning it into a blank array...")
      sItemDBItems[sAppraiseItem] = {["description"] = "", ["appraise_text"] = "", ["weight"] = "", ["dollar_value"] = -1.0, ["searchable"] = 0, ["special_find_note"] = ""}
    end

    sItemDBItems[sAppraiseItem]["description"] = sAppraiseDescription
    sItemDBItems[sAppraiseItem]["appraise_text"] = sAppraiseData
    QuowItemUpdateOrCreate(sThisItem)

    Note("Item=" .. sAppraiseItem)
    Note("Describe=" .. sAppraiseDescription)
    Note("Appraise=" .. sAppraiseData)
    Note("[DB Updated]")

    -- Special description regex search to auto-merge tricky items, like himations, chitons, certain sandals etc.
    for iN = 1, #rexDescriptionChecks do
      iRegexMatch, iLength, sMatchings = rexDescriptionChecks[iN][1]:match(sAppraiseDescription)
      if (iRegexMatch ~= nil and iRegexMatch == 1 and sAppraiseItem ~= rexDescriptionChecks[iN][2]) then
        Note("(auto-renaming due to a description match)")
        sItemRenaming[sAppraiseItem] = rexDescriptionChecks[iN][2]
        QuowRenameItem(sAppraiseItem, rexDescriptionChecks[iN][2])
        sAppraiseItem = rexDescriptionChecks[iN][2]
      end
    end

    iNeedCaptures = iNeedCaptures - 1
    if (iNeedCaptures < 1) then
      Note("All captured, weights next...")
      EnableTrigger("ShopCaptureBrowse", false)
      EnableTrigger("ShopPrepareBrowse", false)
      --EnableTrigger("QuowItemWeight", true)
    end
  end
end

-- Finding items from searching
sQuowSearchIgnore = {
  ["One Ankh-Morpork penny"] = 1,
}
function QuowScavengeItem(sName, sLine, wildcards, objStyles)
  local sThisItem = ""
  for _, objThisStyle in pairs(objStyles) do
    if (objThisStyle ~= nil and objThisStyle["style"] ~= nil and objThisStyle["style"] == 2 and objThisStyle["length"] > 0) then
      sThisItem = FilterItemName(objThisStyle["text"])
      if (sQuowSearchIgnore[sThisItem] == nil) then
        if (sItemDBItems[sThisItem] == nil) then
          ColourTell(sCOLOUR.red, "", "New item created : [")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteItem(" .. sThisItem .. ")", "Delete", "Delete this item from the database", sCOLOUR.orange, "", 0)
          ColourTell(sCOLOUR.grey, "", " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sThisItem .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, "", 0)
          ColourTell(sCOLOUR.grey, "", " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sThisItem .. ")", "Edit", "Edit this item data in the database", sCOLOUR.red, "", 0)
          sItemDBItems[sThisItem] = {["description"] = "", ["appraise_text"] = "", ["weight"] = "", ["dollar_value"] = -1.0, ["searchable"] = 0, ["special_find_note"] = ""}
          Tell("] " .. sThisItem)
          Hyperlink ("l " .. sThisItem .. "#appraise " .. sThisItem .. "#weigh " .. sThisItem .. "#bury " .. sThisItem .. " on me", "look", "", sCOLOUR.red, "", 0)
          Note(" [DB Updated]")
        end
        if (sItemDBItems[sThisItem]["searchable"] == 0 or iCurMap < sItemDBItems[sThisItem]["searchable"]) then
          sItemDBItems[sThisItem]["searchable"] = iCurMap
          Note(sThisItem .. " is now searchable on " .. sQuowMapfiles[iCurMap][2] .. " [DB Updated]")
        end
        QuowItemUpdateOrCreate(sThisItem)
      end
    end
  end
end


function QuowWeighBalance(sName, sLine, wildcards)
  EnableTrigger("QuowAccurateWeight", true)
  Send("weigh " .. wildcards[1] .. " on balance")
end

-- From scales & balances
function QuowAccurateItemWeight(sName, sLine, wildcards, objStyles)
  local sThisItem = ""
  for _, objThisStyle in pairs(objStyles) do
    if (objThisStyle ~= nil and objThisStyle["style"] ~= nil and objThisStyle["style"] == 2 and objThisStyle["length"] > 0) then
      sThisItem = FilterItemName(objThisStyle["text"])
      if (sItemDBItems[sThisItem] == nil) then
        ColourTell(sCOLOUR.red, "", "This item you are weighing doesn't exist in the DB, do you want to add it...?")
        --[[
        ColourTell(sCOLOUR.red, "", "New item created : [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteItem(" .. sThisItem .. ")", "Delete", "Delete this item from the database", sCOLOUR.orange, "", 0)
        ColourTell(sCOLOUR.grey, "", " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sThisItem .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, "", 0)
        ColourTell(sCOLOUR.grey, "", " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sThisItem .. ")", "Edit", "Edit this item data in the database", sCOLOUR.red, "", 0)
        sItemDBItems[sThisItem] = {["description"] = "", ["appraise_text"] = "", ["weight"] = "", ["dollar_value"] = -1.0, ["searchable"] = 0, ["special_find_note"] = ""}
        Note("] " .. sThisItem .. " [DB Updated]")
        --]]
      else
        sItemDBItems[sThisItem]["weight"] = wildcards[2]
        QuowItemUpdateOrCreate(sThisItem)
        Note(sThisItem .. " weight=" .. sItemDBItems[sThisItem]["weight"] .. " [DB Updated]")
      end
    end
  end
  EnableTrigger("QuowAccurateWeight", false)
end

function QuowItemWeight(sName, sLine, wildcards, objStyles)
  local sThisTempItem = ""
  local sThisTempWeight = ""
  local bBatch = false
  -- Getting from a batch shop browse, or a manual "weigh" command?
  if (#sWaitingWeightList > 0) then
    bBatch = true
    sThisTempItem = table.remove(sWaitingWeightList, 1)
    sThisTempWeight = wildcards[2]
    if (sItemRenaming[sThisTempItem] ~= nil) then
      sThisTempItem = sItemRenaming[sThisTempItem]
    end
    Note("Item=" .. sThisTempItem)
    Note("Weight=" .. sThisTempWeight)
    if (sItemDBItems[sThisTempItem] == nil) then
      Note("Item weighing failed, item name changed mid-way through?")
      --sItemDBItems[sThisTempItem] = {["description"] = "", ["appraise_text"] = "", ["weight"] = "", ["dollar_value"] = -1.0, ["searchable"] = 0, ["special_find_note"] = ""}
    else
      -- Only input if old weight is missing, or new weight is not a guesstimate
      if (sItemDBItems[sThisTempItem]["weight"] == "" or string.sub(sThisTempWeight, 1, 6) ~= "about ") then
        sItemDBItems[sThisTempItem]["weight"] = sThisTempWeight
        QuowItemUpdateOrCreate(sThisTempItem)
      end
    end
    if (#sWaitingWeightList < 1) then
      Note("All weighed! [DB Updated]")
      --EnableTrigger("QuowItemWeight", false)
    end
  else
    bBatch = false
    sThisTempWeight = wildcards[2]
    for _, objThisStyle in pairs(objStyles) do
      if (objThisStyle ~= nil and objThisStyle["style"] ~= nil and objThisStyle["style"] == 2 and objThisStyle["length"] > 0 and string.sub(objThisStyle["text"], 1, 10) ~= "corpse of ") then
        sThisTempItem = FilterItemName(objThisStyle["text"])
        Note("Item=" .. sThisTempItem)
        if (sItemDBItems[sThisTempItem] == nil) then
          ColourTell(sCOLOUR.red, "", "This item you are weighing doesn't exist in the DB, do you want to add it...?")
          return
        end
        if (sItemDBItems[sThisTempItem]["weight"] == "") then
          sItemDBItems[sThisTempItem]["weight"] = sThisTempWeight
          QuowItemUpdateOrCreate(sThisTempItem)
          ColourTell(sCOLOUR.orange, "", "Item weight updated to '" .. sThisTempWeight .. "' : [")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sThisTempItem .. ")", "Edit", "Edit this item data in the database", sCOLOUR.orange, "", 0)
          ColourNote(sCOLOUR.orange, "", "] " .. sThisTempItem .. " [DB Updated]")
        end
      end
    end
  end
end

-- User typed "list"
function HandleShopList(sName, sLine, wildcards)
  if (bCreatingRooms == true) then
    EnableTrigger("ShopStandardInventory", true)
    EnableTrigger("ShopRestaurantInventory", true)
  end
  Send("list")
end

sItemAdjectives = "adorable|comfortable|elaborate|fancy|fluffy|itchy|magnificent|monstrous|quirky|simple|stretchy|torn|uncomfortable|weird"
sItemMaterials = "cotton|linen|silk"

--
rexChecks = {
  {rex.new("^lantern (lit)$"), "lantern"},
  {rex.new("^a smelly seed$"), "smelly seed"},
  {rex.new("^glass ink well of (.+) ink$"), "glass ink well of [colour] ink"},
  {rex.new("^ink well containing (.+) ink$"), "ink well containing [colour] ink"},
  {rex.new("^One fish carved from varnish$"), "fish carved from varnish"},
  {rex.new("^spool of ((?!strong sinew)(.+)) thread$"), "spool of [colour] thread"},
  {rex.new("^tub of (.+) dye$"), "tub of [colour] dye"},
  {rex.new("^smart (.+) dog jacket$"), "smart [colour] dog jacket"},
  {rex.new("^(.+) toy poodle$"), "[adjective] [colour] toy poodle"},
  {rex.new("^(.+) Ramtop wolfhound$"), "[adjective] [colour] Ramtop wolfhound"},
  {rex.new("^(.+) poodle$"), "[adjective] [colour] poodle"},
  {rex.new("^(.+) beagle$"), "[adjective] beagle"},
  {rex.new("^(.+) bloodhound$"), "[adjective] bloodhound"},
  {rex.new("^(.+) cabbage hound$"), "[adjective] cabbage hound"},
  {rex.new("^(.+) wire-haired retriever$"), "[adjective] wire-haired retriever"},
  {rex.new("^(.+) curly-coated retriever$"), "[adjective] curly-coated retriever"},
  {rex.new("^(.+) golden retriever$"), "[adjective] golden retriever"},
  {rex.new("^(.+) fox terrier$"), "[adjective] fox terrier"},
  {rex.new("^(.+) skye terrier$"), "[adjective] skye terrier"},
  {rex.new("^(.+) wire-haired terrier$"), "[adjective] wire-haired terrier"},
  {rex.new("^(.+) foxhound$"), "[adjective] foxhound"},
  {rex.new("^(.+) deerhound$"), "[adjective] [colour] deerhound"},
  {rex.new("^(.+) kelpie$"), "[colour] kelpie"},
  {rex.new("^(.+) angora cat$"), "[colour] angora cat"},
  {rex.new("^(.+) archangel cat$"), "[colour] archangel cat"},
  {rex.new("^(.+) curly-haired cat$"), "[colour] curly-haired cat"},
  {rex.new("^(.+) fox cat$"), "[colour] fox cat"},
  {rex.new("^(.+) leopard cat$"), "[colour] leopard cat"},
  {rex.new("^(.+) ragdoll cat$"), "[colour] ragdoll cat"},
  {rex.new("^(.+) spaniel$"), "[colour] spaniel"},
  {rex.new("^(.+) tsortean cat$"), "[colour] tsortean cat"},
  {rex.new("^(.+) greyhound$"), "[adjective] [colour] greyhound"},
  {rex.new("^tin of (.+) paint$"), "tin of [colour] paint"},
  {rex.new("^(.+) pen case$"), "[colour] pen case"},
  {rex.new("^sheet of cute (.+) writing paper$"), "sheet of cute [animal] writing paper"},
  {rex.new("^sheet of (.+) glittery paper$"), "sheet of [colour] glittery paper"},
  {rex.new("^(.+) moon dragon shirt$"), "[colour] moon dragon shirt"},
  {rex.new("^pair of (.+) moon dragon earrings$"), "pair of [type] moon dragon earrings"},
  {rex.new("^((?!sand-coloured)(.+)) coloured candle$"), "[colours] coloured candle"},
  {rex.new("^(.+) riving of (.+)$"), "[length] riving of [wood]"},
  {rex.new("^(.+) sliver of octiron$"), "[colour] sliver of octiron"},
  {rex.new("^(.+) glass nugget$"), "[colour] glass nugget"},
  {rex.new("^pair of (.+) linen drawers$"), "pair of [colour] linen drawers"},
  {rex.new("^pair of (.+) worsted stockings$"), "pair of [colour] worsted stockings"},
  {rex.new("^rolled up (.+) bedroll$"), "rolled up [colour] bedroll"},
  {rex.new("^round (.+) glass jar$"), "round [colour] glass jar"},
  {rex.new("^(.+) saluki$"), "[adjective] [colour] saluki"},
  {rex.new("^(.+) silk camisole$"), "[colour] silk camisole"},
  {rex.new("^pair of (.+) stockings and suspenders$"), "pair of [colour] stockings and suspenders"},
  {rex.new("^lacy (.+) brassiere$"), "lacy [colour] brassiere"},
  {rex.new("^pair of lacy (.+) briefs$"), "pair of lacy [colour] briefs"},
  {rex.new("^piece of writing paper with (.+) edges$"), "piece of writing paper with [colour] edges"},
  {rex.new("^(.+) collie$"), "[colour] collie"},
  {rex.new("^(.+) hergen cat$"), "[colour] hergen cat"},
  {rex.new("^roll of (.+) wrapping paper$"), "roll of [pattern or colour] wrapping paper"},
  {rex.new("^roll of (.+) wallpaper$"), "roll of [pattern or colour] wallpaper"},
  {rex.new("^string of (.+) sausages$"), "string of [type] sausages"},
  {rex.new("^pair of (.+) cashmere gloves$"), "pair of [colour] cashmere gloves"},
  {rex.new("^pair of (.+) kidskin ladies'? boots$"), "pair of [colour] kidskin ladies boots"},
  {rex.new("^(.+) cashmere scarf$"), "[colour] cashmere scarf"},
  {rex.new("^(.+) ladies hat$"), "[colour] ladies hat"},
  {rex.new("^small (.+) envelope$"), "small [colour] envelope"},
  {rex.new("^(.+) bow skirt$"), "[colour] bow skirt"},
  {rex.new("^(.+) butterfly tea dress$"), "[colour] butterfly tea dress"},
  {rex.new("^(.+) chiffon wrap blouse$"), "[colour] chiffon wrap blouse"},
  {rex.new("^(.+) lace back jumper$"), "[colour] lace back jumper"},
  {rex.new("^(.+) rounded collar blouse$"), "[colour] rounded collar blouse"},
  {rex.new("^(.+) leg of mutton blouse$"), "[colour] leg of mutton blouse"},
  {rex.new("^(.+) rounded collar dress$"), "[colour] rounded collar dress"},
  {rex.new("^(.+) tulle skirt$"), "[colour] tulle skirt"},
  {rex.new("^piece of (.+)-edged writing paper$"), "piece of [colour]-edged writing paper"},
  {rex.new("^crystal ink well of (.+) ink$"), "crystal ink well of [colour] ink"},
  {rex.new("^small bag of crystals$"), "small string bag [crystals]"},
  {rex.new("^long (.+) Auriental dress$"), "long [colour] Auriental dress"},
  {rex.new("^short (.+) Auriental dress$"), "short [colour] Auriental dress"},
  {rex.new("^shiny (.+) Auriental silk blouse$"), "shiny [colour] Auriental silk blouse"},
  {rex.new("^pair of shiny (.+) silk trousers$"), "pair of shiny [colour] silk trousers"},
  {rex.new("^pair of (.+) shamfu trousers$"), "pair of [colour] shamfu trousers"},
  {rex.new("^closed colourful brochure$"), "colourful brochure"},
  {rex.new("^small waxed paper packet of ground cinnamon$"), "packet of ground cinnamon"},
  {rex.new("^small waxed paper packet of ground ginger$"), "packet of ground ginger"},
  {rex.new("^small waxed paper packet of dried basil$"), "packet of dried basil"},
  {rex.new("^small waxed paper packet of dried oregano$"), "packet of dried oregano"},
  {rex.new("^small waxed paper packet of dried thyme$"), "packet of dried thyme"},
  {rex.new("^small waxed paper packet of black pepper$"), "packet of black pepper"},
  {rex.new("^small waxed paper packet of ground turmeric$"), "packet of ground turmeric"},
  {rex.new("^small waxed paper packet of sage$"), "packet of sage"},
  {rex.new("^small waxed paper packet of powdered nutmeg$"), "packet of powdered nutmeg"},
  {rex.new("^small waxed paper packet of basil$"), "packet of basil"},
  {rex.new("^small waxed paper packet of rosemary$"), "packet of rosemary"},
  {rex.new("^small waxed paper packet of dried rosemary$"), "packet of dried rosemary"},
  {rex.new("^small waxed paper packet of cloves$"), "packet of cloves"},
  {rex.new("^small waxed paper packet of caraway$"), "packet of caraway"},
  {rex.new("^small waxed paper packet of aniseed$"), "packet of aniseed"},
  {rex.new("^small waxed paper packet of cumin$"), "packet of cumin"},
  {rex.new("^small waxed paper packet of saffron$"), "packet of saffron"},
  {rex.new("^small waxed paper packet of methi$"), "packet of methi"},
  {rex.new("^small waxed paper packet of parsley$"), "packet of parsley"},
  {rex.new("^small waxed paper packet of curry powder$"), "packet of curry powder"},
  {rex.new("^small waxed paper packet of ground cardamom$"), "packet of ground cardamom"},
  {rex.new("^small waxed paper packet of coriander$"), "packet of coriander"},
  {rex.new("^small waxed paper packet of oregano$"), "packet of oregano"},
  {rex.new("^small waxed paper packet of sumac$"), "packet of sumac"},
  {rex.new("^some powdered frog$"), "powdered frog"},
  {rex.new("^(.+?) cotton bodice$"), "[colour] cotton bodice"},
  {rex.new("^(.+?) juggling ball$"), "[colour] juggling ball"},
  {rex.new("^worn (.+) brocade sofa$"), "worn [colour] brocade sofa"},
  {rex.new("^((?!worn)(.+)) brocade sofa$"), "[colour] brocade sofa"},
  {rex.new("^(.+) chaise-longue$"), "[colour] chaise-longue"},
  {rex.new("^overstuffed (.+) brocade armchair$"), "overstuffed [colour] brocade armchair"},
  {rex.new("^overstuffed (?!.+ brocade armchair)(.+) armchair$"), "overstuffed [colour] armchair"},
  {rex.new("^pair of ((?!black)(.+)) lace gloves$"), "pair of [colour] lace gloves"},
  {rex.new("^pair of (.+) kidskin gloves$"), "pair of [colour] kidskin gloves"},
  {rex.new("^(.+) head scarf$"), "[colour] head scarf"},
  {rex.new("^(.+) formal shirt$"), "[colour] formal shirt"},
  {rex.new("^(.+) curtain dress$"), "[colour] curtain dress"},
  {rex.new("^(.+) cotton neck tie$"), "[colour] cotton neck tie"},
  {rex.new("^(.+) cotton kepi$"), "[colour] cotton kepi"},
  {rex.new("^((?!crimson)(.+)) ball gown$"), "[colour] ball gown"},
  {rex.new("^(.+) ascot$"), "[colour] ascot"},
  {rex.new("^(.+) hoop skirt$"), "[colour] [material] hoop skirt"},
  {rex.new("^(.+) pyjama top$"), "[colour] pyjama top"},
  {rex.new("^pair of (.+) pyjama bottoms$"), "pair of [colour] pyjama bottoms"},
  {rex.new("^(.+) lyre plectrum$"), "[colour] lyre plectrum"},
  {rex.new("^(?!.+ lyre plectrum)(.+) plectrum$"), "[colour] plectrum"},
  {rex.new("^((?!simple)(.+)) peasant shirt$"), "[colour] peasant shirt"},
  {rex.new("^((?!simple)(.+)) peasant blouse$"), "[colour] peasant blouse"},
  {rex.new("^(.+) linen scarf$"), "[colour] linen scarf"},
  {rex.new("^(.+) linen cloak$"), "[colour] linen cloak"},
  {rex.new("^pair of (.+) traditional sandals$"), "pair of [colour] traditional sandals"},
  {rex.new("^(.+) tasselled himation$"), "[colour] tasselled himation"},
  {rex.new("^(.+) silk thread$"), "[colour] silk thread"},
  {rex.new("^(.+) silk desert cloak$"), "[colour] silk desert cloak"},
  {rex.new("^(.+) senssu fan$"), "[colour] senssu fan"},
  {rex.new("^pair of (.+) satin gloves$"), "pair of [colour] satin gloves"},
  {rex.new("^(.+) watered silk gown$"), "[colour] watered silk gown"},
  {rex.new("^(.+) satin evening gown$"), "[colour] satin evening gown"},
  {rex.new("^charming (.+) evening dress$"), "charming [colour] evening dress"},
  {rex.new("^imposing (.+) evening gown$"), "imposing [colour] evening gown"},
  {rex.new("^pleated (.+) evening dress$"), "pleated [colour] evening dress"},
  {rex.new("^regal (.+) evening dress$"), "regal [colour] evening dress"},
  {rex.new("^sweeping (.+) taffeta gown$"), "sweeping [colour] taffeta gown"},
  {rex.new("^velvet-trimmed (.+) evening dress$"), "velvet-trimmed [colour] evening dress"},
  {rex.new("^(.+) satin cloak$"), "[colour] satin cloak"},
  {rex.new("^(.+) ruffled blouse$"), "[colour] ruffled blouse"},
  {rex.new("^(.+?) ball of (.+) fluff$"), "[size] ball of [colour] fluff"},
  {rex.new("^(.+) beetle$"), "[size] [colour] beetle"},
  {rex.new("^(.+) butterfly$"), "[size] [colour] butterfly"},
  {rex.new("^(.+) locust$"), "[size] [colour] locust"},
  {rex.new("^(.+) scorpion$"), "[size] [colour] scorpion"},
  {rex.new("^(.+) exomis$"), "[colour] exomis"},
  {rex.new("^(.+) velvet frock-coat$"), "[material]-trimmed [colour] velvet frock-coat"},
  {rex.new("^(.+) velvet Regency jacket$"), "[material]-trimmed [colour] velvet Regency jacket"},
  {rex.new("^(.+) hipflask$"), "[colour] hipflask"},
  {rex.new("^delicate (.+) robe$"), "delicate [colour] robe"},
  {rex.new("^(.+) long-sided chiton$"), "[colour] long-sided chiton"},
  {rex.new("^(.+) buttoned chiton$"), "[style] [colour] buttoned chiton"},
  {rex.new("^(.+) double-girded chiton$"), "[style] [colour] double-girded chiton"},
  {rex.new("^(.+) embroidered chiton$"), "[style] [colour] embroidered chiton"},
  {rex.new("^(.+) wicker-work lamp$"), "[colour] wicker-work lamp"},
  {rex.new("^braided (.+) wicker chair$"), "braided [colour] wicker chair"},
  {rex.new("^braided (.+) wicker sofa$"), "braided [colour] wicker sofa"},
  {rex.new("^diamond-patterned (.+) wicker chair$"), "diamond-patterned [colour] wicker chair"},
  {rex.new("^diamond-patterned (.+) wicker sofa$"), "diamond-patterned [colour] wicker sofa"},
  {rex.new("^elegant celadon jar of (.+) ink$"), "elegant celadon jar of [colour] ink"},
  {rex.new("^bottle of (.+) hair dye$"), "bottle of [colour] hair dye"},
  {rex.new("^pencil of (.+) eyeliner$"), "pencil of [colour] eyeliner"},
  {rex.new("^(.+) party beret$"), "[pattern or colour] party beret"},
  {rex.new("^tube of (.+) lipstick$"), "tube of [colour] lipstick"},
  {rex.new("^vial of (.+) nail polish$"), "vial of [colour] nail polish"},
  {rex.new("^small ((?!clear)(.+)) glass phial$"), "small [colour] glass phial"},
  {rex.new("^tiny ((?!clear)(.+)) glass phial$"), "tiny [colour] glass phial"},
  {rex.new("^pair of (.+) high heeled shoes$"), "pair of [colour] high heeled shoes"},
  {rex.new("^stick of (.+) camouflage paint$"), "stick of [colour] camouflage paint"},
  {rex.new("^sack$"), "hessian sack"},
  {rex.new("^(.+) charm$"), "[material] [shape] charm", {["6569021f515b0ae346e66e29e5919771a04eb56f"] = 1, ["f3eaaef16ed204f7e50d1eb5f9f06a612efc6955"] = 1}},
  {rex.new("^bag of (.+) flavoured Djeli beans$"), "bag of [flavour] flavoured Djeli beans"},
  {rex.new("^length of (.+) ribbon$"), "length of [colour] ribbon"},
  {rex.new("^strand of (.+) thread$"), "strand of [colour] thread"},
  {rex.new("^small string bag$"), "small string bag [crystals]"},
  {rex.new("^suspicious-looking mushroom$"), "suspicious-looking mushroom [Floppy Madman]"},
  {rex.new("^(.+) pottery shard$"), "[adjective] [colour] pottery shard"},

  --{rex.new("^((?!tiny red)(.+)) pottery shard$"), "[adjective] [colour] pottery shard"},
  -- OC stall/Creel talker items
  {rex.new("^wooden ring$"), "wooden ring [talker]", {["f6d9212a13524b0fbb5b21ad65165ac8f4514ee5"] = 1, ["3746178a5177134b11622cfead858782000d2f7b"] = 1}},
  {rex.new("^small stick$"), "small stick [talker]", {["f6d9212a13524b0fbb5b21ad65165ac8f4514ee5"] = 1}},
  -- Ninja guild
  {rex.new("^(.+) ink$"), "[colour] ink well", {["ceb4bb101eef8a019e1d2a18642768d49ec6fbb3"] = 1}},
  -- DJB post office
  {rex.new("^(.+) piece of paper$"), "[colour] piece of paper", {["8996c145b1b02f540f510abc850d8d952ca26b33"] = 1}},
  -- Bleak prospect rag dolls
  {rex.new("^(.+) rag doll$"), "[type] rag doll", {["e04e13e7dceeeb0e3338e0a3bcc80a4c3c226362"] = 1}},
  -- Sailing shop
  {rex.new("^damaged metal pole$"), "iron boathook", {["3b408d9de897bd521a3ed60b15e9c30dd477cc19"] = 1}},

  -- Assassin shop
  {rex.new("^large (.+) bottle$"), "large [colour] bottle", {["f46f9ba874ca36798aef00babb2c8a9f0fb78ce6"] = 1}},
  -- Towel stand & Stapleton
  {rex.new("^(.+) towel$"), "[colour] towel", {["16e11b4fb6d6e383e5f78e47dfa36dfe8982f2e4"] = 1, ["38bd17f65dfa3c924d7ad587db316514c3241792"] = 1, ["4ae3ad5514a77b70c241bcb8dc00867795f02f44"] = 1}},
  -- Stapleton rocks
  {rex.new("^(.+) mineral pebble$"), "[colour] mineral pebble", {["16e11b4fb6d6e383e5f78e47dfa36dfe8982f2e4"] = 1, ["4ae3ad5514a77b70c241bcb8dc00867795f02f44"] = 1}},
  -- Briony
  {rex.new("^(.+) beach towel$"), "[pattern/colour] beach towel", {["c11ada54b46b64627fc0bb9c45fd8271c7ee4a6d"] = 1}},
  -- General knickers
  {rex.new("^pair of (.+) knickers$"), "pair of [colour] [material] knickers", {["fdb3a6bfef3999a325e406a4783f1b2be839c9b7"] = 1}},

  -- Genua lingerie
  {rex.new("^(.+) stockings$"), "pair of [colour] [material] stockings", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) garter$"), "[colour] [material] garter", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) camisole$"), "[colour] [material] camisole", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) teddy$"), "[colour] [material] teddy", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) strapless corset$"), "[colour] [material] corset [strapless]", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) full cup bra$"), "[colour] [material] bra [full cup]", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) half cup bra$"), "[colour] [material] bra [half cup]", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) strapless bra$"), "[colour] [material] bra [strapless]", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) regal panties$"), "pair of [colour] [material] panties [regal]", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) plain panties$"), "pair of [colour] [material] panties [plain]", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) mesh panties$"), "pair of [colour] [material] panties [mesh]", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) string panties$"), "pair of [colour] [material] panties [string]", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) two-tone chemise$"), "[colour] [material] chemise [two-tone]", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) manties$"), "pair of [colour] [material] manties", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},
  {rex.new("^(.+) genua knickers$"), "pair of [colour] [material] knickers [genua knickers]", {["7919d62c5dcbc987dd92bb39b7a43bed439d365d"] = 1}},

  -- Brass Neck stall
  {rex.new("^chalk$"), "stick of chalk", {["601eae2be71c8de42345928b9a35f5a52f7bc414"] = 1}},
  {rex.new("^paper$"), "piece of writing paper", {["601eae2be71c8de42345928b9a35f5a52f7bc414"] = 1}},
  {rex.new("^string$"), "length of string", {["601eae2be71c8de42345928b9a35f5a52f7bc414"] = 1}},
  {rex.new("^sulphur$"), "one block of sulphur", {["601eae2be71c8de42345928b9a35f5a52f7bc414"] = 1}},
  {rex.new("^torch$"), "lightable torch", {["601eae2be71c8de42345928b9a35f5a52f7bc414"] = 1}},

  -- Sofa shop
  {rex.new("^(.+) leather sofa$"), "[colour] leather sofa", {["46e8d8d9616a306bd6446364a128a23daa57430f"] = 1}},

  {rex.new("^piece of (.+?) rock candy$"), "piece of [colour] rock candy", {["77e1a12cab7934a127fac25b98d274651d01315a"] = 1}},
  {rex.new("^(.+?) lollipop$"), "[colour] lollipop", {["77e1a12cab7934a127fac25b98d274651d01315a"] = 1}},

  -- Mannequin shop
  {rex.new("^(.+) mannequin$"), "[type/gender/guild] mannequin", {["96db778460ad523c0189a195f3b2db4b697504a3"] = 1}},
  {rex.new("^(.+) dummy$"), "[type/gender/guild] dummy", {["96db778460ad523c0189a195f3b2db4b697504a3"] = 1}},

  -- Magic stall
  {rex.new("^mysterious (.+) stone$"), "mysterious [colour] stone", {["c70b5d75a29fc0057e8be253d7ae7d4b733df50c"] = 1}},

  -- Falafels sugar
  {rex.new("^small sack$"), "small sack [sugar]", {["9bb171a2bec0a87b4fd6a9ccfc7990225995cbe6"] = 1}},

  -- Special book shop coloured non-leather-bound
  {rex.new("^(?!.+ leather-bound book$)(.+?) book$"), "[colour] book", {["b4321bd59ef87685459110db6d4ff72352e8d0ae"] = 1, ["a95f98659aa8f47bbb092ce99a939e2a7031ea27"] = 1, ["e59e946db969b09f78c4acef1c1699fbcd06e2fa"] = 1, ["20cc8d9987ae4a818d9d8bfcdb2e89c1b886af9c"] = 1, ["869c41cee9d1851da0912b73d0f58da93cfd5589"] = 1}},
  -- Special book shop coloured leather-bound
  {rex.new("^(.+?) leather-bound book$"), "[colour] leather-bound book", {["a95f98659aa8f47bbb092ce99a939e2a7031ea27"] = 1, ["3746178a5177134b11622cfead858782000d2f7b"] = 1}},
  -- Special metal bars
  {rex.new("^(.+) bar$"), "[size] [metal] bar", {["375905c93d0b436477125681c2282feeef4232cc"] = 1}},
  -- Souvenirs
  {rex.new("^(.+) mug$"), "[colour] [slogan] mug", {["429f5a855716125a62abd8595b32f947e01f83a0"] = 1}},
  {rex.new("^(.+) badge$"), "[colour] [slogan] badge", {["429f5a855716125a62abd8595b32f947e01f83a0"] = 1}},
  {rex.new("^glossy label$"), "glossy label [random slogan]", {["429f5a855716125a62abd8595b32f947e01f83a0"] = 1}},
  -- Party supplies
  {rex.new("^(.+) garland$"), "[colour] garland", {["ec3ef3c51c8e53352ec4fd6ea8b6e98b3938983a"] = 1}},
  {rex.new("^(.+) balloon$"), "[colour] balloon", {["ec3ef3c51c8e53352ec4fd6ea8b6e98b3938983a"] = 1}},
  -- Rock-a-rama
  {rex.new("^(.+) anklet$"), "[stone] anklet", {["77a274e8231965df9615d42e2e55e6658cb25cac"] = 1}},
  {rex.new("^(.+) bangle$"), "[stone] bangle", {["77a274e8231965df9615d42e2e55e6658cb25cac"] = 1}},
  {rex.new("^(.+) brooch$"), "[stone] brooch", {["77a274e8231965df9615d42e2e55e6658cb25cac"] = 1}},
  {rex.new("^(.+) choker$"), "[stone] choker", {["77a274e8231965df9615d42e2e55e6658cb25cac"] = 1}},
  {rex.new("^(.+) earring$"), "[stone] earring", {["77a274e8231965df9615d42e2e55e6658cb25cac"] = 1}},
  {rex.new("^(.+) pendant$"), "[stone] pendant", {["77a274e8231965df9615d42e2e55e6658cb25cac"] = 1}},
  {rex.new("^(.+) ring$"), "[stone] ring", {["77a274e8231965df9615d42e2e55e6658cb25cac"] = 1}},

  -- Copperhead broomstick polishes
  {rex.new("^jar of (.+?) (?:.+)-scented broom polish$"), "* [scent] broom polish", {["dd3b8b435c2620b459aabf4c1dcd1c8bd791d74c"] = 1}, true},
  {rex.new("^jar of (.+?) unscented broom polish$"), "* [scent] broom polish", {["dd3b8b435c2620b459aabf4c1dcd1c8bd791d74c"] = 1}, true},

  -- Build a bear
  {rex.new("^(.+)$"), "* [build-a-bear]", {["a388fc812da56ce9a43046f7059ad99d067b0c22"] = 1}, true},

  -- Stencil shop
  {rex.new("^(?>tiny |small |medium |large |huge |enormous )(.+) stencil$"), "[size] * stencil", {["0e2cb0fd91508ed05773c487e22f21079b804c50"] = 1}, true},

  -- Trading-post traders
  {rex.new("^((?!sand-coloured)(.+)) coloured candle from (.+)$"), "[colours] coloured candle", {["bf47ef14c4647af6629b5db3d2b185ce21f6e594"] = 1}, true},
  {rex.new("^(.+) cashmere scarf from (.+)$"), "[colour] cashmere scarf", {["bf47ef14c4647af6629b5db3d2b185ce21f6e594"] = 1}, true},
  {rex.new("^(.+) from (?>(?!varnish)(.+))$"), "*", {["bf47ef14c4647af6629b5db3d2b185ce21f6e594"] = 1}, true},

}

rexDescriptionChecks = {
  {rex.new("^This is a very (.+?) himation\\.  It flows loosely around the shoulders then drapes down the body\\.  It has been embroidered with a design of stylised (.+?) in immaculate detail all along its edges\\.  Its fabric is (.+?)\\.$"), 
      "[colour] himation"},
  {rex.new("^This is an? (.+?) himation\\.  It is designed to wrap around the wearer's waist before hanging loosely from the left shoulder exposing whatever is worn \\(or not worn\\) below it\\.  The hem has an embroidered band of (.+?) patterned along its whole length\\.  It is nothing but truly (.+?)\\.$"), 
      "[adjective] [colour] himation"},
  {rex.new("^This (.+?) himation has been carefully dyed a pleasant shade of (.+?) and decorated with tiny (.+?) in a solid band along the hemline\\.  Draped from just one shoulder, the fabric flows nicely over the body and could also cover the head like a veil\\.$"),
      "[colour] [material] himation"},
  {rex.new("^This is an? (.+?) himation\\.  It is dyed a vibrant shade of (.+?)\\.  An eye-catching pattern of (.+?) has been added to its border\\.  It is perfect for a double arrangement to hang over both shoulders before draping over the whole body\\.  The edge is patterned with (.+?)\\.  It is made from (.+?) fabric\\.$"),
      "[adjective] himation"},
  {rex.new("^A simple square of fine linen, soft and loose, drapes gently around the body, fastening at the shoulders with an array of small silver pins\\.  Traditionally worn with a girdle to gather it in at the waist, the linen falls in soft folds across the wearer's shoulders, and reaches to mid-thigh\\.$"),
      "short [colour] chiton [simple]"},
  {rex.new("^This (.+?) chiton is made of (.+?)\\.  It's worn pinned at two shoulders, without sleeves, but with a belt so that it hangs down only to the thighs\\.  A pattern of (.+?) decorates the fabric\\.$"),
      "short [colour] chiton [patterned]"},
  {rex.new("^This is a very (.+?) sleeveless chiton\\.  Simple brass clasps at the shoulder bring the folds of the garment together without straps\\.  The upper portion is nicely fitted\\.  The (.+?) fabric skims the chest and waist before draping down over the lower body\\.  An unusual design of (.+?) is embroidered along the bottom hem\\.$"),
      "[colour] chiton [patterned]"},
  {rex.new("^A simple square of fine linen, soft and loose, drapes gently around the body, fastening at the shoulders with an array of small silver pins\\.  Traditionally worn with a girdle to gather it in at the waist, the linen falls in soft folds across the wearer's shoulders, and brushes their ankles\\.$"),
      "[colour] chiton [simple]"},
  {rex.new("^This is (.+?) pair of (.+?) sandals made of (.+?)\\.  Two thin leather straps decorated with a pattern of (.+?) are attached to the base and function to keep the sandal on the foot while dividing the big toe from the smaller ones\\.$"),
      "pair of [adjective] [colour] [material] sandals"},
  {rex.new("^This is (.+?) pair of traditional sandals which was formed by lacing leather straps through the edges of a toughened double layer of (.+?)\\.  The sole and sides of each sandal are one continuous piece that wrap around the foot from the bottom and are completely open on the top, front and back \\(other than the essential strappings that bind it\\)\\.  A pattern of (.+?) embellishes the soles of each sandal\\.$"),
      "pair of traditional [colour] sandals"},
  {rex.new("^This pair of embroidered (.+?) sandals has been dyed a pleasant shade of (.+?)\\.  Very (.+?) in design, the sandals are embroidered with (.+)\\.$"),
      "pair of [colour] embroidered sandals"},
  {rex.new("^This is (.+?) pair of (.+?) sandals\\.  The top of each sandal is formed by four leather straps that criss-cross between the sides of the (.+?) sole\\.  They have been (.+?) decorated with (.+)\\.$"),
      "pair of [adjective] [colour] sandals"},
  {rex.new("^These (.+?) sandals are very (.+?) and have been dyed in a vibrant shade of (.+?)\\.  A tiny band of (.+?) decorates the sole of each sandal\\.$"),
      "pair of [colour] [material] sandals"},
  {rex.new("^This is a pair of shiny patent leather sandals\\.  Odd refractions of light dance within the (.+?) coloured leather\\.  Good for informal situations\\.$"),
      "pair of [colour] sandals [informal]"},  
}

rexStripItem = rex.new("^(?>slightly rotten |almost rotten |half rotten |mostly rotten )?(.+)$")

-- Auto-converting one item-name to another, for NPCs that have their own "special versions" of normally high-value things
sNPCObjectConvert = {
  ["1_tourist"] = {["katana"] = "katana [no value]"},
  ["17_Imperial guard"] = {["katana"] = "katana [no value]", ["wakizashi"] = "wakizashi [no value]"},
  ["17_[family] samurai"] = {["katana"] = "katana [no value]", ["wakizashi"] = "wakizashi [no value]", ["nagamaki"] = "nagamaki [no value]", ["nodachi"] = "nodachi [no value]", ["sode-garami"] = "sode-garami [no value]", ["tanto"] = "tanto [no value]", ["wooden naginata"] = "wooden naginata [no value]"},
  ["17_ninja"] = {["katana"] = "katana [no value]", ["wakizashi"] = "wakizashi [no value]", ["sharpened sai"] = "sharpened sai [no value]", ["black bokken"] = "black bokken [no value]", ["steel-tempered katana"] = "steel-tempered katana [no value]"},
  ["17_master chef"] = {["wakizashi"] = "wakizashi [no value]"},
  ["17_ronin"] = {["katana"] = "katana [no value]", ["wakizashi"] = "wakizashi [no value]"},
  ["17_Ome outlaw"] = {["katana"] = "katana [no value]", ["wakizashi"] = "wakizashi [no value]"},
  ["17_Bunk the punk junk junk monk"] = {["katana"] = "katana [no value]"},
  ["17_Triad boss"] = {["katana"] = "katana [no value]", ["wakizashi"] = "wakizashi [no value]"},
  ["19_Fang family guard"] = {["katana"] = "katana [no value]"},
  ["19_Hong family guard"] = {["katana"] = "katana [no value]"},
  ["19_McSweeney family guard"] = {["katana"] = "katana [no value]"},
  ["19_Sung family guard"] = {["katana"] = "katana [no value]"},
  ["19_Tang family guard"] = {["katana"] = "katana [no value]"},
  ["19_sword dancer"] = {["katana"] = "katana [no value]"},
  ["19_Lord Hong Jr"] = {["black velvet cape"] = "black velvet cape [mysterious]"},
  ["39_rich man"] = {["fine silk robe"] = "fine silk robe [Sto-Lat family]"},
  ["39_rich woman"] = {["fancy silk gown"] = "fancy silk gown [Sto-Lat family]"},
  ["23_officer"] = {["small copper key"] = "small copper key [DJB barracks]"},
  ["23_Ephebian mercenary"] = {["short sword"] = "short sword [thrusting sword]"},
  ["31_patroller [Oasis]"] = {["short sword"] = "short sword [thrusting sword]"},
  ["26_smuggler"] = {["knife belt"] = "knife belt [no value]"},
  ["15_Lacrimosa"] = {["small copper key"] = "small copper key [Lacrimosa]"},
  ["54_gentlewoman adventurer"] = {["utility belt"] = "utility belt [large]"},
  
}

-- Turn item names into their converted names, eg removing colours from things with randomised colours
function FilterItemName(sOldItemName)
  -- Remove concealed message
  sOldItemName = string.gsub(sOldItemName, " (concealed)", "")
  local iRegexMatch, iLength, sMatchings
  -- Strip rotten values out
  _, _, sMatchings = rexStripItem:match(sOldItemName)
  sOldItemName = sMatchings[1]
  for iN = 1, #rexChecks do
    if (rexChecks[iN][3] == nil or rexChecks[iN][3][sCurrentRoomID] ~= nil) then
      iRegexMatch, iLength, sMatchings = rexChecks[iN][1]:match(sOldItemName)
      if (iRegexMatch ~= nil and iRegexMatch == 1) then
        if (rexChecks[iN][4] ~= nil and rexChecks[iN][4] == true) then
          local sNewName = string.gsub(rexChecks[iN][2], "*", sMatchings[1])
          return sNewName
        else
          return rexChecks[iN][2]
        end
      end
    end
  end
  return sOldItemName
end

function QuowBrowseCommand(sName, sLine, wildcards)
  EnableTrigger("ShopManualBrowsePrime", true)
  EnableTrigger("ShopManualBrowseGather", false)
  Send(sLine)
end
function ShopManualBrowsePrime(sName, sLine, wildcards, objStyles)
  local sThisItem = ""
  local bNeedItemData = false
  EnableTrigger("ShopManualBrowsePrime", false)
  for _, objThisStyle in pairs(objStyles) do
    if (objThisStyle ~= nil and objThisStyle["style"] ~= nil and objThisStyle["style"] == 2 and objThisStyle["length"] > 0 and string.sub(objThisStyle["text"], 1, 10) ~= "corpse of ") then
      sThisItem = FilterItemName(objThisStyle["text"])
      if (sItemDBItems[sThisItem] == nil) then
        ColourTell(sCOLOUR.red, "", "New item created : [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteItem(" .. sThisItem .. ")", "Delete", "Delete this item from the database", sCOLOUR.orange, "", 0)
        ColourTell(sCOLOUR.grey, "", " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sThisItem .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, "", 0)
        ColourTell(sCOLOUR.grey, "", " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sThisItem .. ")", "Edit", "Edit this item data in the database", sCOLOUR.red, "", 0)
        sItemDBItems[sThisItem] = {["description"] = "", ["appraise_text"] = "", ["weight"] = "", ["dollar_value"] = -1.0, ["searchable"] = 0, ["special_find_note"] = ""}
        Tell("] " .. sThisItem)
        Note(" [DB Updated]")
        QuowItemUpdateOrCreate(sThisItem)
      end
      if (sItemDBItems[sThisItem]["description"] == "" or sItemDBItems[sThisItem]["appraise_text"] == "") then
        bNeedItemData = true
      end
      local bShopHadThis = false
      if (sItemDBShopItems[sCurrentRoomID] == nil) then
        sItemDBShopItems[sCurrentRoomID] = {}
      end
      -- Did this shop already have this item in?
      if (sItemDBShopItems[sCurrentRoomID][sThisItem] ~= nil) then
        bShopHadThis = true
      end
      if (sItemDBShopItems[sCurrentRoomID][sThisItem] == nil or sItemDBShopItems[sCurrentRoomID][sThisItem] ~= wildcards[2]) then
        -- DB Update if needed
        local sSaveSQL = "INSERT OR REPLACE INTO shop_items (room_id, item_name, sale_price) VALUES " ..
          "('" .. sCurrentRoomID .. "', '" .. EscapeSQL(sThisItem) .. "', '" .. EscapeSQL(wildcards[2]) .. "')"
        assert(dbMap:execute(sSaveSQL))
      end

      -- Update shop price regardless
      sItemDBShopItems[sCurrentRoomID][sThisItem] = wildcards[2]
      -- Do we need appraise/description data for this item?
      if (bNeedItemData == true) then
        sAppraiseItem = sThisItem
        sCapturedLines = {}
        EnableTrigger("ShopManualBrowseGather", true)
      else
        if (bShopHadThis == true) then
          Tell("Ignored, shop already has this item (price updated). [DB Updated] ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sThisItem .. ")", "Edit", "Edit this item data in the database", sCOLOUR.orange, sAlternatingColour, 0)
          Note("")
        else
          Tell("Added " .. sThisItem .. " to shop, but no need for any description data etc. [DB Updated]")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sThisItem .. ")", "Edit", "Edit this item data in the database", sCOLOUR.orange, sAlternatingColour, 0)
          Note("")
        end
      end
    end
  end
end
function ShopManualBrowseGather(sName, sLine, wildcards, styles)
  if (sLine == nil or sLine == "" or sCaptureIgnoreLines[sLine] ~= nil or styles == nil or styles[1] == nil or styles[1]["textcolour"] ~= 12632256 or string.sub(sLine, 1, 1) == "[" or (styles[2] ~= nil and styles[2]["length"] ~= nil and tonumber(styles[2]["length"]) > 0 and styles[2]["textcolour"] ~= 12632256)) then
    return
  end
  local bFinished = false
  if (sLine == "==endapp==" or (#sCapturedLines > 1 and string.find(sCapturedLines[#sCapturedLines], "long") ~= nil and string.find(sCapturedLines[#sCapturedLines], "wide") ~= nil and string.find(sCapturedLines[#sCapturedLines], "made of") ~= nil)) then
    bFinished = true
  end
  if (#sCapturedLines > 1 and sCapturedLines[#sCapturedLines] == "Don't play with your food!") then
    bFinished = true
  end
  if (bFinished == false) then
    sLine = string.gsub(sLine, "  It is in excellent condition.", "")
    sLine = string.gsub(sLine, "  It is in very good condition.", "")
    sLine = string.gsub(sLine, "  It is in good condition.", "")
    sLine = string.gsub(sLine, "  It is in decent condition.", "")
    sLine = string.gsub(sLine, "  It is in fairly good condition.", "")
    sLine = string.gsub(sLine, "  It is in fairly poor condition.", "")
    sLine = string.gsub(sLine, "  It is in poor condition.", "")
    sLine = string.gsub(sLine, "  It is in really poor condition.", "")
    sLine = string.gsub(sLine, "  It is in very poor condition.", "")
    sLine = string.gsub(sLine, "  It is in atrocious condition.", "")
    sLine = string.gsub(sLine, "  It is a complete wreck.", "")
    sLine = string.gsub(sLine, "  They are in excellent condition.", "")
    sLine = string.gsub(sLine, "  They are in very good condition.", "")
    sLine = string.gsub(sLine, "  They are in good condition.", "")
    sLine = string.gsub(sLine, "  They are in decent condition.", "")
    sLine = string.gsub(sLine, "  They are in fairly good condition.", "")
    sLine = string.gsub(sLine, "  They are in fairly poor condition.", "")
    sLine = string.gsub(sLine, "  They are in poor condition.", "")
    sLine = string.gsub(sLine, "  They are in really poor condition.", "")
    sLine = string.gsub(sLine, "  They are in very poor condition.", "")
    sLine = string.gsub(sLine, "  They are in atrocious condition.", "")
    sLine = string.gsub(sLine, "  They are a complete wreck.", "")
    table.insert(sCapturedLines, sLine)
  else
    local sAppraiseDescription = ""
    for iN = 1, #sCapturedLines do
      if (iN < #sCapturedLines) then
        if (sAppraiseDescription ~= "") then
          sAppraiseDescription = sAppraiseDescription .. "  "
        end
        sAppraiseDescription = sAppraiseDescription .. sCapturedLines[iN]
      else
        sAppraiseData = sCapturedLines[iN]
      end
    end
    sCapturedLines = {}
    EnableTrigger("ShopManualBrowseGather", false)
    if (sItemDBItems[sAppraiseItem] == nil) then
      Note("Strange... item '" .. sAppraiseItem .. "' doesn't even exist?  Why/how are we browsing it?")
      sItemDBItems[sAppraiseItem] = {}
      Note("Turning it into a blank array...")
      sItemDBItems[sAppraiseItem] = {["description"] = "", ["appraise_text"] = "", ["weight"] = "", ["dollar_value"] = -1.0, ["searchable"] = 0, ["special_find_note"] = ""}
    end
    Note("Item=" .. sAppraiseItem)
    if (sItemDBItems[sAppraiseItem]["description"] == "") then
      sItemDBItems[sAppraiseItem]["description"] = sAppraiseDescription
      Note("Describe [DB Updated]=" .. sAppraiseDescription)
      assert(dbMap:execute("UPDATE items SET description='" .. EscapeSQL(sAppraiseDescription) .. "' WHERE item_name='" .. EscapeSQL(sAppraiseItem) .. "'"))
    end
    if (sItemDBItems[sAppraiseItem]["appraise_text"] == "") then
      sItemDBItems[sAppraiseItem]["appraise_text"] = sAppraiseData
      Note("Appraise [DB Updated]=" .. sAppraiseData)
      assert(dbMap:execute("UPDATE items SET appraise_text='" .. EscapeSQL(sAppraiseData) .. "' WHERE item_name='" .. EscapeSQL(sAppraiseItem) .. "'"))
    end
  end
end

-- Log shop inventory for restaurant
function ShopRestaurantInventory (sName, sLine, wildcards, styles)
  if (bCreatingRooms == true) then
    if (bLastRoomFailGMCP == false) then
      local sThisItemName = FilterItemName(wildcards[1])
      if (sThisItemName ~= "" and sThisItemName ~= " ") then
        -- Trim spaces from price
        local sThisItemPrice = wildcards[2]:match'^%s*(.*%S)' or ''
        if (sItemDBItems[sThisItemName] == nil) then
          sItemDBItems[sThisItemName] = {["description"] = "", ["appraise_text"] = "", ["weight"] = "", ["dollar_value"] = -1.0, ["searchable"] = 0, ["special_find_note"] = "", ["stock_code"] = ""}
          QuowItemUpdateOrCreate(sThisItemName)
          Tell(" [New] [DB Updated]")
        end
        if (sItemDBShopItems[sCurrentRoomID] == nil) then
          sItemDBShopItems[sCurrentRoomID] = {}
        end
        if (sItemDBShopItems[sCurrentRoomID][sThisItemName] == nil or sItemDBShopItems[sCurrentRoomID][sThisItemName] ~= sThisItemPrice) then
          -- DB Update if needed
          local sSaveSQL = "INSERT OR REPLACE INTO shop_items (room_id, item_name, sale_price) VALUES " ..
            "('" .. sCurrentRoomID .. "', '" .. EscapeSQL(sThisItemName) .. "', '" .. EscapeSQL(sThisItemPrice) .. "')"
          assert(dbMap:execute(sSaveSQL))
        end
        sItemDBShopItems[sCurrentRoomID][sThisItemName] = sThisItemPrice
      end
    end
  end
end

-- Log shop inventory to this room ID
function ShopStandardInventory (sName, sLine, wildcards, styles)
  if (bCreatingRooms == true) then
    if (bLastRoomFailGMCP == false) then
      local sThisStockCode = wildcards[1]
      local sThisItemName = FilterItemName(wildcards[2])
      local sThisItemPrice = wildcards[3]

      -- Wiper
      if (sItemDBItems[sThisItemName] ~= nil) then
        --sItemDBItems[sThisItemName]["description"] = ""
        --sItemDBItems[sThisItemName]["appraise_text"] = ""
        --sItemDBItems[sThisItemName]["weight"] = ""
      end

      if (sItemDBItems[sThisItemName] == nil) then
        sItemDBItems[sThisItemName] = {["description"] = "", ["appraise_text"] = "", ["weight"] = "", ["dollar_value"] = -1.0, ["searchable"] = 0, ["special_find_note"] = "", ["stock_code"] = sThisStockCode}
        QuowItemUpdateOrCreate(sThisItemName)
        Tell(" [New] [DB Updated]")
      else
        if (sItemDBItems[sThisItemName]["description"] == "" or sItemDBItems[sThisItemName]["appraise_text"] == "") then
          Tell(" [Desc/App missing]")
        end
        if (sItemDBItems[sThisItemName]["weight"] == "") then
          Tell(" [Weight missing]")
        end
      end
      sItemDBItems[sThisItemName]["stock_code"] = sThisStockCode
      if (sItemDBShopItems[sCurrentRoomID] == nil) then
        sItemDBShopItems[sCurrentRoomID] = {}
      end
      if (sItemDBShopItems[sCurrentRoomID][sThisItemName] == nil or sItemDBShopItems[sCurrentRoomID][sThisItemName] ~= sThisItemPrice) then
        -- DB Update if needed
        local sSaveSQL = "INSERT OR REPLACE INTO shop_items (room_id, item_name, sale_price) VALUES " ..
          "('" .. sCurrentRoomID .. "', '" .. EscapeSQL(sThisItemName) .. "', '" .. EscapeSQL(sThisItemPrice) .. "')"
        assert(dbMap:execute(sSaveSQL))
      end
      sItemDBShopItems[sCurrentRoomID][sThisItemName] = sThisItemPrice
    end
  end
end


-- Quow's custom path finding/Routefinder
function QuowRoutefind(sStartID, sDestinationID, iDestMap, iDestX, iDestY, bExactRoom)
  if (sStartID == sDestinationID or sStartID == nil or sDestinationID == nil or sStartID == "" or sDestinationID == "") then
    Note("Cannot find a valid route, start or end rooms may be invalid or the same map location.")
    return "", "", 0
  end
  -- Do we want the EXACT correct room?  If yes, set to true
  if (bExactRoom == nil) then
    bExactRoom = true
  end
  local sDoRoom, bEverDone, sIDToRoomNum, iGotHereFrom, sLinkedTo = {}, {}, {}, {}, {}
  sDoRoom[1], sIDToRoomNum[sStartID], bEverDone[sStartID] = sStartID, 1, true
  local iNextRoom, iTotalRooms, iSearchDepth, bDone, iFinalRoom, iPreviousTotal = 1, 1, 0, false, 0, 0
  -- "Infinite" loop
  while (bDone == false) do
    -- Loop through all the rooms we have yet to do
    iPreviousTotal = iTotalRooms
    for iN = iNextRoom, iPreviousTotal do
      -- Loop through all the exits from this room
      for sKey, sExitData in pairs(sQuowExitsByID[sDoRoom[iN]]) do
        -- Make sure we aren't looping back around on ourselves, and that we haven't already finished
        if (sKey ~= sStartID and bEverDone[sKey] == nil and iFinalRoom == 0) then
          iTotalRooms = iTotalRooms + 1
          -- Add destination of THIS room, to the "to-be-processed-next" list
          sDoRoom[iTotalRooms] = sKey
          -- Flag this room so we never come here again
          bEverDone[sKey] = true
          -- Record ID to room-num
          sIDToRoomNum[sKey] = iTotalRooms
          -- Record back-tracking data
          iGotHereFrom[iTotalRooms] = {sIDToRoomNum[sDoRoom[iN]], sExitData}
          -- See if we made it yet
          if (sDoRoom[iN] == sDestinationID) then
            bDone = true
            iFinalRoom = iN
          elseif (sKey == sDestinationID) then
            -- Double check
            bDone = true
            iFinalRoom = iTotalRooms
          elseif (bExactRoom == false and sQuowLocationsByRoomID[sDoRoom[iN]][1] == iDestMap and sQuowLocationsByRoomID[sDoRoom[iN]][2] == iDestX and sQuowLocationsByRoomID[sDoRoom[iN]][3] == iDestY) then
            -- Maybe we reached the co-ordinates instead - eg a house with multiple rooms in one pixels -- only stop here if we didn't START here
            if (sQuowLocationsByRoomID[sStartID][1] ~= iDestMap or sQuowLocationsByRoomID[sStartID][2] ~= iDestX or sQuowLocationsByRoomID[sStartID][3] ~= iDestY) then
              bDone = true
              iFinalRoom = iN
            end
          end
        end -- Not back to beginning
      end -- Loop through exit rooms
    end -- Loop through "to-do"
    iNextRoom = iPreviousTotal + 1
    if (iNextRoom > iTotalRooms) then
      Note("Failed to find a route, no solid path all the way to the destination!")
      bDone = true
    end
    iSearchDepth = iSearchDepth + 1
    if (iSearchDepth > 500) then
      Note("Route finding to target room failed, search depth exceeded the 500 limit")
      bDone = true
      iFinalRoom = 0
      break
    end
  end
  -- Did we actually find a room?
  if (iFinalRoom ~= 0) then
    sPath = {}
    bDone = false
    local iCurRoom = iFinalRoom
    while (bDone == false) do
      --Note("iCurRoom=" .. tostring(iCurRoom) .. "... GotHereFrom:" .. tostring(iGotHereFrom[iCurRoom][1]) .. " with " .. tostring(iGotHereFrom[iCurRoom][2]))
      table.insert(sPath, iGotHereFrom[iCurRoom][2])
      iCurRoom = iGotHereFrom[iCurRoom][1]
      if (iCurRoom == 1) then
        bDone = true
      end
    end
    local sRealPath = ""
    for iN = #sPath, 1, -1 do
      if (sRealPath ~= "") then
        sRealPath = sRealPath .. ";"
      end
      sRealPath = sRealPath .. sPath[iN]
    end
    return sRealPath, sDoRoom[iFinalRoom], #sPath
  end
  -- Didn't find a route, return blanks
  return "", "", 0
end

function RepositionComms()
  WindowPosition(winComms, iEnlargedCommsData["LEFT"], iEnlargedCommsData["TOP"], 0, 2)
end

-- Double-clicking on the comms window, toggle growth
function QuowCommsDoubleclick()
  if (iEnlargedCommsData["ENABLED"] == true) then
    iEnlargedCommsData["ENABLED"] = false
    WINDATA[winComms]["WIDTH"] = iEnlargedCommsData["WIDTH"]
    WINDATA[winComms]["HEIGHT"] = iEnlargedCommsData["HEIGHT"]
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    bCommsNeedsButtons = true
    RedrawCommsWindow()
    --WindowPosition(winComms, iEnlargedCommsData["LEFT"], iEnlargedCommsData["TOP"], 0, 2)
    local iErr = AddTimer("timer_reposition", 0, 0, 0.1, "", 1061, "RepositionComms")
    if (iErr ~= 0) then
      WindowPosition(winComms, iEnlargedCommsData["LEFT"], iEnlargedCommsData["TOP"], 0, 2)
    end
  else
    iEnlargedCommsData["ENABLED"] = true
    iEnlargedCommsData["WIDTH"] = WINDATA[winComms]["WIDTH"]
    iEnlargedCommsData["HEIGHT"] = WINDATA[winComms]["HEIGHT"]
    iEnlargedCommsData["LEFT"] = WindowInfo(winComms, 10)
    iEnlargedCommsData["TOP"] = WindowInfo(winComms, 11)
    WINDATA[winComms]["WIDTH"] = GetInfo(274) - GetInfo(272)
    WINDATA[winComms]["HEIGHT"] = math.floor((GetInfo(275) - GetInfo(273)) * 0.8)
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], "Comms")
    bCommsNeedsButtons = true
    ReorderWindows(winComms)
    RedrawCommsWindow()
    WindowPosition(winComms, GetInfo(272), GetInfo(273), 0, 2)  
    ColourTell(sCOLOUR.orange, "", "Your communications window has been enlarged, double-click or '")
    Hyperlink ("minimap chat", "minimap chat", "", sCOLOUR.cyan, "", 0)
    ColourNote(sCOLOUR.orange, "", "' to reset.")
  end
  return 0
end

-- Mousewheel on chat window
function HandleMouseWheelComms(flags, hotspot_id)
  if (bit.band(flags, 0x100) ~= 0) then
    -- Mouse wheel down/scroll down, page down
    if (iCommLineBottomRender < iCommsMessagesCurrentlyShown) then
      iCommLineBottomRender = iCommLineBottomRender + 1
      RedrawCommsWindow()
    end
  else
    -- Mouse wheel up/scroll up, page up
    if (iCommLineBottomRender > iCommLinesRendered) then
      iCommLineBottomRender = iCommLineBottomRender - 1
      RedrawCommsWindow()
    end
  end -- Scrolling down, or up?
end -- Mouse wheel function on comms window


-- Mousewheel on graphical minimap
function HandleMouseWheelMinimap(flags, hotspot_id)
  -- We only want to zoom if holding the control key down, so skip out if no control key
  if (bit.band(flags, miniwin.hotspot_got_control) == 0) then
    return 0
  end
  if (bit.band(flags, 0x100) ~= 0) then
    -- Mouse wheel down/scroll down, zoom out (subtraction)
    iUseZoom = iUseZoom - 1
  else
    -- Mouse wheel up/scroll up, zoom in (addition)
    iUseZoom = iUseZoom + 1
  end
  if (iUseZoom < 1) then
    iUseZoom = 1
  end
  if (iUseZoom > 7) then
    iUseZoom = 7
  end
  WindowResize(winMapRender, MINIMAP_WIDTH*iZoomData[iUseZoom][2], MINIMAP_HEIGHT*iZoomData[iUseZoom][2], iCOLOUR.black)
  if (iUseZoom == 3) then
    sMapWinTitle = sQuowMapfiles[iUseMap][2]
  else
    sMapWinTitle = sQuowMapfiles[iUseMap][2] .. " @ " .. iZoomData[iUseZoom][4]
  end
  iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
  RetitleWindow(winMinimap, sMapWinTitle)
  RedrawMap()
  --ColourNote(sCOLOUR.orange, "", "Minimap zoom level changed: " .. iZoomData[iUseZoom][4] .. " [option " .. iUseZoom .. "]")
  return 0
end

-- Convert mouseclicks on the minimap to a location to shift the map around
iCatchupX = 0
iCatchupY = 0
--Mousemapping
function QuowMapMouse(flags, hotspot_id)
  if (hotspot_id == "hsMapClick") then
    if (bit.band(flags, miniwin.hotspot_got_alt) ~= 0) then
      -- Alt-click cycles through all the maps, left click one way, right click the other
      local bGoalReached = false
      if (bit.band(flags, miniwin.hotspot_got_lh_mouse) ~= 0) then
        while (bGoalReached == false) do
          iCurMap = iCurMap + 1
          if (sQuowMapfiles[iCurMap] ~= nil) then
            bGoalReached = true
          end
          if (iCurMap > 99) then
            iCurMap = 1
            bGoalReached = true
          end
        end
      else
        while (bGoalReached == false) do
          iCurMap = iCurMap - 1
          if (sQuowMapfiles[iCurMap] ~= nil) then
            bGoalReached = true
          end
          if (iCurMap < 1) then
            iCurMap = 99
            bGoalReached = true
          end
        end
      end
      sCurrentMap = sQuowMapfiles[iCurMap][1]
      iMyX = sQuowMapfiles[iCurMap][5]
      iMyY = sQuowMapfiles[iCurMap][6]
      --Note("Changing map to:  " .. sCurrentMap)
      RedrawMap()
      Repaint()
    --or bit.band(flags, miniwin.hotspot_got_shift) ~= 0

    elseif (bit.band(flags, miniwin.hotspot_got_rh_mouse) ~= 0) then
      -- Right click bring up menu - build the custom menu here
      -- ! : return numeric result (only in first position of entire string)
      -- - : separator line
      -- ^ : grayed-out item
      -- + : checked (ticked) item
      -- > : start of nested menu (rest of line is nested menu title)
      -- < : end of nested menu (rest of line is ignored)

      local sMenuString = "^Quow's Cow Bar:|-|"

      if (WINDATA[winMinimap]["LOCKED"] == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Lock Minimap Window Position|"
      sMenuString = sMenuString .. "Hide Minimap Window|"

      -- Options section
      sMenuString = sMenuString .. ">Minimap Options...|"

      -- Zooming
      sMenuString = sMenuString .. ">Zoom Level...|"
      for iN = 1, #iZoomData do
        if (iUseZoom == iN) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Zoom Level: " .. iZoomData[iN][4] .. "|"
      end
      sMenuString = sMenuString .. "<|"

      -- Brightness
      sMenuString = sMenuString .. ">Brightness...|"
      if (iMinimapBrightness == 100) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Brightness: 100%|"
      if (iMinimapBrightness == 90) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Brightness: 90%|"
      if (iMinimapBrightness == 80) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Brightness: 80%|"
      if (iMinimapBrightness == 70) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Brightness: 70%|"
      if (iMinimapBrightness == 60) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Brightness: 60%|"
      if (iMinimapBrightness == 50) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Brightness: 50%|"
      sMenuString = sMenuString .. "<|"

      -- Colour of centre-dot
      sMenuString = sMenuString .. "Colour Select Map Centre-Dot|"

      -- Crosshair or dot
      if (bCentreCrosshair == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Show Map Centre Crosshair|"      

      -- Disc date
      if (bShowDiscDate == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Show Discworld Date on Map|"
      if (bDrawOrbs == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Display spell orbs in library|"
      if (bTerrainsTracking == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Attempt Terrains Tracking|"
      if (bHideOnTerrain == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Auto-hide map in terrains|"
      if (bAutoShowHideAscii == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Auto-Hide-Show Ascii map with terrains|"
      if (bAsciiMapOmitted == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Omit Ascii map from MUD output|"
      if (bShowGhost == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Show Ghost when running ahead|"
      if (bPredictiveMoves == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Allow map to move through unsupported exits|"
      if (bReBroadcastData == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Re-Broadcast GMCP Data|"
      if (bDrawSkeletonMode == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Skeleton Map Mode|"
      sMenuString = sMenuString .. "<|"

      -- Windows section
      sMenuString = sMenuString .. ">Extra Windows...|"
      if (WINDATA[winBars]["SHOW"] == true) then
        sMenuString = sMenuString .. "+"
      end
      if (MODULES["vitals"] == false) then
        sMenuString = sMenuString .. "^[disabled] "
      end
      sMenuString = sMenuString .. "Show Character Vitals Window|"
      if (WINDATA[winXP]["SHOW"] == true) then
        sMenuString = sMenuString .. "+"
      end
      if (MODULES["xp"] == false) then
        sMenuString = sMenuString .. "^[disabled] "
      end
      sMenuString = sMenuString .. "Show XP Window|"
      if (WINDATA[winMDT]["SHOW"] == true) then
        sMenuString = sMenuString .. "+"
      end
      if (MODULES["mdt"] == false) then
        sMenuString = sMenuString .. "^[disabled] "
      end
      sMenuString = sMenuString .. "Show Written-Map Window|"
      if (WINDATA[winAscii]["SHOW"] == true) then
        sMenuString = sMenuString .. "+"
      end
      if (MODULES["ascii"] == false) then
        sMenuString = sMenuString .. "^[disabled] "
      end
      sMenuString = sMenuString .. "Show Ascii-Map Window|"
      if (WINDATA[winStats]["SHOW"] == true) then
        sMenuString = sMenuString .. "+"
      end
      if (MODULES["stats"] == false) then
        sMenuString = sMenuString .. "^[disabled] "
      end
      sMenuString = sMenuString .. "Show Combat Stats Window|"
      if (WINDATA[winShields]["SHOW"] == true) then
        sMenuString = sMenuString .. "+"
      end
      if (MODULES["shields"] == false) then
        sMenuString = sMenuString .. "^[disabled] "
      end
      sMenuString = sMenuString .. "Show Shields Window|"
      if (WINDATA[winHotspots]["SHOW"] == true) then
        sMenuString = sMenuString .. "+"
      end
      if (MODULES["hotspots"] == false) then
        sMenuString = sMenuString .. "^[disabled] "
      end
      sMenuString = sMenuString .. "Show Hotspots Window|"
      if (WINDATA[winComms]["SHOW"] == true) then
        sMenuString = sMenuString .. "+"
      end
      if (MODULES["comms"] == false) then
        sMenuString = sMenuString .. "^[disabled] "
      end
      sMenuString = sMenuString .. "Show Comms Window|"
      sMenuString = sMenuString .. "<|"

      -- Disable Modules
      sMenuString = sMenuString .. ">Disable/Enable Modules...|"

      if (MODULES["stats"] == true) then
        sMenuString = sMenuString .. "+Disable Combat Stats Module|"
      else
        sMenuString = sMenuString .. "Enable Combat Stats Module|"
      end
      if (MODULES["mdt"] == true) then
        sMenuString = sMenuString .. "+Disable Written-Map Module|"
      else
        sMenuString = sMenuString .. "Enable Written-Map Module|"
      end
      if (MODULES["ascii"] == true) then
        sMenuString = sMenuString .. "+Disable Ascii-Map Module|"
      else
        sMenuString = sMenuString .. "Enable Ascii-Map Module|"
      end
      if (MODULES["comms"] == true) then
        sMenuString = sMenuString .. "+Disable Comms Module|"
      else
        sMenuString = sMenuString .. "Enable Comms Module|"
      end
      if (MODULES["hotspots"] == true) then
        sMenuString = sMenuString .. "+Disable Hotspots Module|"
      else
        sMenuString = sMenuString .. "Enable Hotspots Module|"
      end
      if (MODULES["shields"] == true) then
        sMenuString = sMenuString .. "+Disable Shields Module|"
      else
        sMenuString = sMenuString .. "Enable Shields Module|"
      end
      if (MODULES["xp"] == true) then
        sMenuString = sMenuString .. "+Disable XP Module|"
      else
        sMenuString = sMenuString .. "Enable XP Module|"
      end
      if (MODULES["vitals"] == true) then
        sMenuString = sMenuString .. "+Disable Character Vitals Module|"
      else
        sMenuString = sMenuString .. "Enable Character Vitals Module|"
      end
      sMenuString = sMenuString .. "<|-|"
      -- Screen margins
      sMenuString = sMenuString .. ">Screen Margins...|"
      if (bLockMargins == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Lock Screen Margins|-|"
      if (SCREENMARGINS["left"][1] == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Left Edge Margin|"
      if (SCREENMARGINS["top"][1] == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Top Edge Margin|"
      if (SCREENMARGINS["right"][1] == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Right Edge Margin|"
      if (SCREENMARGINS["bottom"][1] == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Bottom Edge Margin|"
      sMenuString = sMenuString .. "<|"

      -- Instant layouts
      sMenuString = sMenuString .. ">Instant Layouts...|"
      sMenuString = sMenuString .. "^Auto-Configure Full Layout:|-|"
      if (iThemeLayoutLocked == 11) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Simple Cow|-|"
      if (iThemeLayoutLocked == 2) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Cow-Bar Classic Left|"
      if (iThemeLayoutLocked == 3) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Cow-Bar Classic Right|"
      if (iThemeLayoutLocked == 1) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Cow-Bar Classic Top|"
      if (iThemeLayoutLocked == 4) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Cow-Bar Classic Bottom|"
      sMenuString = sMenuString .. "-|"
      if (iThemeLayoutLocked == 8) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Semi-Skimmed Top|"
      if (iThemeLayoutLocked == 9) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Semi-Skimmed Bottom|"
      sMenuString = sMenuString .. "-|"
      if (iThemeLayoutLocked == 5) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Micro-Cow Miniatures|"
      if (iThemeLayoutLocked == 7) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Marginalised Cows|"
      if (iThemeLayoutLocked == 6) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Big-Cows Big-Windows|"
      sMenuString = sMenuString .. "-|"
      if (iThemeLayoutLocked == 12) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Side of Beef Left|"
      if (iThemeLayoutLocked == 13) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Side of Beef Right|"
      sMenuString = sMenuString .. "-|"
      if (iThemeLayoutLocked == 14) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Minimoolist|"
      sMenuString = sMenuString .. "-|"
      sMenuString = sMenuString .. "^Custom Layout|"
      if (iThemeLayoutLocked == 10) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Load Custom Cows Layout|"
      sMenuString = sMenuString .. "-|"
      sMenuString = sMenuString .. "Save Custom Cows Layout|"
      sMenuString = sMenuString .. "-|"
      sMenuString = sMenuString .. "^Import/Export Layout|"
      sMenuString = sMenuString .. "Import Scaled Layout|"
      sMenuString = sMenuString .. "Export Scaled Layout|"

      sMenuString = sMenuString .. "<|"

      -- Colour mode/theme
      sMenuString = sMenuString .. ">Colour Theme...|"
      sMenuString = sMenuString .. "^Auto-Configure Colour Theme:|-|"
      if (sTheme == "default") then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Colour Theme - Basic Cow|"
      if (sTheme == "darkmode") then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Colour Theme - Black Patched|"
      if (sTheme == "greymode") then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Colour Theme - Grey Moo|"
      if (sTheme == "greenmode") then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Colour Theme - Green Pasture|"
      if (sTheme == "bluemode") then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Colour Theme - Winter Moo|"
      if (sTheme == "redmode") then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Colour Theme - Bull Red|"
      if (sTheme == "lightmode") then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Colour Theme - White Patched|"
      -- Individual Colours
      sMenuString = sMenuString .. "-|Customise Current Theme|-|"
      sMenuString = sMenuString .. "Reset Current Theme Colours|-|" 
      sMenuString = sMenuString .. "Colour Theme - Export|"
      sMenuString = sMenuString .. "Colour Theme - Import|-|"
      if (iMushclientVersion >= 5.07) then
        sMenuString = sMenuString .. "MUSHclient Frame - Default Colour|"
        sMenuString = sMenuString .. "MUSHclient Frame - Pick Colour|-|"
      else
        sMenuString = sMenuString .. "^Main Window Frame - Needs v5.07 MUSH|-|"
      end
      sMenuString = sMenuString .. "Background - Clear Image|"
      sMenuString = sMenuString .. "Background - Load Image|-|"

      sMenuString = sMenuString .. ">Date Font: " .. objWindowFonts[winMinimap]["body"] .. " (" .. tostring(objWindowFonts[winMinimap]["size"]) .. ")...|"
      sMenuString = sMenuString .. "^Change Discworld-Date font:|-|"
      sMenuString = sMenuString .. "Font: Pick Font-Type for Date|"
      sMenuString = sMenuString .. "Font: Pick Font-Size for Date|"
      sMenuString = sMenuString .. "Font: Restore Default for Date|<|-|"

      sMenuString = sMenuString .. "<|-|"

      -- Auto-wrapper
      if (bRapMyWrap == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Attempt Auto-Wrap Output|-|"

      -- Switch to map section
      sMenuString = sMenuString .. "Switch To Map|-|"

      -- Basic functionality
      if (iMyX == iOldMX and iMyY == iOldMY and iCurMap == iOldMap) then
        sMenuString = sMenuString .. "^"
      end
      sMenuString = sMenuString .. "Reset Map Position|"
      sMenuString = sMenuString .. "List Bookmarked Rooms|"
      sMenuString = sMenuString .. "-|"

      -- Room-click functionatliy
      if (sClickedRoomID == "") then
        sMenuString = sMenuString .. "^Left-click a valid room first:|"
        sMenuString = sMenuString .. "^Add Clicked Room To Bookmarks|"
        sMenuString = sMenuString .. "^Show Clicked Room Info|-|"
        sMenuString = sMenuString .. "^Speedwalk To Clicked Room|"
      else
        if (sQuowUserBookmarks[sClickedRoomID] ~= nil and sQuowUserBookmarks[sClickedRoomID] ~= "") then
          sMenuString = sMenuString .. "^" .. sQuowUserBookmarks[sClickedRoomID] .. ":|"
        else
          sMenuString = sMenuString .. "^" .. sQuowLocationsByRoomID[sClickedRoomID][4] .. ":|"
        end
        if (sQuowUserBookmarks[sClickedRoomID] == nil) then
          sMenuString = sMenuString .. "Add Clicked Room To Bookmarks|"
        else
          sMenuString = sMenuString .. "Remove Clicked Room From Bookmarks|"
        end
        sMenuString = sMenuString .. "Show Clicked Room Info|"
        if (sItemDBShopItems[sClickedRoomID] ~= nil) then
          sMenuString = sMenuString .. "-|Show Shop Exclusives|"
        end
        sMenuString = sMenuString .. "-|Speedwalk To Clicked Room|"
      end

      sRMBResult = WindowMenu (winMinimap, WindowInfo(winMinimap, 14), WindowInfo(winMinimap, 15), sMenuString)

      if (sRMBResult ~= "") then
        if (sRMBResult == "Reset Map Position") then
          QuowOldSnap()
        -- Lock minimap window Position
        elseif (sRMBResult == "Lock Minimap Window Position") then
          if (WINDATA[winMinimap]["LOCKED"] == true) then
            WINDATA[winMinimap]["LOCKED"] = false
          else
            WINDATA[winMinimap]["LOCKED"] = true
          end
        elseif (sRMBResult == "Hide Minimap Window") then
          ColourNote(sCOLOUR.orange, "", "Hiding the main graphical minimap window.  Note this window is the master window and should not be hidden for most users.")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowWindow(" .. winMinimap .. ")", "Click here to show it again", "", sCOLOUR.cyan, "", 0)
          ColourNote(sCOLOUR.orange, "", " or use '", sCOLOUR.cyan, "", "minimap show", sCOLOUR.orange, "", "' command.")
          ColourNote(sCOLOUR.silver, "", "Note:  MANY options and features of the entire Cow Bar are controlled through the minimap window menu!")
          WindowShow(winMinimap, false)
          WINDATA[winMinimap]["SHOW"] = false
          iThemeLayoutLocked = 0
          bMinimapHidden = true
          bMinimapTempHidden = false
        -- Pre-configured layout themes
        elseif (sRMBResult == "Simple Cow") then
          QuowLayoutTheme(11)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Cow-Bar Classic Top") then
          QuowLayoutTheme(1)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Cow-Bar Classic Left") then
          QuowLayoutTheme(2)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Cow-Bar Classic Right") then
          QuowLayoutTheme(3)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Cow-Bar Classic Bottom") then
          QuowLayoutTheme(4)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Micro-Cow Miniatures") then
          QuowLayoutTheme(5)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Big-Cows Big-Windows") then
          QuowLayoutTheme(6)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Side of Beef Left") then
          QuowLayoutTheme(12)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Side of Beef Right") then
          QuowLayoutTheme(13)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Minimoolist") then
          QuowLayoutTheme(14)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Marginalised Cows") then
          QuowLayoutTheme(7)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Semi-Skimmed Top") then
          QuowLayoutTheme(8)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Semi-Skimmed Bottom") then
          QuowLayoutTheme(9)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Load Custom Cows Layout") then
          QuowLayoutTheme(10)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: Custom Cows")
        elseif (sRMBResult == "Save Custom Cows Layout") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "QuowSaveCustomCows", "", "")
          ColourNote(sCOLOUR.orange, "", "Your current exact window positions and sizes have been saved to the Custom Cows layout.")

        -- Import scaled output
        elseif (sRMBResult == "Import Scaled Layout") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "QuowLayoutImport")
        -- Export scaled output
        elseif (sRMBResult == "Export Scaled Layout") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "QuowLayoutExport")

        elseif (sRMBResult == "List Bookmarked Rooms") then
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar Location Bookmarks:")
          local iAnyBookmarks = QuowBookmarkList("", 0)
          if (iAnyBookmarks == 0) then
            Note("You have no bookmarked rooms.  You can create these by left-clicking a room on the map, and then selecting Bookmark in the right-click menu.")
          end
        elseif (sRMBResult == "Auto-hide map in terrains") then
          if (bHideOnTerrain == true) then
            bHideOnTerrain = false
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WON'T hide the graphical minimap window whenever you enter unknown/random terrain rooms.")
          else
            bHideOnTerrain = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WILL hide the graphical minimap window whenever you enter unknown/random terrain rooms.")
          end
        elseif (sRMBResult == "Re-Broadcast GMCP Data") then
          if (bReBroadcastData == true) then
            bReBroadcastData = false
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WON'T re-broadcast data to other plugins - third party plugins may rely on this data.")
          else
            bReBroadcastData = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WILL re-broadcast data to other plugins - third party plugins may rely on this data.")
          end

        elseif (sRMBResult == "Attempt Terrains Tracking") then
          if (bTerrainsTracking == true) then
            bTerrainsTracking = false
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WON'T try to 'track' your skills-based-location as you wander aimlessly through the terrains.")
          else
            bTerrainsTracking = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WILL try to 'track' your skills-based-location as you wander aimlessly through the terrains.")
          end

        elseif (sRMBResult == "Auto-Hide-Show Ascii map with terrains") then
          if (bAutoShowHideAscii == true) then
            bAutoShowHideAscii = false
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WON'T try to automatically switch your Ascii map window on and off depending on where you are.")
          else
            bAutoShowHideAscii = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar will now hide the Ascii map window when you are in database-recognised locations, and show it when in unknown places (eg terrains).")
          end
        elseif (sRMBResult == "Omit Ascii map from MUD output") then
          if (bAsciiMapOmitted == true) then
            bAsciiMapOmitted = false
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WON'T try to omit the Discworld Ascii map from your main mud output area.")
          else
            bAsciiMapOmitted = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WILL try to omit the Discworld Ascii map from your main mud output area.")
          end
        elseif (sRMBResult == "Draw spell orbs in library") then
          if (bDrawOrbs == true) then
            bDrawOrbs = false
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WON'T try to render a small image on the Library map when escaped spell orbs are seen.")
          else
            bDrawOrbs = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WILL try to render a small image on the Library map when escaped spell orbs are seen.")
          end
        elseif (sRMBResult == "Show Ghost when running ahead") then
          if (bShowGhost == true) then
            bShowGhost = false
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WON'T show a 'ghost' of your current/live location chasing you as you spam-move ahead.")
          else
            bShowGhost = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WILL show a 'ghost' of your current/live location chasing you as you spam-move ahead.")
          end

        elseif (sRMBResult == "Zoom Level: 50%") then
          iUseZoom = 1
          WindowResize(winMapRender, MINIMAP_WIDTH*iZoomData[iUseZoom][2], MINIMAP_HEIGHT*iZoomData[iUseZoom][2], iCOLOUR.black)
          sMapWinTitle = sQuowMapfiles[iUseMap][2] .. " @ " .. iZoomData[iUseZoom][4]
          iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
          RetitleWindow(winMinimap, sMapWinTitle)
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Zoom Level: 75%") then
          iUseZoom = 2
          WindowResize(winMapRender, MINIMAP_WIDTH*iZoomData[iUseZoom][2], MINIMAP_HEIGHT*iZoomData[iUseZoom][2], iCOLOUR.black)
          sMapWinTitle = sQuowMapfiles[iUseMap][2] .. " @ " .. iZoomData[iUseZoom][4]
          iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
          RetitleWindow(winMinimap, sMapWinTitle)
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Zoom Level: 100%") then
          iUseZoom = 3
          WindowResize(winMapRender, MINIMAP_WIDTH*iZoomData[iUseZoom][2], MINIMAP_HEIGHT*iZoomData[iUseZoom][2], iCOLOUR.black)
          sMapWinTitle = sQuowMapfiles[iUseMap][2]
          iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
          RetitleWindow(winMinimap, sMapWinTitle)
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Zoom Level: 150%") then
          iUseZoom = 4
          WindowResize(winMapRender, MINIMAP_WIDTH*iZoomData[iUseZoom][2], MINIMAP_HEIGHT*iZoomData[iUseZoom][2], iCOLOUR.black)
          sMapWinTitle = sQuowMapfiles[iUseMap][2] .. " @ " .. iZoomData[iUseZoom][4]
          iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
          RetitleWindow(winMinimap, sMapWinTitle)
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Zoom Level: 200%") then
          iUseZoom = 5
          WindowResize(winMapRender, MINIMAP_WIDTH*iZoomData[iUseZoom][2], MINIMAP_HEIGHT*iZoomData[iUseZoom][2], iCOLOUR.black)
          sMapWinTitle = sQuowMapfiles[iUseMap][2] .. " @ " .. iZoomData[iUseZoom][4]
          iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
          RetitleWindow(winMinimap, sMapWinTitle)
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Zoom Level: 300%") then
          iUseZoom = 6
          WindowResize(winMapRender, MINIMAP_WIDTH*iZoomData[iUseZoom][2], MINIMAP_HEIGHT*iZoomData[iUseZoom][2], iCOLOUR.black)
          sMapWinTitle = sQuowMapfiles[iUseMap][2] .. " @ " .. iZoomData[iUseZoom][4]
          iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
          RetitleWindow(winMinimap, sMapWinTitle)
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Zoom Level: 400%") then
          iUseZoom = 7
          WindowResize(winMapRender, MINIMAP_WIDTH*iZoomData[iUseZoom][2], MINIMAP_HEIGHT*iZoomData[iUseZoom][2], iCOLOUR.black)
          sMapWinTitle = sQuowMapfiles[iUseMap][2] .. " @ " .. iZoomData[iUseZoom][4]
          iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
          RetitleWindow(winMinimap, sMapWinTitle)
          RedrawMap()
          Redraw()

        elseif (sRMBResult == "Brightness: 100%") then
          iMinimapBrightness = 100
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Brightness: 90%") then
          iMinimapBrightness = 90
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Brightness: 80%") then
          iMinimapBrightness = 80
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Brightness: 70%") then
          iMinimapBrightness = 70
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Brightness: 60%") then
          iMinimapBrightness = 60
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Brightness: 50%") then
          iMinimapBrightness = 50
          RedrawMap()
          Redraw()
        elseif (sRMBResult == "Show Map Centre Crosshair") then
          if (bCentreCrosshair == true) then
            bCentreCrosshair = false
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WON'T show a crosshair over your current location.")
          else
            bCentreCrosshair = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WILL show a crosshair over your current location.")
          end
          RedrawMap()
        elseif (sRMBResult == "Colour Select Map Centre-Dot") then
          FetchMapColour()
        elseif (sRMBResult == "Show Discworld Date on Map") then
          if (bShowDiscDate == true) then
            bShowDiscDate = false
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WON'T show the Discworld date below your map.")
          else
            bShowDiscDate = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WILL show the Discworld date below your map.")
          end  
          RedrawMap()       
        elseif (sRMBResult == "Skeleton Map Mode") then
          if (bDrawSkeletonMode == true) then
            bDrawSkeletonMode = false
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar now back to normal graphical map mode.")
          else
            bDrawSkeletonMode = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar will now show a skeletal image representing the internal map database and room-links.")
          end         
        elseif (sRMBResult == "Allow map to move through unsupported exits") then
          if (bPredictiveMoves == true) then
            bPredictiveMoves = false
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar will try to lock itself to only follow through room exits/locations in the database.")
          else
            bPredictiveMoves = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar can now 'move' into un-supported rooms and exits that are not part of the visual maps/databases (not recommended!).")
          end
        elseif (sRMBResult == "Show XP Window") then
          if (WINDATA[winXP]["SHOW"] == true) then
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowHideWindow", winXP)
          else
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowShowWindow", winXP)
          end   
        elseif (sRMBResult == "Show Character Vitals Window") then
          if (WINDATA[winBars]["SHOW"] == true) then
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowHideWindow", winBars)
          else
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowShowWindow", winBars)
          end     
        elseif (sRMBResult == "Show Written-Map Window") then
          if (WINDATA[winMDT]["SHOW"] == true) then
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowHideWindow", winMDT)
          else
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowShowWindow", winMDT)
          end
        elseif (sRMBResult == "Show Combat Stats Window") then
          if (WINDATA[winStats]["SHOW"] == true) then
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowHideWindow", winStats)
          else
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowShowWindow", winStats)
          end
        elseif (sRMBResult == "Show Shields Window") then
          if (WINDATA[winShields]["SHOW"] == true) then
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowHideWindow", winShields)
          else
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowShowWindow", winShields)
          end
        elseif (sRMBResult == "Show Comms Window") then
          if (WINDATA[winComms]["SHOW"] == true) then
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowHideWindow", winComms)
          else
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowShowWindow", winComms)
          end
        elseif (sRMBResult == "Show Ascii-Map Window") then
          if (WINDATA[winAscii]["SHOW"] == true) then
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowHideWindow", winAscii)
          else
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowShowWindow", winAscii)
          end
        elseif (sRMBResult == "Show Hotspots Window") then
          if (WINDATA[winHotspots]["SHOW"] == true) then
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowHideWindow", winHotspots)
          else
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowShowWindow", winHotspots)
          end

        -- ***** Disable or Enable Modules Fully *****
        elseif (sRMBResult == "Disable Character Vitals Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleDisable", "vitals")
        elseif (sRMBResult == "Enable Character Vitals Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleEnable", "vitals")
        elseif (sRMBResult == "Disable XP Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleDisable", "xp")
        elseif (sRMBResult == "Enable XP Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleEnable", "xp")
        elseif (sRMBResult == "Disable Written-Map Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleDisable", "mdt")
        elseif (sRMBResult == "Enable Written-Map Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleEnable", "mdt")
        elseif (sRMBResult == "Disable Ascii-Map Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleDisable", "ascii")
        elseif (sRMBResult == "Enable Ascii-Map Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleEnable", "ascii")
        elseif (sRMBResult == "Disable Hotspots Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleDisable", "hotspots")
        elseif (sRMBResult == "Enable Hotspots Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleEnable", "hotspots")
        elseif (sRMBResult == "Disable Combat Stats Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleDisable", "stats")
        elseif (sRMBResult == "Enable Combat Stats Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleEnable", "stats")
        elseif (sRMBResult == "Disable Shields Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleDisable", "shields")
        elseif (sRMBResult == "Enable Shields Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleEnable", "shields")
        elseif (sRMBResult == "Disable Comms Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleDisable", "comms")
        elseif (sRMBResult == "Enable Comms Module") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "ModuleEnable", "comms")

        elseif (sRMBResult == "Lock Screen Margins") then
          if (bLockMargins == true) then
            Note("Screen margins are unlocked, you can now click-drag to resize your screen areas.")
            bLockMargins = false
            WindowShow(winScreenMarginLeft, true)
            WindowShow(winScreenMarginTop, true)
            WindowShow(winScreenMarginRight, true)
            WindowShow(winScreenMarginBottom, true)
          else
            Note("Screen margins are now locked in place.")
            bLockMargins = true
            WindowShow(winScreenMarginLeft, false)
            WindowShow(winScreenMarginTop, false)
            WindowShow(winScreenMarginRight, false)
            WindowShow(winScreenMarginBottom, false)
          end
        elseif (sRMBResult == "Left Edge Margin") then
          if (SCREENMARGINS["left"][1] == true) then
            SCREENMARGINS["left"][1] = false
            WindowShow(winScreenMarginLeft, false)
          else
            SCREENMARGINS["left"][1] = true
            if (bLockMargins == false) then
              WindowShow(winScreenMarginLeft, true)
            end
          end
          RedoScreenMargins()
        elseif (sRMBResult == "Top Edge Margin") then
          if (SCREENMARGINS["top"][1] == true) then
            SCREENMARGINS["top"][1] = false
            WindowShow(winScreenMarginTop, false)
          else
            SCREENMARGINS["top"][1] = true
            if (bLockMargins == false) then
              WindowShow(winScreenMarginTop, true)
            end
          end
          RedoScreenMargins()
        elseif (sRMBResult == "Right Edge Margin") then
          if (SCREENMARGINS["right"][1] == true) then
            SCREENMARGINS["right"][1] = false
            WindowShow(winScreenMarginRight, false)
          else
            SCREENMARGINS["right"][1] = true
            if (bLockMargins == false) then
              WindowShow(winScreenMarginRight, true)
            end
          end
          RedoScreenMargins()
        elseif (sRMBResult == "Bottom Edge Margin") then
          if (SCREENMARGINS["bottom"][1] == true) then
            SCREENMARGINS["bottom"][1] = false
            WindowShow(winScreenMarginBottom, false)
          else
            SCREENMARGINS["bottom"][1] = true
            if (bLockMargins == false) then
              WindowShow(winScreenMarginBottom, true)
            end
          end
          RedoScreenMargins()
        elseif (sRMBResult == "Add Clicked Room To Bookmarks" and sClickedRoomID ~= "") then
          QuowCreateBookmark(sClickedRoomID)
        elseif (sRMBResult == "Remove Clicked Room From Bookmarks" and sClickedRoomID ~= "") then
          QuowDeleteBookmark(sClickedRoomID)
        elseif (sRMBResult == "Show Clicked Room Info" and sClickedRoomID ~= "") then
          QuowShowRoomInfo(sClickedRoomID)
        elseif (sRMBResult == "Show Shop Exclusives" and sItemDBShopItems[sClickedRoomID] ~= nil) then
          QuowShowRoomInfo(sClickedRoomID, true)
        elseif (sRMBResult == "Speedwalk To Clicked Room" and sClickedRoomID ~= "") then
          iMyX = iOldMX
          iMyY = iOldMY
          iCurMap = iOldMap
          sCurrentMap = sOldMap
          if (sClickedRoomID ~= "") then
            if (sQuowLocationsByRoomID[sClickedRoomID] ~= nil) then
              QuowRouteToRoomID(sClickedRoomID, true, false)
            else
              Note("Unable to find a route - ensure you click on a recognised room on the map first, and you are not in darkness.")
            end
          else
            Note("Unable to find a route - ensure you click on a recognised room on the map first, and you are not in darkness.")
          end

        elseif (sRMBResult == "MUSHclient Frame - Default Colour") then  
          winThemeData.MAINFRAME = 0xFFFFFFFF
          if (iMushclientVersion >= 5.07) then
            SetFrameBackgroundColour(winThemeData.MAINFRAME)
            ColourNote(sCOLOUR.orange, "", "The MUSHclient main background frame has been reset to the default OS colouring.")
          end
        elseif (sRMBResult == "MUSHclient Frame - Pick Colour") then
          local iNewColour
          if (winThemeData.MAINFRAME == 0xFFFFFFFF) then
            iNewColour = PickColour(0xFFFFFF)
          else
            iNewColour = PickColour(winThemeData.MAINFRAME)
          end
          if (iNewColour ~= -1) then
            winThemeData.MAINFRAME = iNewColour 
            if (iMushclientVersion >= 5.07) then
              SetFrameBackgroundColour(winThemeData.MAINFRAME)
              ColourNote(sCOLOUR.orange, "", "The MUSHclient main background frame colour has been changed.")
            end
          end

        elseif (sRMBResult == "Background - Clear Image") then
          sBackgroundImage = ""
          SetBackgroundImage("", 0)          
          ColourNote(sCOLOUR.orange, "", "Any background images have now been cleared.")

        elseif (sRMBResult == "Background - Load Image") then
          local sFilename = utils.filepicker("Select Valid *.PNG Image File", sBackgroundImage, "*.png", { ["png"] = "PNG Files" }, false)
          if (sFilename ~= nil) then
            if (sFilename ~= sBackgroundImage) then
              sBackgroundImage = sFilename
              SetBackgroundImage(sBackgroundImage, 0)
            end
          else
            Note("Cancelled selecting a background image.")
          end

        elseif (sRMBResult == "Colour Theme - Export") then
          -- Exporting hotspots to a jsonified shortlist
          local Col = {["W"] = {}, ["C"] = {}}
          Col["W"] = {
            [1] = RGBColourToName(winThemeData.WINDOW_BORDER),
            [2] = RGBColourToName(winThemeData.HIGHLIGHT),
            [3] = RGBColourToName(winThemeData.INNERSHADOW),
            [4] = RGBColourToName(winThemeData.OUTERSHADOW),
            [5] = RGBColourToName(winThemeData.FACE),
            [6] = RGBColourToName(winThemeData.ONFACE),
            [7] = RGBColourToName(winThemeData.TEXTSHADOW),
            [8] = RGBColourToName(winThemeData.BACK_FACE),
            [9] = RGBColourToName(winThemeData.DETAIL),
            [10] = RGBColourToName(winThemeData.SELECTFACE)
          }
          if (winThemeData.MAINFRAME ~= 0xFFFFFFFF) then
            Col["W"][11] = RGBColourToName(winThemeData.MAINFRAME)
          else
            Col["W"][11] = ""
          end
          for sThisColourKey, sThisColourValue in pairs(sCOLOUR) do
            Col["C"][sThisColourKey] = sThisColourValue
          end
          SetClipboard("COWTHEME:" .. json.encode(Col))
          ColourNote(sCOLOUR.orange, "", "Your current colour theme has been copied to your clipboard for you to backup or to 'paste' to others, for example through tells or group chat.")

        elseif (sRMBResult == "Colour Theme - Import") then
          -- Importing hotspots
          local sColoursImport = utils.inputbox("Please paste a FULL theme data starting with and including COWTHEME:\n", "Import Colours", "", "", 12)
          if (sColoursImport ~= nil) then
            if (string.sub(sColoursImport, 1, 9) == "COWTHEME:") then
              sColoursImport = string.sub(sColoursImport, 10)
              local objImportedColours = json.decode(sColoursImport)
              if (objImportedColours ~= nil and objImportedColours["C"] ~= nil and objImportedColours["W"] ~= nil) then
                -- Import theme colours
                winThemeData.WINDOW_BORDER = ColourNameToRGB(objImportedColours["W"][1]) -- for miniwindow body
                winThemeData.HIGHLIGHT=ColourNameToRGB(objImportedColours["W"][2]) -- 3d panel top-left highlights
                winThemeData.INNERSHADOW=ColourNameToRGB(objImportedColours["W"][3]) -- 3d panel bottom-right inner mid
                winThemeData.OUTERSHADOW = ColourNameToRGB(objImportedColours["W"][4]) -- 3d panel bottom-right dark
                winThemeData.FACE=ColourNameToRGB(objImportedColours["W"][5]) -- for 3D surfaces
                winThemeData.ONFACE=ColourNameToRGB(objImportedColours["W"][6]) -- for text on 3D surfaces
                winThemeData.TEXTSHADOW=ColourNameToRGB(objImportedColours["W"][7]) -- for text-shadowing (eg HP bars)
                winThemeData.BACK_FACE = ColourNameToRGB(objImportedColours["W"][8]) -- for scrollbar back
                winThemeData.DETAIL = ColourNameToRGB(objImportedColours["W"][9]) -- for scrollbar lines
                -- Importing from v4.00 will be lacking SELECTFACE, so be careful;
                if (objImportedColours["W"][10] ~= nil) then
                  winThemeData.SELECTFACE = ColourNameToRGB(objImportedColours["W"][10])
                else
                  winThemeData.SELECTFACE = winThemeData.FACE
                end
                -- Importing from CowBar v4.07 and later, for the MUSHclient 5.07 and later mainframe background window
                if (objImportedColours["W"][11] ~= nil) then
                  if (objImportedColours["W"][11] == "") then
                    winThemeData.MAINFRAME = 0xFFFFFFFF
                  else
                    winThemeData.MAINFRAME = ColourNameToRGB(objImportedColours["W"][11])
                  end
                else
                  winThemeData.MAINFRAME = 0xFFFFFFFF
                end
                -- Import core colours
                for sThisColourKey, sThisColourValue in pairs(objImportedColours["C"]) do
                  if (sCOLOUR[sThisColourKey] ~= nil) then
                    sCOLOUR[sThisColourKey] = sThisColourValue
                  end
                end
                iCOLOUR = {}
                for sColourKey, sColourString in pairs(sCOLOUR) do
                  iCOLOUR[sColourKey] = ColourNameToRGB(sColourString)
                end
                -- If our version supports it, set mainframe background colour
                if (iMushclientVersion >= 5.07) then
                  SetFrameBackgroundColour(winThemeData.MAINFRAME)
                end
                -- Now redraw all Quow windows
                RedrawEverything()
                ColourNote(sCOLOUR.orange, "", "Your colour theme has been updated from the imported/pasted colours.  You can modify them further from the menus.")
              else
                Note("Colour theme importing failed, you may have missed a character at the start or end of the paste.")
              end
            else
              Note("Colour theme importing failed, you may have missed a character at the start or end of the paste.")
            end
          else
            Note("Colour theme importing cancelled.")
          end

        -- Core colour mode/colour theme/colour scheme
        elseif (string.sub(sRMBResult, 1, 15) == "Colour Theme - ") then
          sRMBResult = string.sub(sRMBResult, 16)
          if (sRMBResult == "Basic Cow") then
            sTheme = "default"
          elseif (sRMBResult == "Black Patched") then
            sTheme = "darkmode"
          elseif (sRMBResult == "White Patched") then
            sTheme = "lightmode"
          elseif (sRMBResult == "Green Pasture") then
            sTheme = "greenmode"
          elseif (sRMBResult == "Winter Moo") then
            sTheme = "bluemode"
          elseif (sRMBResult == "Grey Moo") then
            sTheme = "greymode"
          elseif (sRMBResult == "Bull Red") then
            sTheme = "redmode"
          end
          ChangeColourTheme(sTheme)

        -- Reset all core Cow Bar Colours
        elseif (sRMBResult == "Reset Current Theme Colours") then
          ChangeColourTheme(sTheme)
          CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")

        elseif (sRMBResult == "Customise Current Theme") then
          local sCustomiseOptions = {
            [1] = "Miniwindow Backgrounds",
            [2] = "Text-List Backgrounds",
            [3] = "Disc-Date Background",
            [4] = "Texts - General",
            [5] = "Texts - Notices",
            [6] = "Texts - Highlights",
            [7] = "Texts - Green",
            [8] = "Texts - Red",
            [9] = "Texts - Grey",
            [10] = "Miniwindow Borders",
            [11] = "Tab Background",
            [12] = "Tab Selected Background",
            [13] = "Tab Face Text",
            [14] = "Tab Highlights",
            [15] = "Tab Outer Shadow",
            [16] = "Tab Inner Shadow",
            [17] = "Vitals Text Shadows",
            [18] = "Scrollbar Back",
            [19] = "Scrollbar Details",
            [20] = "Disc-Date Text",
            [21] = "XP Rate-Line",
          }
          local iColourOption = utils.listbox("Select a colour option in the list below to customise:\n\n", "Colour Customising", sCustomiseOptions)
          if (iColourOption ~= nil) then
            iColourOption = tonumber(iColourOption)
            local sSelectedOption = ""
            if (sCustomiseOptions[iColourOption] ~= nil) then
              sSelectedOption = sCustomiseOptions[iColourOption]
            end
            if (sSelectedOption == "Miniwindow Backgrounds") then
              local iNewColour = PickColour(iCOLOUR["black"])
              if (iNewColour ~= -1) then
                iCOLOUR["black"] = iNewColour
                sCOLOUR["black"] = RGBColourToName(iNewColour)
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Text-List Backgrounds") then
              local iNewColour = PickColour(iCOLOUR["offblack"])
              if (iNewColour ~= -1) then
                iCOLOUR["offblack"] = iNewColour
                sCOLOUR["offblack"] = RGBColourToName(iNewColour)
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Disc-Date Background") then
              local iNewColour = PickColour(iCOLOUR["white"])
              if (iNewColour ~= -1) then
                iCOLOUR["white"] = iNewColour
                sCOLOUR["white"] = RGBColourToName(iNewColour)
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Disc-Date Text") then
              local iNewColour = PickColour(iCOLOUR["date"])
              if (iNewColour ~= -1) then
                iCOLOUR["date"] = iNewColour
                sCOLOUR["date"] = RGBColourToName(iNewColour)
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "XP Rate-Line") then
              local iNewColour = PickColour(iCOLOUR["xp"])
              if (iNewColour ~= -1) then
                iCOLOUR["xp"] = iNewColour
                sCOLOUR["xp"] = RGBColourToName(iNewColour)
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Texts - General") then
              local iNewColour = PickColour(iCOLOUR["silver"])
              if (iNewColour ~= -1) then
                iCOLOUR["silver"] = iNewColour
                sCOLOUR["silver"] = RGBColourToName(iNewColour)
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Texts - Notices") then
              local iNewColour = PickColour(iCOLOUR["orange"])
              if (iNewColour ~= -1) then
                iCOLOUR["orange"] = iNewColour
                sCOLOUR["orange"] = RGBColourToName(iNewColour)
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Texts - Highlights") then
              local iNewColour = PickColour(iCOLOUR["cyan"])
              if (iNewColour ~= -1) then
                iCOLOUR["cyan"] = iNewColour
                sCOLOUR["cyan"] = RGBColourToName(iNewColour)
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Texts - Green") then
              local iNewColour = PickColour(iCOLOUR["green"])
              if (iNewColour ~= -1) then
                iCOLOUR["green"] = iNewColour
                sCOLOUR["green"] = RGBColourToName(iNewColour)
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Texts - Red") then
              local iNewColour = PickColour(iCOLOUR["red"])
              if (iNewColour ~= -1) then
                iCOLOUR["red"] = iNewColour
                sCOLOUR["red"] = RGBColourToName(iNewColour)
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Texts - Grey") then
              local iNewColour = PickColour(iCOLOUR["grey"])
              if (iNewColour ~= -1) then
                iCOLOUR["grey"] = iNewColour
                sCOLOUR["grey"] = RGBColourToName(iNewColour)
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            -- Theme data colourings
            elseif (sSelectedOption == "Miniwindow Borders") then
              local iNewColour = PickColour(winThemeData.WINDOW_BORDER)
              if (iNewColour ~= -1) then
                winThemeData.WINDOW_BORDER = iNewColour
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Tab Background") then
              local iNewColour = PickColour(winThemeData.FACE)
              if (iNewColour ~= -1) then
                winThemeData.FACE = iNewColour
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Tab Selected Background") then
              local iNewColour = PickColour(winThemeData.SELECTFACE)
              if (iNewColour ~= -1) then
                winThemeData.SELECTFACE = iNewColour
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Tab Face Text") then
              local iNewColour = PickColour(winThemeData.ONFACE)
              if (iNewColour ~= -1) then
                winThemeData.ONFACE = iNewColour
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end
            elseif (sSelectedOption == "Tab Highlights") then
              local iNewColour = PickColour(winThemeData.HIGHLIGHT)
              if (iNewColour ~= -1) then
                winThemeData.HIGHLIGHT = iNewColour
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end 
            elseif (sSelectedOption == "Tab Outer Shadow") then
              local iNewColour = PickColour(winThemeData.OUTERSHADOW)
              if (iNewColour ~= -1) then
                winThemeData.OUTERSHADOW = iNewColour
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end 
            elseif (sSelectedOption == "Tab Inner Shadow") then
              local iNewColour = PickColour(winThemeData.INNERSHADOW)
              if (iNewColour ~= -1) then
                winThemeData.INNERSHADOW = iNewColour
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end 
            elseif (sSelectedOption == "Vitals Text Shadows") then
              local iNewColour = PickColour(winThemeData.TEXTSHADOW)
              if (iNewColour ~= -1) then
                winThemeData.TEXTSHADOW = iNewColour
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end 
            elseif (sSelectedOption == "Scrollbar Back") then
              local iNewColour = PickColour(winThemeData.BACK_FACE)
              if (iNewColour ~= -1) then
                winThemeData.BACK_FACE = iNewColour
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end 
            elseif (sSelectedOption == "Scrollbar Details") then
              local iNewColour = PickColour(winThemeData.DETAIL)
              if (iNewColour ~= -1) then
                winThemeData.DETAIL = iNewColour
                CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawEverything", "", "")
              end 
            end -- Which colour option
          end -- Got a colour option

        -- ***************************************
        -- *   Font-Type and Font-Size Options   *
        -- ***************************************
        -- Restore the default font-type for a selected window
        elseif (string.sub(sRMBResult, 1, 26) == "Font: Restore Default for ") then
          sRMBResult = string.sub(sRMBResult, 27)
          if (sRMBResult == "Date") then
            objWindowFonts[winMinimap] = {["body"] = "FixedSys", ["size"] = 8,}
            objThisWindowName = winMinimap
          end
          CallPlugin ("bfe35205f026786ea1d56e3b", "QuowChangeFont", objThisWindowName)
          ColourNote(sCOLOUR.orange, "", "The font for the " .. sRMBResult .. " window has been reset to the default '" .. objWindowFonts[objThisWindowName]["body"] .. "' [" .. tostring(objWindowFonts[objThisWindowName]["size"]) .. "]")
       
        -- Change the core font-type for a selected window
        elseif (string.sub(sRMBResult, 1, 25) == "Font: Pick Font-Type for ") then
          sRMBResult = string.sub(sRMBResult, 26)
          local objThisWindowName, bNeedMono = "", false
          if (sRMBResult == "Date") then
            objThisWindowName = winMinimap
            bNeedMono = true
          end
          -- Load the custom font-picker window
          local _, sFontChoice = CallPlugin ("bfe35205f026786ea1d56e3b", "QuowPickFontType", objWindowFonts[objThisWindowName]["body"], bNeedMono, sRMBResult)
          -- Change the font
          if (sFontChoice ~= "") then
            -- Make the changes and do the refreshing
            objWindowFonts[objThisWindowName]["body"] = sFontChoice
            CallPlugin ("bfe35205f026786ea1d56e3b", "QuowChangeFont", objThisWindowName)
            ColourNote(sCOLOUR.orange, "", "The font for the " .. sRMBResult .. " window has been changed to '" .. sFontChoice .. "' [" .. tostring(objWindowFonts[objThisWindowName]["size"]) .. "]")
          else
            Note("Font-type selection cancelled, the font-type for the " .. sRMBResult .. " window has not been changed.")
          end

        -- Change the core font-size for a selected window
        elseif (string.sub(sRMBResult, 1, 25) == "Font: Pick Font-Size for ") then
          sRMBResult = string.sub(sRMBResult, 26)
          local objThisWindowName = ""
          if (sRMBResult == "Date") then
            objThisWindowName = winMinimap
          end
          -- Load the custom font-size window
          local _, iFontSizeChoice = CallPlugin ("bfe35205f026786ea1d56e3b", "QuowPickFontSize", objWindowFonts[objThisWindowName]["size"], sRMBResult)
          -- Change the font
          if (iFontSizeChoice ~= 0) then
            -- Make the changes (includes extra sizing as needed) and do the refreshing
            objWindowFonts[objThisWindowName]["size"] = iFontSizeChoice
            CallPlugin ("bfe35205f026786ea1d56e3b", "QuowChangeFont", objThisWindowName)
            ColourNote(sCOLOUR.orange, "", "The font-size for the " .. sRMBResult .. " window has been changed to " .. tostring(iFontSizeChoice) .. " ['" .. objWindowFonts[objThisWindowName]["body"] .. "']")
          else
            Note("Font-size change cancelled, the font-size for the " .. sRMBResult .. " window has not been changed.")
          end

        -- Other formatting options
        elseif (sRMBResult == "Attempt Auto-Wrap Output") then
          if (bRapMyWrap == false) then
            bRapMyWrap = true
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WILL try to auto-configure word-wrap on your output.")
            QuowRapMyWrap()
          else
            bRapMyWrap = false
            SetOption ("wrap", 0)
            ColourNote(sCOLOUR.cyan, "", "Quow's Cow Bar WON'T try to auto-configure word-wrap on your output.")
          end

        elseif (sRMBResult == "Switch To Map") then
          local sMapChoices = {}
          for iCheckMap, objThisMapFile in pairs(sQuowMapfiles) do
            sMapChoices[iCheckMap] = objThisMapFile[2]
          end
          local sMapSwitchChoice = utils.listbox("Select a map to switch to.\n", "Map Selection:", sMapChoices, iCurMap)
          if (sMapSwitchChoice ~= nil) then
            if (sQuowMapfiles[tonumber(sMapSwitchChoice)] ~= nil) then
              iCurMap = tonumber(sMapSwitchChoice)
              sCurrentMap = sQuowMapfiles[iCurMap][1]
              iMyX = sQuowMapfiles[iCurMap][5]
              iMyY = sQuowMapfiles[iCurMap][6]
              -- get a room ID if one matches this exact co-ordinate
              sSQL = "SELECT room_id, map_id, xpos, ypos, room_short, room_type FROM rooms WHERE map_id=" .. iCurMap .. " AND xpos=" .. iMyX .. " AND ypos=" .. iMyY
              for row in dbMap:nrows(sSQL) do
                sClickedRoomID = row.room_id
                break
              end
              RedrawMap()
              Note("Changing map to:  " .. sQuowMapfiles[iCurMap][2] .. " (" .. sQuowMapfiles[iCurMap][1] .. ")")
            end
          end
        end
      end
    else
      -- Anything else re-centres the map, based on current zoom levels
      -- Now get the mouse position (affected by zoom scaling)
      local iMouseX = ((WindowInfo(winMinimap, 14) - MINIMAP_CX) * iZoomData[iUseZoom][2]) - 1
      local iMouseY = (((WindowInfo(winMinimap, 15) - winThemeData.TITLE_HEIGHT) - MINIMAP_CY) * iZoomData[iUseZoom][2]) - 1

      -- Snap to grid for UU and Shades
      if (iCurMap == 47) then
        -- Grid of 30x30 snap-zooming
        iMouseX = iMouseX - 15
        iMouseY = iMouseY - 15
        iMouseX = math.floor((iMouseX / 30) + 1) * 30
        iMouseY = math.floor((iMouseY / 30) + 1) * 30
      elseif (iCurMap == 8) then

      end

      -- Admin edit mode to record hotspot zones (special feature for shift-clicking buildings and changing map)
      if (bRecordingHotzones == true and bit.band(flags, miniwin.hotspot_got_shift) == 0) then
        if (iHotspotLevel == 1) then
          Note("Recorded one corner of a new hotzone area, now click the opposite corner...")
          iCurrentHotspot = #sQuowHotZones[iCurMap] + 1
          iTempZone[1] = iCurMap
          iTempZone[2] = (iMyX + iMouseX)
          iTempZone[3] = (iMyY + iMouseY)
          iHotspotLevel = iHotspotLevel + 1
          return
        elseif (iHotspotLevel == 2) then
          Note("Recorded area of the new hotzone, now click on a room to jump to.  You can shift-click around the map without selecting a room, and switch to a map in the right click menu first.")
          if ((iMyX + iMouseX) < iTempZone[2]) then
            iTempZone[4] = iTempZone[2]
            iTempZone[2] = (iMyX + iMouseX)
          else
            iTempZone[4] = (iMyX + iMouseX)
          end
          if ((iMyY + iMouseY) < iTempZone[3]) then
            iTempZone[5] = iTempZone[3]
            iTempZone[3] = (iMyY + iMouseY)
          else
            iTempZone[5] = (iMyY + iMouseY)
          end
          iHotspotLevel = iHotspotLevel + 1
          return
        end
      end

      iMyX = (iMyX + iMouseX)
      iMyY = (iMyY + iMouseY)
      --Note("Debug: Mouse Translation MX=" .. iMyX .. ", MY=" .. iMyY)

      -- Holding shift, skip out before doing anything else!
      if (bRecordingHotzones == true and bit.band(flags, miniwin.hotspot_got_shift) ~= 0) then
        RedrawMap()
        Repaint()
        return
      end

      -- Check a hotspot
      if (bit.band(flags, miniwin.hotspot_got_shift) ~= 0 and sQuowHotZones[iCurMap] ~= nil) then
        for iHotID, sHotData in ipairs(sQuowHotZones[iCurMap]) do
          if (iMyX >= sHotData[1] and iMyX <= sHotData[3] and iMyY >= sHotData[2] and iMyY <= sHotData[4]) then
            sClickedRoomID = sHotData[5]
            iCurMap = sQuowLocationsByRoomID[sClickedRoomID][1]
            sCurrentMap = sQuowMapfiles[iCurMap][1]
            iMyX = sQuowLocationsByRoomID[sClickedRoomID][2]
            iMyY = sQuowLocationsByRoomID[sClickedRoomID][3]
            RedrawMap()
            Repaint()
            return
          end
        end
      end

      sClickedRoomID = ""
      -- Find a database entry for nearest room to snapto and search from, if not ctrl-clicking
      if (iCurMap ~= 99 and (bCreatingRooms == false or (bCreatingRooms == true and bit.band(flags, miniwin.hotspot_got_control) == 0))) then
        if (sQuowMapfiles[iCurMap] ~= nil) then
          local iGridX = sQuowMapfiles[iCurMap][3]
          local iGridY = sQuowMapfiles[iCurMap][4]
          local iBestDistance = 500
          local iThisDistance = 0
          local iDistX = 0
          local iDistY = 0
          local iRealX = iMyX
          local iRealY = iMyY
          sSQL = "SELECT room_id, map_id, xpos, ypos, room_short, room_type FROM rooms WHERE map_id=" .. iCurMap .. 
            " AND xpos>=" .. (iMyX-iGridX) .. " AND xpos<=" .. (iMyX+iGridX) ..
            " AND ypos>=" .. (iMyY-iGridY) .. " AND ypos<=" .. (iMyY+iGridY)
          for row in dbMap:nrows(sSQL) do
            iDistX = math.abs(iRealX - row.xpos)
            iDistY = math.abs(iRealY - row.ypos)
            iThisDistance = math.sqrt((iDistX * iDistX) + (iDistY * iDistY))
            if (iThisDistance < iBestDistance) then
              iBestDistance = iThisDistance
              iMyX = row.xpos
              iMyY = row.ypos
              sClickedRoomID = row.room_id
            end
          end
        else
          ColourNote(iCOLOUR.orange, "", "There seems to be an error in your Cow Bar install.  The saved variable CurMap is set to: " .. tostring(iCurMap) .. ".  Attempting to fix this error automatically.")
          iCurMap = 1
          iOldMap = 1
          ColourNote(sCOLOUR.silver, "", "This error occurred in the function 'QuowMapMouse', and the plugin thinks you were trying to click on the graphical minimap at the time this error happened.")
          ColourNote(sCOLOUR.silver, "", "The map IDs have now been reset, which may fix this error.  You may now try clicking on the graphical map again.")
          RedrawMap()
          Repaint()
        end
      end

      if (sClickedRoomID ~= "" and bRecordingHotzones == true) then
        if (iHotspotLevel == 3) then
          iTempZone[6] = sClickedRoomID
          local sThisLine = "[" .. iTempZone[1] .. "] = {" .. iTempZone[2] .. ", " .. iTempZone[3] .. ", " .. iTempZone[4] .. ", " .. iTempZone[5] .. ", '" .. iTempZone[6] .. "'}, -- " .. sQuowMapfiles[iTempZone[1]][2] .. " to " .. sQuowMapfiles[sQuowLocationsByRoomID[sClickedRoomID][1]][2] .. "(" .. sQuowLocationsByRoomID[sClickedRoomID][4] .. ")\n"
          Note(sThisLine)
          SetClipboard(sThisLine)
          sQuowHotZones[iTempZone[1]][iCurrentHotspot] = {iTempZone[2], iTempZone[3], iTempZone[4], iTempZone[5], iTempZone[6]}
          iCurrentHotspot = #sQuowHotZones + 1
          iHotspotLevel = 0
          bRecordingHotzones = false
          Note("Hotzone has been recorded and added to your clipboard.  This line must be added to the .xml plugin file in the list of hotzones.")
        end
      end

      -- Try to find a route if ctrl-clicking (and if not in editor-mode)?
      if (bCreatingRooms == false and bit.band(flags, miniwin.hotspot_got_control) ~= 0) then
        -- Terrain location adjustment *OR* speedwalk instant
        if (iCurMap == 99) then
          -- Cap our clicked-spot
          iMyX = math.ceil(iMyX)
          iMyY = math.ceil(iMyY)
          -- Difference between ORIGINAL terrain-spot and where on the screen we clicked
          iTerrainShiftX = math.floor(iMyX - (iCatchupX - iTerrainShiftX))
          iTerrainShiftY = math.floor(iMyY - (iCatchupY - iTerrainShiftY))
        else
          iMyX = iOldMX
          iMyY = iOldMY
          iCurMap = iOldMap
          sCurrentMap = sOldMap
          if (sClickedRoomID ~= "") then
            if (sQuowLocationsByRoomID[sClickedRoomID] ~= nil) then
              QuowRouteToRoomID(sClickedRoomID, false, false)
            else
              Note("Unable to find a route - ensure you click on a recognised room on the map first, and you are not in darkness.")
            end
          else
            Note("Unable to find a route - ensure you click on a recognised room on the map first, and you are not in darkness.")
          end
        end
      end
    end
    RedrawMap()
    Repaint()
  end
end

-- Fully enable a module and associated triggers, timers etc.
function ModuleEnable(sModule)
  MODULES[sModule] = true
  iThemeLayoutLocked = 0
  if (sModule == "vitals") then
    WINDATA[winBars]["SHOW"] = true
    iThemeLayoutLocked = 0
    WindowShow(winBars, true)
    ReorderWindows(winBars)
    bForceVitalsUpdate = true
    RedrawVitalsWindow()
    EnableTriggerGroup ("module_vitals", true)
    EnableTimer("timer_gpregen", true)
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar:  Character Vitals Module Enabled.")
  elseif (sModule == "xp") then
    WINDATA[winXP]["SHOW"] = true
    iThemeLayoutLocked = 0
    WindowShow(winXP, true)
    ReorderWindows(winXP)
    RedrawXPWindow(true)
    EnableTriggerGroup ("module_xp", true)
    EnableTimer("timer_xpgraph", true)
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar:  XP Module Enabled.")
  elseif (sModule == "mdt") then
    WINDATA[winMDT]["SHOW"] = true
    iThemeLayoutLocked = 0
    WindowShow(winMDT, true)
    ReorderWindows(winMDT)
    RedrawMDTWindow()
    EnableTriggerGroup ("module_mdt", true)
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar:  Written-Map Module Enabled.")
  elseif (sModule == "ascii") then
    WINDATA[winAscii]["SHOW"] = true
    iThemeLayoutLocked = 0
    WindowShow(winAscii, true)
    ReorderWindows(winAscii)
    RedrawAsciiWindow()
    EnableTriggerGroup ("module_ascii", true)
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar:  Ascii-Map Module Enabled.")
  elseif (sModule == "hotspots") then
    WINDATA[winHotspots]["SHOW"] = true
    iThemeLayoutLocked = 0
    WindowShow(winHotspots, true)
    ReorderWindows(winHotspots)
    RedrawHotspotsWindow()
    EnableTriggerGroup ("module_hotspots", true)
    EnableTimer("timer_hotspots", true)
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar:  Hotspots Module Enabled.")
  elseif (sModule == "stats") then
    WINDATA[winStats]["SHOW"] = true
    iThemeLayoutLocked = 0
    CallPlugin ("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
    WindowShow(winStats, true)
    ReorderWindows(winStats)
    RedrawStatsWindow()
    EnableTriggerGroup ("module_stats", true)
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar:  Stats Module Enabled.")
    if (bOptimisedCombatTriggers == true and iMushclientVersion >= 4.89) then
      EnableTrigger("QuowStatOptimizer", true)
    else
      EnableTrigger("QuowStatOptimizer", false)
    end
  elseif (sModule == "shields") then
    WINDATA[winShields]["SHOW"] = true
    WindowShow(winShields, true)
    ReorderWindows(winShields)
    RedrawShieldsWindow()
    EnableTriggerGroup("module_shields", true)
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar:  Group and Shields Module has been enabled.")
  elseif (sModule == "comms") then
    MODULES["comms"] = true
    WINDATA[winComms]["SHOW"] = true
    iThemeLayoutLocked = 0
    sCommsBuffer = {}
    iCommsCountByType = {}
    iChatExtraChannels = 0
    iCurrentChannelChoice = 1
    for sKey, sData in pairs(objChatFilters) do
      iCommsCountByType[sKey] = 0
      iChatExtraChannels = iChatExtraChannels + 1
    end
    iCommsMessagesCurrentlyShown = 0
    WindowShow(winComms, true)
    ReorderWindows(winComms)
    ChangeChatChannel(1)
    bCommsNeedsButtons = true
    RedrawCommsWindow()
    EnableTriggerGroup ("module_comms", true)
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar:  Comms talker/chat capture module enabled.")
  end
end
-- Fully disable a module and associated triggers, timers etc.
function ModuleDisable(sModule)
  MODULES[sModule] = false
  iThemeLayoutLocked = 0
  if (sModule == "vitals") then
    WINDATA[winBars]["SHOW"] = false
    iThemeLayoutLocked = 0
    WindowShow(winBars, false)
    EnableTriggerGroup ("module_vitals", false)
    EnableTimer("timer_gpregen", false)
    ColourNote(sCOLOUR.red, "", "Quow's Cow Bar:  Character Vitals Module Disabled.")
    ColourNote(sCOLOUR.silver, "", "Your HP, GP, and Burden will not be logged.  There will be no GP-Full notifications, or HP-Low notifications.")
  elseif (sModule == "xp") then
    WINDATA[winXP]["SHOW"] = false
    iThemeLayoutLocked = 0
    WindowShow(winXP, false)
    EnableTriggerGroup ("module_xp", false)
    EnableTimer("timer_xpgraph", false)
    ColourNote(sCOLOUR.red, "", "Quow's Cow Bar:  XP Module Disabled.")
    ColourNote(sCOLOUR.silver, "", "Your XP rates will not be logged.  You cannot group-report your XP-rates.")
  elseif (sModule == "mdt") then
    WINDATA[winMDT]["SHOW"] = false
    iThemeLayoutLocked = 0
    WindowShow(winMDT, false)
    EnableTriggerGroup ("module_mdt", false)
    ColourNote(sCOLOUR.red, "", "Quow's Cow Bar:  Written-Map Module Disabled.")
    ColourNote(sCOLOUR.silver, "", "You will not see a short-range written-map every time you enter a room.")
  elseif (sModule == "ascii") then
    WINDATA[winAscii]["SHOW"] = false
    iThemeLayoutLocked = 0
    WindowShow(winAscii, false)
    EnableTriggerGroup ("module_ascii", false)
    ColourNote(sCOLOUR.red, "", "Quow's Cow Bar:  Ascii-Map Module Disabled.")
    ColourNote(sCOLOUR.silver, "", "The Ascii-Map sent by the MUD will not be copied into a window.  Ascii-Maps will not automatically pop-up, or hide, in terrains.")
  elseif (sModule == "hotspots") then
    WINDATA[winHotspots]["SHOW"] = false
    iThemeLayoutLocked = 0
    WindowShow(winHotspots, false)
    EnableTriggerGroup ("module_hotspots", false)
    EnableTimer("timer_hotspots", false)
    ColourNote(sCOLOUR.red, "", "Quow's Cow Bar:  Hotspots Module Disabled.")
    ColourNote(sCOLOUR.silver, "", "The Hotspots module will no longer update or track any timers, send you notification reminders, and any currently ticking timers will be ignored.")
  elseif (sModule == "stats") then
    WINDATA[winStats]["SHOW"] = false
    iThemeLayoutLocked = 0
    CallPlugin ("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
    WindowShow(winStats, false)
    EnableTriggerGroup ("module_stats", false)
    EnableTrigger("QuowStatOptimizer", false)
    ColourNote(sCOLOUR.red, "", "Quow's Cow Bar:  Stats Module Disabled.")
    ColourNote(sCOLOUR.silver, "", "Your combat messages will not be coloured or omitted based on categories.  No combat stats will be recorded.  You cannot generate combat-stat reports.")
    ColourNote(sCOLOUR.orange, "", "If you want to keep the stats module, but find your MUSHclient to be too sluggish with stats enabled, have you tried the 'Optimize Combat Stats Triggers' option in the stats window menu?")
  elseif (sModule == "shields") then
    WINDATA[winShields]["SHOW"] = false
    WindowShow(winShields, false)
    EnableTriggerGroup("module_shields", false)
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar:  Group and Shields Module has been fully disabled.")
    ColourNote(sCOLOUR.red, "", "Warning:  This will also disable the Cow Bar built in sounds for shield breaks if you use them.")
  elseif (sModule == "comms") then
    MODULES["comms"] = false
    WINDATA[winComms]["SHOW"] = false
    iThemeLayoutLocked = 0
    WindowShow(winComms, false)
    sCommsBuffer = {}
    for sKey, sData in pairs(iCommsCountByType) do
      iCommsCountByType[sKey] = 0
    end
    iCommsMessagesCurrentlyShown = 0
    iCurrentChannelChoice = 1
    EnableTriggerGroup ("module_comms", false)
    ColourNote(sCOLOUR.red, "", "Quow's Cow Bar:  Comms Module Disabled.")
    ColourNote(sCOLOUR.silver, "", "Tells, group says, and talker channels will not be monitored, recorded, or displayed in a communications window.")
  end
end

-- Temporary hotspot creator
iHotspotLevel = 0
iTempZone = {}
function QuowHotspotStart()
  if (bRecordingHotzones == true) then
    Note("Starting hotspot record... click top-left, then bottom-right, of square... then go to a room and snap-to it to complete!")
    iTempZone = nil
    iTempZone = {}
    iHotspotLevel = 1
  end
end

-- Text command to list all bookmarks to output
function QuowBookmarkList(sSearchPhrase, iResultEntryPoint)
  local iBookmarkFinds = 0
  local iAlternator = 1
  local iTotalBookmarks = 0
  local iBookmarkNumLen = 1
  for _, sBookmarkData in pairs(sSortedBookmarks) do
    iTotalBookmarks = iTotalBookmarks + 1
  end
  iBookmarkNumLen = string.len(tostring(iTotalBookmarks)) + 1
  sSortedBookmarkRoomID = nil
  sSortedBookmarkRoomID = {}
  if (iResultEntryPoint == nil) then
    iResultEntryPoint = 0
  end
  if (iResultEntryPoint == 0) then
    sMinimapSearchResults = {}
  end
  for _, sBookmarkData in pairs(sSortedBookmarks) do
    sBookmarkedRoomID = sBookmarkData[1]
    sBookmarkNote = sBookmarkData[2]
    if (sSearchPhrase == "" or ((sBookmarkNote == "" and string.find(string.lower(sQuowLocationsByRoomID[sBookmarkedRoomID][4]), sSearchPhrase, 1, true) ~= nil) or (sBookmarkNote ~= "" and string.find(string.lower(sBookmarkNote), sSearchPhrase, 1, true) ~= nil))) then
      iBookmarkFinds = iBookmarkFinds + 1
      sSortedBookmarkRoomID[iBookmarkFinds] = sBookmarkedRoomID
      sMinimapSearchResults[iBookmarkFinds + iResultEntryPoint] = sBookmarkedRoomID

      iAlternator = 1 - iAlternator
      if (iAlternator == 0) then
        sAlternatingColour = ""
      else
        sAlternatingColour = sCOLOUR.offblack
      end
      -- Nicely formatted bookmark numbers
      if (sSearchPhrase == "") then
        ColourTell(sCOLOUR.silver, sAlternatingColour, string.format("%-" .. iBookmarkNumLen .. "s", iBookmarkFinds) .. ": ")
      elseif (bScreenreader == true) then
        ColourTell(sCOLOUR.silver, sAlternatingColour,(iBookmarkFinds + iResultEntryPoint) .. ": ")
      end
      -- Only show clickable links if not in screenreader mode
      if (bScreenreader == false) then
        ColourTell(sCOLOUR.grey, sAlternatingColour, "[")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowJumpToRoomID(" .. sBookmarkedRoomID .. ")", "Show", "Display this location (" .. sQuowLocationsByRoomID[sBookmarkedRoomID][1] .. "," .. sQuowLocationsByRoomID[sBookmarkedRoomID][2] .. "," .. sQuowLocationsByRoomID[sBookmarkedRoomID][3] .. ") on the minimap", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRouteToRoomID(" .. sBookmarkedRoomID .. ")", "Route", "Attempt to find a speedwalk to this location (" .. sQuowLocationsByRoomID[sBookmarkedRoomID][1] .. "," .. sQuowLocationsByRoomID[sBookmarkedRoomID][2] .. "," .. sQuowLocationsByRoomID[sBookmarkedRoomID][3] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
        if (sSearchPhrase == "") then
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteBookmark(" .. sBookmarkedRoomID .. ")", "Delete", "Delete this bookmark", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameBookmark(" .. sBookmarkedRoomID .. ")", "Rename", "Rename the room for this bookmark", sCOLOUR.orange, sAlternatingColour, 0)
        end
        ColourTell(sCOLOUR.grey, sAlternatingColour, "] ")
      end
      if (sBookmarkNote == "") then
        ColourTell(sCOLOUR.grey, sAlternatingColour, sQuowLocationsByRoomID[sBookmarkedRoomID][4])
      else
        ColourTell(sCOLOUR.grey, sAlternatingColour, sBookmarkNote)
      end
      ColourTell(sCOLOUR.grey, sAlternatingColour, " (" .. sQuowMapfiles[sQuowLocationsByRoomID[sBookmarkedRoomID][1]][2] .. ")")
      if (sSearchPhrase ~= "") then
        ColourTell(sCOLOUR.grey, sAlternatingColour, " (")
        ColourTell(sCOLOUR.cyan, sAlternatingColour, "bookmarked")
        ColourTell(sCOLOUR.grey, sAlternatingColour, ") ")
      end
      Note("")
    end
  end
  return iBookmarkFinds
end


-- Manually change shop listing price
function QuowChangeShopPrice(sEditShopPriceID)
  if (sItemDBShopItems ~= nil and sItemDBShopItems[sCurrentRoomID] ~= nil and sItemDBShopItems[sCurrentRoomID][sEditShopPriceID] ~= nil) then
    local sNewShopPrice = ""
    local sCurrentShopPrice = sItemDBShopItems[sCurrentRoomID][sEditShopPriceID]
    sNewShopPrice = utils.inputbox("Please edit the price for the item '" .. sEditShopPriceID .. "'", "Price Change", sCurrentShopPrice, "", 12 )
    if (sNewShopPrice ~= nil and sNewShopPrice ~= "") then
      sItemDBShopItems[sCurrentRoomID][sEditShopPriceID] = sNewShopPrice
      local sSaveSQL = "UPDATE shop_items SET sale_price='" .. EscapeSQL(sNewShopPrice) .. "' WHERE room_id='" .. sCurrentRoomID .. 
            "' AND item_name='" .. EscapeSQL(sEditShopPriceID) .. "'"
      assert(dbMap:execute(sSaveSQL))
      Note("Changed shop price for item '" .. sEditShopPriceID .. "' to price: " .. sNewShopPrice .. " [DB Updated]")
    end
  end
end

-- Manually deletean item from the current shop-stock
function QuowDeleteShopStockItem(sDeleteThisItemID)
  if (sItemDBShopItems ~= nil and sItemDBShopItems[sCurrentRoomID] ~= nil and sItemDBShopItems[sCurrentRoomID][sDeleteThisItemID] ~= nil) then
    sItemDBShopItems[sCurrentRoomID][sDeleteThisItemID] = nil
    local sSaveSQL = "DELETE FROM shop_items WHERE room_id='" .. sCurrentRoomID .. "' AND item_name='" .. EscapeSQL(sDeleteThisItemID) .. "'"
    assert(dbMap:execute(sSaveSQL))
    Note("Deleted item '" .. sDeleteThisItemID .. "' from shop currently stood in. [DB Updated]")
  end
end

-- Manual add item to an NPC for a price
function QuowAddNPCStockItem(sAddThisItemID)
  if (sLastNPCCodeViewed ~= nil and sLastNPCCodeViewed ~= "" and sNPCs[sLastNPCCodeViewed] ~= nil and (sItemDBNPCItems[sLastNPCCodeViewed] == nil or sItemDBNPCItems[sLastNPCCodeViewed][sAddThisItemID] == nil)) then
    local sNewShopPrice = ""
    sNewShopPrice = utils.inputbox("Please type a price to add the item '" .. sAddThisItemID .. "' to NPC " .. sLastNPCCodeViewed .. "\n\nLeave price blank to have NPC carry the item.\n", "NPC Stock Add", "", "", 12 )
    if (sNewShopPrice ~= nil) then
      if (sItemDBNPCItems[sLastNPCCodeViewed] == nil) then
        sItemDBNPCItems[sLastNPCCodeViewed] = {}
      end
      sItemDBNPCItems[sLastNPCCodeViewed][sAddThisItemID] = sNewShopPrice
      local sSaveSQL = "INSERT OR REPLACE INTO npc_items (npc_id, item_name, sale_price) VALUES " ..
        "('" .. EscapeSQL(sLastNPCCodeViewed) .. "', '" .. EscapeSQL(sAddThisItemID) .. "', '" .. EscapeSQL(sNewShopPrice) .. "')"
      assert(dbMap:execute(sSaveSQL))
      Tell("Added: " .. sAddThisItemID .. " | to NPC " .. sLastNPCCodeViewed .. " for " .. sNewShopPrice .. " [")
      Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteNPCItem(" .. sAddThisItemID .. ")", "DeleteNPC", "Delete this item from this NPC", sCOLOUR.orange, sAlternatingColour, 0)
      Note("] [DB Updated]")
    end
  end
end

-- Manually add items to shop-stock for a price
function QuowAddShopStockItem(sAddThisItemID)
  if (sItemDBShopItems ~= nil) then
    if (sItemDBShopItems[sCurrentRoomID] == nil) then
      sItemDBShopItems[sCurrentRoomID] = {}
    end
    local sCurrentShopPrice = ""
    local sNewShopPrice = ""
    if (sItemDBShopItems[sCurrentRoomID][sAddThisItemID] ~= nil) then
      sCurrentShopPrice = sItemDBShopItems[sCurrentRoomID][sAddThisItemID]
    end
    sNewShopPrice = utils.inputbox("Please type a price to add the item '" .. sAddThisItemID .. "' to the current room or shop", "Stock Add", sCurrentShopPrice, "", 12 )
    if (sNewShopPrice ~= nil and sNewShopPrice ~= "") then
      sItemDBShopItems[sCurrentRoomID][sAddThisItemID] = sNewShopPrice
      local sSaveSQL = "INSERT OR REPLACE INTO shop_items (room_id, item_name, sale_price) VALUES " ..
        "('" .. sCurrentRoomID .. "', '" .. EscapeSQL(sAddThisItemID) .. "', '" .. EscapeSQL(sNewShopPrice) .. "')"
      assert(dbMap:execute(sSaveSQL))
      Note("Added item '" .. sAddThisItemID .. "' to shop currently stood in for price: " .. sNewShopPrice .. " [DB Updated]")
    end
  end
end


function QuowDeleteNPC(sDeleteThisNPC)
  if (sNPCs[sDeleteThisNPC] == nil) then
    return
  end
  local sPopupResult = utils.inputbox("Type 'yes' to completely delete the npc '" .. sDeleteThisNPC .. "' from the DB.\n\n", "NPC Deletion", "", "", 12 )
  if (sPopupResult ~= nil and string.lower(sPopupResult) == "yes") then
    if (sNPCs[sDeleteThisNPC] ~= nil) then
      sNPCs[sDeleteThisNPC] = {}
      sNPCs[sDeleteThisNPC] = nil
      assert(dbMap:execute("DELETE FROM npc_info WHERE npc_id='" .. EscapeSQL(sDeleteThisNPC) .. "'"))
    end
    if (sItemDBNPCItems ~= nil and sItemDBNPCItems[sDeleteThisNPC] ~= nil) then
      sItemDBNPCItems[sDeleteThisNPC] = nil
      assert(dbMap:execute("DELETE FROM npc_items WHERE npc_id='" .. EscapeSQL(sDeleteThisNPC) .. "'"))
    end
    Note("NPC '" .. sDeleteThisNPC .. "' has been successfully deleted from the plugin. [DB Updated]")
  end -- confirm deletion
end
function QuowMoveNPC(sMoveThisNPC)
  if (sNPCs[sMoveThisNPC] == nil) then
    return
  end
  local sThisRealNewName = ""

  local sPopupResult = utils.inputbox("Type 'yes' to move the NPC '" .. sMoveThisNPC .. "' to your map ID " .. iCurMap .. ".\n\n", "NPC Move", "", "", 12 )
  if (sPopupResult ~= nil and string.lower(sPopupResult) == "yes") then
    sThisRealNewName = iCurMap .. "_" .. sNPCs[sMoveThisNPC]["npc_name"]
    -- First see if an NPC already exists with the same name
    if (sNPCs[sThisRealNewName] ~= nil) then
      -- New NPC already exists, so just delete the old records from the database
      sSQL = "DELETE FROM npc_info WHERE npc_id='" .. EscapeSQL(sMoveThisNPC) .. "'"
      assert(dbMap:execute(sSQL))
      Note("Already an NPC with ID: " .. sThisRealNewName .. " so deleting old: " .. sMoveThisNPC)
    else
      -- New NPC name doesn't already exist, create it from old data
      sNPCs[sThisRealNewName] = {}
      sNPCs[sThisRealNewName]["map_id"] = iCurMap
      sNPCs[sThisRealNewName]["npc_name"] = sNPCs[sMoveThisNPC]["npc_name"]
      sNPCs[sThisRealNewName]["roomid"] = sCurrentRoomID
      if (iCurMap == 99 or sQuowLocationsByRoomID[sCurrentRoomID] == nil) then
        sNPCs[sThisRealNewName]["roomid"] = "{" .. iCurMap .. "," .. iMyX .. "," .. iMyY .. "}"
        Note("Note: Using special navigational map position, NOT the current room ID (" .. sCurrentRoomID .. "): " .. sNPCs[sThisRealNewName]["roomid"])
      end
      sSQL = "UPDATE npc_info SET npc_id='" .. EscapeSQL(sThisRealNewName) .. "', map_id=" .. iCurMap .. 
             ", room_id='" .. EscapeSQL(sNPCs[sThisRealNewName]["roomid"]) .. "' WHERE npc_id='" .. EscapeSQL(sMoveThisNPC) .. "'"
      assert(dbMap:execute(sSQL))
      Note("NPC map ID changed to " .. sThisRealNewName .. " (from old " .. sMoveThisNPC .. ")")
    end

    if (sItemDBNPCItems ~= nil and sItemDBNPCItems[sMoveThisNPC] ~= nil) then
      for sThisItem, sThisItemPrice in pairs(sItemDBNPCItems[sMoveThisNPC]) do
        if (sItemDBNPCItems[sThisRealNewName] == nil) then
          sItemDBNPCItems[sThisRealNewName] = {}
        end
        if (sItemDBNPCItems[sThisRealNewName][sThisItem] == nil) then
          -- This item does NOT exist on the 'new' NPC name, so just shift the NPC-id across
          sSQL = "UPDATE npc_items SET npc_id='" .. EscapeSQL(sThisRealNewName) .. "' WHERE npc_id='" .. EscapeSQL(sMoveThisNPC) .. 
                 "' AND item_name='" .. EscapeSQL(sThisItem) .. "'"
          assert(dbMap:execute(sSQL))
        end
        sItemDBNPCItems[sThisRealNewName][sThisItem] = sThisItemPrice
      end
      sItemDBNPCItems[sMoveThisNPC] = {}
    end
    -- Delete old NPC data
    sNPCs[sMoveThisNPC] = {}
    sNPCs[sMoveThisNPC] = nil
    -- Delete all old items from old NPC from DB
    sSQL = "DELETE FROM npc_items WHERE npc_id='" .. EscapeSQL(sMoveThisNPC) .. "'"
    assert(dbMap:execute(sSQL))

    ColourNote(sCOLOUR.orange, "", "NPC '" .. sMoveThisNPC .. "' has been successfully moved to '" .. sThisRealNewName .. "' [DB Updated]")

  end
end
function QuowRenameNPC(sRenameThisNPC)
  if (sNPCs[sRenameThisNPC] == nil) then
    return
  end
  local sThisRealOldName = sNPCs[sRenameThisNPC]["npc_name"]
  local sThisRealNewName = ""
  local sPopupResult = utils.inputbox("Please type a replacement name for the NPC '" .. sThisRealOldName .. "'.\n\nIf the name already exists, both NPCs will have items merged together.\n\nLeaving it blank will default to the original item name.", "NPC Rename", sThisRealOldName, "", 12 )
  if (sPopupResult ~= nil and sPopupResult ~= "" and sNPCs[sRenameThisNPC] ~= nil) then
    sThisRealNewName = sPopupResult
    sPopupResult = sNPCs[sRenameThisNPC]["map_id"] .. "_" .. sPopupResult

    -- First see if an NPC already exists with the same name
    if (sNPCs[sPopupResult] ~= nil) then
      -- New NPC already exists, so just delete the old records from the database
      sSQL = "DELETE FROM npc_info WHERE npc_id='" .. EscapeSQL(sRenameThisNPC) .. "'"
      assert(dbMap:execute(sSQL))
    else
      -- New NPC name doesn't already exist, create it from old data
      sNPCs[sPopupResult] = {}
      sNPCs[sPopupResult]["map_id"] = sNPCs[sRenameThisNPC]["map_id"]
      sNPCs[sPopupResult]["npc_name"] = sThisRealNewName
      sNPCs[sPopupResult]["roomid"] = sNPCs[sRenameThisNPC]["roomid"]
      sSQL = "UPDATE npc_info SET npc_id='" .. EscapeSQL(sPopupResult) .. "', npc_name='" .. EscapeSQL(sThisRealNewName) .. 
             "' WHERE npc_id='" .. EscapeSQL(sRenameThisNPC) .. "'"
      assert(dbMap:execute(sSQL))
    end

    if (sItemDBNPCItems ~= nil and sItemDBNPCItems[sRenameThisNPC] ~= nil) then
      for sThisItem, sThisItemPrice in pairs(sItemDBNPCItems[sRenameThisNPC]) do
        if (sItemDBNPCItems[sPopupResult] == nil) then
          sItemDBNPCItems[sPopupResult] = {}
        end
        if (sItemDBNPCItems[sPopupResult][sThisItem] == nil) then
          -- This item does NOT exist on the 'new' NPC name, so just shift the NPC-id across
          sSQL = "UPDATE npc_items SET npc_id='" .. EscapeSQL(sPopupResult) .. "' WHERE npc_id='" .. EscapeSQL(sRenameThisNPC) .. 
                 "' AND item_name='" .. EscapeSQL(sThisItem) .. "'"
          assert(dbMap:execute(sSQL))
        end
        sItemDBNPCItems[sPopupResult][sThisItem] = sThisItemPrice
      end
      sItemDBNPCItems[sRenameThisNPC] = {}
    end
    -- Delete old NPC data
    sNPCs[sRenameThisNPC] = {}
    sNPCs[sRenameThisNPC] = nil
    -- Delete all old items from old NPC from DB
    sSQL = "DELETE FROM npc_items WHERE npc_id='" .. EscapeSQL(sRenameThisNPC) .. "'"
    assert(dbMap:execute(sSQL))

    ColourNote(sCOLOUR.orange, "", "NPC '" .. sRenameThisNPC .. "' has been successfully renamed to '" .. sPopupResult .. "' [DB Updated]")

  end -- Any new name given
end -- Rename npc

function QuowDeleteItem(sDeleteThisItemID)

  local sPopupResult = utils.inputbox("Type 'yes' to completely delete the item '" .. sDeleteThisItemID .. "' from the DB.\n\n", "Item Deletion", "", "", 12 )
  if (sPopupResult ~= nil and string.lower(sPopupResult) == "yes") then

    if (sItemDBItems[sDeleteThisItemID] ~= nil) then
      sItemDBItems[sDeleteThisItemID] = {}
      sItemDBItems[sDeleteThisItemID] = nil
      assert(dbMap:execute("DELETE FROM items WHERE item_name='" .. EscapeSQL(sDeleteThisItemID) .. "'"))
    end

    if (sItemDBShopItems ~= nil) then
      for sKey, sItemData in pairs(sItemDBShopItems) do
        if (sItemDBShopItems[sKey][sDeleteThisItemID] ~= nil) then
          sItemDBShopItems[sKey][sDeleteThisItemID] = nil
          assert(dbMap:execute("DELETE FROM shop_items WHERE room_id='" .. sKey .. "' AND item_name='" .. EscapeSQL(sDeleteThisItemID) .. "'"))
        end
      end
    end

    if (sItemDBNPCItems ~= nil) then
      for sKey, sItemData in pairs(sItemDBNPCItems) do
        if (sItemDBNPCItems[sKey][sDeleteThisItemID] ~= nil) then
          sItemDBNPCItems[sKey][sDeleteThisItemID] = nil
          assert(dbMap:execute("DELETE FROM npc_items WHERE npc_id='" .. EscapeSQL(sKey) .. "' AND item_name='" .. EscapeSQL(sDeleteThisItemID) .. "'"))
        end
      end
    end

    Note("Item '" .. sDeleteThisItemID .. "' has been successfully deleted from the plugin. [DB Updated]")

  end -- Any new name given
end
-- Manual-ish editing of an item's data
function QuowEditItem(sEditThisItemID)
  if (sItemDBItems[sEditThisItemID] ~= nil) then
    local sPopupResult = utils.inputbox("Please enter a description for the item '" .. sEditThisItemID .. "'.\n\n", "Item Edit Description", sItemDBItems[sEditThisItemID]["description"], "", 12 )
    if (sPopupResult ~= nil and sPopupResult ~= "") then
      sItemDBItems[sEditThisItemID]["description"] = sPopupResult
      -- Special description regex search to auto-merge tricky items, like himations, chitons, certain sandals etc.
      for iN = 1, #rexDescriptionChecks do
        iRegexMatch, iLength, sMatchings = rexDescriptionChecks[iN][1]:match(sPopupResult)
        if (iRegexMatch ~= nil and iRegexMatch == 1 and sEditThisItemID ~= rexDescriptionChecks[iN][2]) then
          Note("(auto-renaming due to a description match)")
          QuowRenameItem(sEditThisItemID, rexDescriptionChecks[iN][2])
          sEditThisItemID = rexDescriptionChecks[iN][2]
          return
        end
      end
    elseif (sPopupResult == nil) then
      Note("Item editing for " .. sEditThisItemID .. " cancelled")
      return
    end
    sPopupResult = utils.inputbox("Please enter the appraise data for the item '" .. sEditThisItemID .. "'.\n\n", "Item Edit Appraise", sItemDBItems[sEditThisItemID]["appraise_text"], "", 12 )
    if (sPopupResult ~= nil and sPopupResult ~= "") then
      sItemDBItems[sEditThisItemID]["appraise_text"] = sPopupResult
    elseif (sPopupResult == nil) then
      QuowItemUpdateOrCreate(sEditThisItemID)
      Note("Item editing for " .. sEditThisItemID .. " cancelled (after description done) [DB Updated]")
      return
    end
    sPopupResult = utils.inputbox("Please enter the weight data for the item '" .. sEditThisItemID .. "'.\n\n", "Item Edit Weight", sItemDBItems[sEditThisItemID]["weight"], "", 12 )
    if (sPopupResult ~= nil and sPopupResult ~= "") then
      sItemDBItems[sEditThisItemID]["weight"] = sPopupResult
    elseif (sPopupResult == nil) then
      QuowItemUpdateOrCreate(sEditThisItemID)
      Note("Item editing for " .. sEditThisItemID .. " cancelled (after appraise done) [DB Updated]")
      return
    end
    sPopupResult = utils.inputbox("Please enter the dollar value 0.0 numeric value for '" .. sEditThisItemID .. "'.\n\n", "Item Edit Value", sItemDBItems[sEditThisItemID]["dollar_value"], "", 12 )
    if (sPopupResult ~= nil and sPopupResult ~= "") then
      sItemDBItems[sEditThisItemID]["dollar_value"] = tonumber(sPopupResult)
    elseif (sPopupResult == nil) then
      QuowItemUpdateOrCreate(sEditThisItemID)
      Note("Item editing for " .. sEditThisItemID .. " cancelled (after weight done) [DB Updated]")
      return
    end
    sPopupResult = utils.inputbox("Type a special find note OR enter a full room ID for where it can be picked up for '" .. sEditThisItemID .. "'.\n\n", "Item Edit Special Notes", sItemDBItems[sEditThisItemID]["special_find_note"], "", 12 )
    if (sPopupResult ~= nil and sPopupResult ~= "") then
      sItemDBItems[sEditThisItemID]["special_find_note"] = sPopupResult
    elseif (sPopupResult == nil) then
      QuowItemUpdateOrCreate(sEditThisItemID)
      Note("Item editing for " .. sEditThisItemID .. " cancelled (after dollar value done) [DB Updated]")
      return
    end
    sPopupResult = utils.inputbox("Please enter a map ID value IF this can be searched up for '" .. sEditThisItemID .. "'.\n\n", "Item Edit MapID Search", sItemDBItems[sEditThisItemID]["searchable"], "", 12 )
    if (sPopupResult ~= nil and sPopupResult ~= "") then
      sItemDBItems[sEditThisItemID]["searchable"] = tonumber(sPopupResult)
    elseif (sPopupResult == nil) then
      QuowItemUpdateOrCreate(sEditThisItemID)
      Note("Item editing for " .. sEditThisItemID .. " cancelled (after special find note done) [DB Updated]")
      return
    end
    QuowItemUpdateOrCreate(sEditThisItemID)
    ColourNote(sCOLOUR.red, "", "Item '" .. sEditThisItemID .. "' has been successfully edited. [DB Updated]")

  end -- valid item
end -- edit items

function QuowRenameItem(sRenameThisItemID, sForceRenameToThis)
  local sNewItemName
  if (sForceRenameToThis == nil) then
    sNewItemName = utils.inputbox("Please type a replacement name for the item '" .. sRenameThisItemID .. "'.\n\nLeaving it blank will default to the original item name.", "Item Rename", sRenameThisItemID, "", 12 )
  else
    sNewItemName = sForceRenameToThis
  end
  if (sNewItemName ~= nil and sNewItemName ~= "" and sNewItemName ~= sRenameThisItemID and sItemDBItems[sRenameThisItemID] ~= nil) then
    -- If this is a brand new item, copy the old item data to the new name
    if (sItemDBItems[sNewItemName] == nil) then
      sItemDBItems[sNewItemName] = {}
      sItemDBItems[sNewItemName] = sItemDBItems[sRenameThisItemID]
    else
      -- Rescue data like weight, appraise, notes as appropriate, without erasing anything already in
      if (sItemDBItems[sNewItemName]["description"] == "") then
        sItemDBItems[sNewItemName]["description"] = sItemDBItems[sRenameThisItemID]["description"]
      end
      if (sItemDBItems[sNewItemName]["appraise_text"] == "") then
        sItemDBItems[sNewItemName]["appraise_text"] = sItemDBItems[sRenameThisItemID]["appraise_text"]
      end
      if (sItemDBItems[sNewItemName]["weight"] == "") then
        sItemDBItems[sNewItemName]["weight"] = sItemDBItems[sRenameThisItemID]["weight"]
      end
      if (sItemDBItems[sNewItemName]["dollar_value"] == -1) then
        sItemDBItems[sNewItemName]["dollar_value"] = sItemDBItems[sRenameThisItemID]["dollar_value"]
      end
      if (sItemDBItems[sNewItemName]["searchable"] == 0) then
        sItemDBItems[sNewItemName]["searchable"] = sItemDBItems[sRenameThisItemID]["searchable"]
      end
      if (sItemDBItems[sNewItemName]["special_find_note"] == "") then
        sItemDBItems[sNewItemName]["special_find_note"] = sItemDBItems[sRenameThisItemID]["special_find_note"]
      end
    end
    QuowItemUpdateOrCreate(sNewItemName)

    -- Destroy the original/old item name object altogether
    sItemDBItems[sRenameThisItemID] = {}
    sItemDBItems[sRenameThisItemID] = nil
    assert(dbMap:execute("DELETE FROM items WHERE item_name='" .. EscapeSQL(sRenameThisItemID) .. "'"))

    if (sItemDBShopItems ~= nil) then
      for sKey, sItemData in pairs(sItemDBShopItems) do
        if (sItemDBShopItems[sKey][sRenameThisItemID] ~= nil) then
          sItemDBShopItems[sKey][sNewItemName] = sItemDBShopItems[sKey][sRenameThisItemID]
          sItemDBShopItems[sKey][sRenameThisItemID] = nil
          assert(dbMap:execute("DELETE FROM shop_items WHERE room_id='" .. sKey .. "' AND item_name='" .. EscapeSQL(sRenameThisItemID) .. "'"))
        end
      end
    end

    if (sItemDBNPCItems ~= nil) then
      for sKey, sItemData in pairs(sItemDBNPCItems) do
        if (sItemDBNPCItems[sKey][sRenameThisItemID] ~= nil) then
          sItemDBNPCItems[sKey][sNewItemName] = sItemDBNPCItems[sKey][sRenameThisItemID]
          sItemDBNPCItems[sKey][sRenameThisItemID] = nil
          assert(dbMap:execute("DELETE FROM npc_items WHERE npc_id='" .. EscapeSQL(sKey) .. "' AND item_name='" .. EscapeSQL(sRenameThisItemID) .. "'"))
        end
      end
    end   
    ColourTell(sCOLOUR.orange, "", "Item '" .. sRenameThisItemID .. "' has been successfully renamed to '" .. sNewItemName .. "' [")
    Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteItem(" .. sNewItemName .. ")", "Delete", "Delete this item from the database", sCOLOUR.orange, "", 0)
    ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
    Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sNewItemName .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, "", 0)
    ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
    Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sNewItemName .. ")", "Edit", "Edit this item data in the database", sCOLOUR.orange, "", 0)
    ColourNote(sCOLOUR.orange, "", "]  [DB Updated]")
   
    if (sItemDBItems[sNewItemName]["dollar_value"] == -1) then
      ColourNote(sCOLOUR.orange, "", "Item '" .. sNewItemName .. "' has NO VALUE!")
    else
      ColourNote(sCOLOUR.orange, "", "Item '" .. sNewItemName .. "' value is $" .. sItemDBItems[sNewItemName]["dollar_value"] .. "")
    end
    if (sItemDBItems[sNewItemName]["description"] == "") then
      ColourNote(sCOLOUR.orange, "", "Item '" .. sNewItemName .. "' has NO DESCRIPTION!")
    end
    if (sItemDBItems[sNewItemName]["appraise_text"] == "") then
      ColourNote(sCOLOUR.orange, "", "Item '" .. sNewItemName .. "' has NO APPRAISE!")
    end
    if (sItemDBItems[sNewItemName]["weight"] == "") then
      ColourNote(sCOLOUR.orange, "", "Item '" .. sNewItemName .. "' has NO WEIGHT!")
    end

  end -- Any new name given
end -- Rename items

function QuowItemCommand(sName, sLine, wildcards)
  local sNewItemName = string.sub(sLine, 6)
  local sCheckItemName = FilterItemName(sNewItemName)
  local bNewItemNeeded = false
  if (sItemDBItems[sNewItemName] == nil) then
    bNewItemNeeded = true
    ColourTell(sCOLOUR.red, sAlternatingColour, "Creating whole new item: " .. sNewItemName .. " [")
    sItemDBItems[sNewItemName] = {["description"] = "", ["appraise_text"] = "", ["weight"] = "", ["dollar_value"] = -1.0, ["searchable"] = 0, ["special_find_note"] = ""}
  else
    Tell("Editing data for already existing item: " .. sNewItemName .. " [")
  end
  Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteItem(" .. sNewItemName .. ")", "Delete", "Delete this item from the database", sCOLOUR.orange, sAlternatingColour, 0)
  ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
  Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sNewItemName .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, sAlternatingColour, 0)
  ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
  Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sNewItemName .. ")", "Edit", "Edit this item data in the database", sCOLOUR.orange, sAlternatingColour, 0)
  Note("]")

  if (sLastNPCCodeViewed ~= nil and sLastNPCCodeViewed ~= "" and sNPCs[sLastNPCCodeViewed] ~= nil and (sItemDBNPCItems[sLastNPCCodeViewed] == nil or sItemDBNPCItems[sLastNPCCodeViewed][sNewItemName] == nil)) then
    if (sItemDBNPCItems[sLastNPCCodeViewed] == nil) then
      sItemDBNPCItems[sLastNPCCodeViewed] = {}
    end
    sItemDBNPCItems[sLastNPCCodeViewed][sNewItemName] = ""
    local sSaveSQL = "INSERT OR REPLACE INTO npc_items (npc_id, item_name, sale_price) VALUES " ..
      "('" .. EscapeSQL(sLastNPCCodeViewed) .. "', '" .. EscapeSQL(sNewItemName) .. "', '')"
    assert(dbMap:execute(sSaveSQL))
    Tell("Added: " .. sNewItemName .. " | to NPC " .. sLastNPCCodeViewed .. " [")
    Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteNPCItem(" .. sNewItemName .. ")", "DeleteNPC", "Delete this item from this NPC", sCOLOUR.orange, sAlternatingColour, 0)
    Note("] [DB Updated]")
  end

  local sPopupResult = utils.inputbox("Please enter a description for the item '" .. sNewItemName .. "'.\n\n", "Item Edit Description", sItemDBItems[sNewItemName]["description"], "", 12 )
  if (sPopupResult ~= nil and sPopupResult ~= "") then
    sItemDBItems[sNewItemName]["description"] = sPopupResult
  elseif (sPopupResult == nil) then
    if (bNewItemNeeded == true) then
      QuowItemUpdateOrCreate(sNewItemName)
      Note("Item editing for " .. sNewItemName .. " cancelled [DB Updated - new item]")
    else
      Note("Item editing for " .. sNewItemName .. " cancelled")
    end
    return
  end
  sPopupResult = utils.inputbox("Please enter the appraise data for the item '" .. sNewItemName .. "'.\n\n", "Item Edit Appraise", sItemDBItems[sNewItemName]["appraise_text"], "", 12 )
  if (sPopupResult ~= nil and sPopupResult ~= "") then
    sItemDBItems[sNewItemName]["appraise_text"] = sPopupResult
  elseif (sPopupResult == nil) then
    QuowItemUpdateOrCreate(sNewItemName)
    Note("Item editing for " .. sNewItemName .. " cancelled (after description done) [DB Updated]")
    return
  end
  sPopupResult = utils.inputbox("Please enter the weight data for the item '" .. sNewItemName .. "'.\n\n", "Item Edit Weight", sItemDBItems[sNewItemName]["weight"], "", 12 )
  if (sPopupResult ~= nil and sPopupResult ~= "") then
    sItemDBItems[sNewItemName]["weight"] = sPopupResult
  elseif (sPopupResult == nil) then
    QuowItemUpdateOrCreate(sNewItemName)
    Note("Item editing for " .. sNewItemName .. " cancelled (after appraise done) [DB Updated]")
    return
  end
  sPopupResult = utils.inputbox("Please enter the dollar value 0.0 numeric value for '" .. sNewItemName .. "'.\n\n", "Item Edit Value", sItemDBItems[sNewItemName]["dollar_value"], "", 12 )
  if (sPopupResult ~= nil and sPopupResult ~= "") then
    sItemDBItems[sNewItemName]["dollar_value"] = tonumber(sPopupResult)
  elseif (sPopupResult == nil) then
    QuowItemUpdateOrCreate(sNewItemName)
    Note("Item editing for " .. sNewItemName .. " cancelled (after weight done) [DB Updated]")
    return
  end
  sPopupResult = utils.inputbox("Type a special find note OR enter a full room ID for where it can be picked up for '" .. sNewItemName .. "'.\n\n", "Item Edit Special Notes", sItemDBItems[sNewItemName]["special_find_note"], "", 12 )
  if (sPopupResult ~= nil and sPopupResult ~= "") then
    sItemDBItems[sNewItemName]["special_find_note"] = sPopupResult
  elseif (sPopupResult == nil) then
    QuowItemUpdateOrCreate(sNewItemName)
    Note("Item editing for " .. sNewItemName .. " cancelled (after dollar value done) [DB Updated]")
    return
  end
  sPopupResult = utils.inputbox("Please enter a map ID value IF this can be searched up for '" .. sNewItemName .. "'.\n\n", "Item Edit MapID Search", sItemDBItems[sNewItemName]["searchable"], "", 12 )
  if (sPopupResult ~= nil and sPopupResult ~= "" and tonumber(sPopupResult) ~= nil and tonumber(sPopupResult) > 0 and sQuowMapfiles[tonumber(sPopupResult)] ~= nil) then
    sItemDBItems[sNewItemName]["searchable"] = tonumber(sPopupResult)
  elseif (sPopupResult == nil) then
    QuowItemUpdateOrCreate(sNewItemName)
    Note("Item editing for " .. sNewItemName .. " cancelled (after special find note done) [DB Updated]")
    return
  end
  QuowItemUpdateOrCreate(sNewItemName)
  Note("Item editing/creation for " .. sNewItemName .. " finished! [DB Updated]")
end -- Create new items or edit full data of one

-- Rename a user location bookmark
function QuowRenameBookmark(sRenameThisBookmarkID)
  sSQL = ""
  if (sQuowUserBookmarks[sRenameThisBookmarkID] ~= nil) then
    local sPopupResult = utils.inputbox("Please type a replacement name for the room '" .. sQuowLocationsByRoomID[sRenameThisBookmarkID][4] .. "'.\n\nLeaving it blank will default to the original room name.", "Bookmark Rename", sQuowUserBookmarks[sRenameThisBookmarkID], "", 12 )
    if (sPopupResult ~= nil) then
      sSQL = "UPDATE bookmarks SET note='" .. EscapeSQL(sPopupResult) .. "' WHERE room_id='" .. sRenameThisBookmarkID .. "'"
      assert(dbUserData:execute(sSQL))

      --Reorder alphabetically
      sSortedBookmarks = {}
      for row in dbUserData:nrows("SELECT room_id, note FROM bookmarks") do
        if (sQuowLocationsByRoomID[row.room_id] ~= nil) then
          table.insert(sSortedBookmarks, {row.room_id, row.note})
        end
      end
      table.sort(sSortedBookmarks, QuowBookmarkCompare)

      sQuowUserBookmarks[sRenameThisBookmarkID] = sPopupResult
        if (sPopupResult == "") then
        ColourTell(sCOLOUR.silver, "", "The bookmarked room '")
        ColourTell(sCOLOUR.orange, "", sQuowLocationsByRoomID[sRenameThisBookmarkID][4])
        ColourNote(sCOLOUR.silver, "", "' name has been set to the original room name.")
      else
        ColourTell(sCOLOUR.silver, "", "The bookmarked room '")
        ColourTell(sCOLOUR.orange, "", sQuowLocationsByRoomID[sRenameThisBookmarkID][4])
        ColourTell(sCOLOUR.silver, "", "' has been renamed to '")
        ColourTell(sCOLOUR.orange, "", sPopupResult)
        ColourNote(sCOLOUR.silver, "", "'")
      end
    else
      ColourTell(sCOLOUR.silver, "", "The bookmarked room '")
      ColourTell(sCOLOUR.orange, "", sQuowLocationsByRoomID[sRenameThisBookmarkID][4])
      ColourNote(sCOLOUR.silver, "", "' has not been renamed.")
    end
  end
end


-- Rename a user location bookmark
function QuowRenameCommandBookmark(sRenameThisBookmarkID, sPopupResult)
  sSQL = ""
  if (sQuowUserBookmarks[sRenameThisBookmarkID] ~= nil) then
    if (sPopupResult ~= nil) then
      sSQL = "UPDATE bookmarks SET note='" .. EscapeSQL(sPopupResult) .. "' WHERE room_id='" .. sRenameThisBookmarkID .. "'"
      assert(dbUserData:execute(sSQL))

      --Reorder alphabetically
      sSortedBookmarks = {}
      for row in dbUserData:nrows("SELECT room_id, note FROM bookmarks") do
        if (sQuowLocationsByRoomID[row.room_id] ~= nil) then
          table.insert(sSortedBookmarks, {row.room_id, row.note})
        end
      end
      table.sort(sSortedBookmarks, QuowBookmarkCompare)

      sQuowUserBookmarks[sRenameThisBookmarkID] = sPopupResult
      if (sPopupResult == "" or sPopupResult == " ") then
        ColourTell(sCOLOUR.silver, "", "The bookmarked room '")
        ColourTell(sCOLOUR.orange, "", sQuowLocationsByRoomID[sRenameThisBookmarkID][4])
        ColourNote(sCOLOUR.silver, "", "' name has been set to the original room name.")
      else
        ColourTell(sCOLOUR.silver, "", "The bookmarked room '")
        ColourTell(sCOLOUR.orange, "", sQuowLocationsByRoomID[sRenameThisBookmarkID][4])
        ColourTell(sCOLOUR.silver, "", "' has been renamed to '")
        ColourTell(sCOLOUR.orange, "", sPopupResult)
        ColourNote(sCOLOUR.silver, "", "'")
      end
    else
      ColourTell(sCOLOUR.silver, "", "The bookmarked room '")
      ColourTell(sCOLOUR.orange, "", sQuowLocationsByRoomID[sRenameThisBookmarkID][4])
      ColourNote(sCOLOUR.silver, "", "' has not been renamed.")
    end
  end
end


-- Delete a user location bookmark
function QuowDeleteBookmark(sDeleteThisBookmarkID)
  sSQL = ""
  if (sQuowUserBookmarks[sDeleteThisBookmarkID] ~= nil) then
    sSQL = "DELETE FROM bookmarks WHERE room_id='" .. sDeleteThisBookmarkID .. "'"
    assert(dbUserData:execute(sSQL))
    if (sQuowLocationsByRoomID[sDeleteThisBookmarkID] ~= nil) then
      ColourTell(sCOLOUR.silver, "", "The bookmark for '")
      ColourTell(sCOLOUR.orange, "", sQuowLocationsByRoomID[sDeleteThisBookmarkID][4])
      ColourNote(sCOLOUR.silver, "", "' has been removed from your list.")
    end
    sQuowUserBookmarks[sDeleteThisBookmarkID] = nil
    --Reorder alphabetically
    sSortedBookmarks = {}
    for row in dbUserData:nrows("SELECT room_id, note FROM bookmarks") do
      if (sQuowLocationsByRoomID[row.room_id] ~= nil) then
        table.insert(sSortedBookmarks, {row.room_id, row.note})
      end
    end
    table.sort(sSortedBookmarks, QuowBookmarkCompare)
  end
end


-- Create a user location bookmark
sLastCreatedBookmarkID = ""
function QuowCreateBookmark(sCreateThisBookmarkID)
  sSQL = ""
  if (sQuowLocationsByRoomID[sCreateThisBookmarkID] ~= nil and sQuowUserBookmarks[sCreateThisBookmarkID] == nil) then
    sQuowUserBookmarks[sCreateThisBookmarkID] = sQuowLocationsByRoomID[sCreateThisBookmarkID][4]
    sSQL = "INSERT INTO bookmarks VALUES ('" .. sCreateThisBookmarkID .. "', '" .. EscapeSQL(sQuowLocationsByRoomID[sCreateThisBookmarkID][4])  .. "')"
    assert(dbUserData:execute(sSQL))

    --Reorder alphabetically
    sSortedBookmarks = {}
    for row in dbUserData:nrows("SELECT room_id, note FROM bookmarks") do
      if (sQuowLocationsByRoomID[row.room_id] ~= nil) then
        table.insert(sSortedBookmarks, {row.room_id, row.note})
      end
    end
    table.sort(sSortedBookmarks, QuowBookmarkCompare)

    ColourTell(sCOLOUR.silver, "", "A new bookmark has been added for '")
    Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameBookmark(" .. sCreateThisBookmarkID .. ")", sQuowLocationsByRoomID[sCreateThisBookmarkID][4], "Rename the room for this bookmark", sCOLOUR.orange, "", 0)
    ColourTell(sCOLOUR.silver, "", "' (")
    Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameBookmark(" .. sCreateThisBookmarkID .. ")", "click to rename", "Rename the room for this bookmark", sCOLOUR.orange, "", 0)
    ColourNote(sCOLOUR.silver, "", ").  Type 'minimap bookmarks' to view them.")
    -- Screenreader users need a text command to rename
    if (bScreenreader == true) then
      ColourNote(sCOLOUR.silver, "", "Type 'minimap renamelast <insert custom name>' to rename the last created bookmark to the given name.")
    end
    sLastCreatedBookmarkID = sCreateThisBookmarkID
  elseif (sQuowUserBookmarks[sCreateThisBookmarkID] ~= nil) then
    ColourNote(sCOLOUR.silver, "", "Unable to create new bookmark - bookmark already exists for this room.")
  end
end


-- Display room-info in-client
function QuowShowRoomInfo(sDisplayThisRoomID, bShowShopUniques)
  if (sQuowLocationsByRoomID[sDisplayThisRoomID] ~= nil) then
    Note("")
    Tell("[")
    ColourTell(sCOLOUR.orange, "", sQuowLocationsByRoomID[sDisplayThisRoomID][4])
    Note("]")
    if (bDebugMode == true) then
      Tell("Room ID: ")
      ColourNote(sCOLOUR.silver, "", sDisplayThisRoomID)
    end
    if (sQuowUserBookmarks[sDisplayThisRoomID] ~= nil and sQuowUserBookmarks[sDisplayThisRoomID] ~= "") then
      Tell("Bookmarked as: '")
      ColourTell(sCOLOUR.cyan, "", sQuowUserBookmarks[sDisplayThisRoomID])
      Note("'")
    end
    Tell("Room Type: ")
    ColourNote(sCOLOUR.silver, "", sQuowLocationsByRoomID[sDisplayThisRoomID][5])
    Tell("Map Region: ")
    ColourNote(sCOLOUR.silver, "", sQuowMapfiles[sQuowLocationsByRoomID[sDisplayThisRoomID][1]][2])
    Tell("Share Command: '")
    ColourTell(sCOLOUR.silver, "", "minimap {" .. sQuowLocationsByRoomID[sDisplayThisRoomID][1] .. ", " .. sQuowLocationsByRoomID[sDisplayThisRoomID][2] .. ", " .. sQuowLocationsByRoomID[sDisplayThisRoomID][3] .. "}")
    Note("'")
    Tell("Recognised room exits: ")
    local bDoComma = false
    for sKey, sData in pairs(sQuowExitsByExit[sDisplayThisRoomID]) do
      if (bDoComma == true) then
        Tell(", ")
      end
      ColourTell(sCOLOUR.silver, "", sKey)
      bDoComma = true
    end
    if (bDoComma == false) then
      Tell("(no known exits)")
    end
    Note("")
    local iAnyFinds = 0
    local iAlternator = 1
    -- Now we look for NPCs stood in this location
    local sNPCData
    local sNPCDataResults = {}
    -- First build a list of results
    for sKey, sNPCData in pairs(sNPCs) do
      if (sNPCData["roomid"] ~= nil and sNPCData["roomid"] == sDisplayThisRoomID) then
        table.insert(sNPCDataResults, {sKey, string.lower(sNPCData["npc_name"])})
      end
    end
    -- Attempt to sort the table
    table.sort(sNPCDataResults, QuowSearchCompare)

    -- Now render that list
    for _, sKey in ipairs(sNPCDataResults) do
      sNPCData = sNPCs[sKey[1]]
      iAnyFinds = iAnyFinds + 1
      if (iAnyFinds > 50) then
        Note("  [cutting npc list short, more than 50 NPCs marked at location]")
        iAnyFinds = iAnyFinds - 1
        break
      end
      if (iAnyFinds == 1) then
        sMinimapNPCResults = {}
        Note("")
        Note("NPCs seen or marked at this location:")
      end
      iAlternator = 1 - iAlternator
      if (iAlternator == 0) then
        sAlternatingColour = ""
      else
        sAlternatingColour = sCOLOUR.offblack
      end
      ColourTell(sCOLOUR.silver, sAlternatingColour, string.format("%2d", iAnyFinds))
      sMinimapNPCResults[iAnyFinds] = sKey[1]
      if (bScreenreader == false) then
        ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowNPCDetails(" .. sKey[1] .. ")", "Details", "Show details of this NPC (" .. sNPCData["npc_name"] .. ")", sCOLOUR.orange, sAlternatingColour, 0)
      else
        ColourTell(sCOLOUR.silver, sAlternatingColour, ": ")
      end
      -- Links for editing the items in editing debug mode
      if (bDebugMode == true and bCreatingRooms == true) then
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowAdminNPCCommand(" .. sNPCs[sKey[1]]["npc_name"] .. ")", "NPC", "Snap to this NPC for database updating", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteNPC(" .. sKey[1] .. ")", "Delete", "Delete this npc from the database", sCOLOUR.orange, sAlternatingColour, 0)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
        Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameNPC(" .. sKey[1] .. ")", "Rename", "Rename this npc in the database", sCOLOUR.orange, sAlternatingColour, 0)
      end
      if (bScreenreader == false) then
        ColourTell(sCOLOUR.grey, sAlternatingColour, "] : ")
      end
      ColourTell(sCOLOUR.cyan, sAlternatingColour, sNPCData["npc_name"])
      Note("")
    end
    sNPCDataResults = nil

    -- And now onto items for sale in this possible-shop building (if it is one)
    iAnyFinds = 0
    iAlternator = 1
    -- Any items for sale in this shop-building?
    if (sItemDBShopItems[sDisplayThisRoomID] ~= nil) then
      local sItemData, sItemName
      local sItemDataResults = {}
      -- First build a list of results
      if (bShowShopUniques == nil) then
        for sItemName, sItemPrice in pairs(sItemDBShopItems[sDisplayThisRoomID]) do
          table.insert(sItemDataResults, {sItemName, string.lower(sItemName)})
        end
      else
        -- Unique to this shop only
        local bIsUnique = false
        for sItemName, sItemPrice in pairs(sItemDBShopItems[sDisplayThisRoomID]) do
          bIsUnique = true
          -- Search all other shops for this item
          for sRawShopKey, sRawItemData in pairs(sItemDBShopItems) do
            if (sRawShopKey ~= sDisplayThisRoomID and sItemDBShopItems[sRawShopKey][sItemName] ~= nil) then
              bIsUnique = false
              break
            end
          end
          -- Search all NPCs for this item
          for sRawNPCKey, sRawItemData in pairs(sItemDBNPCItems) do
            if (sItemDBNPCItems[sRawNPCKey][sItemName] ~= nil) then
              bIsUnique = false
              break
            end
          end
          if (bIsUnique == true) then
            table.insert(sItemDataResults, {sItemName, string.lower(sItemName)})
          end
        end
      end
      -- Attempt to sort the table
      table.sort(sItemDataResults, QuowSearchCompare)

      for _, sItemData in pairs(sItemDataResults) do
        sItemName = sItemData[1]
        iAnyFinds = iAnyFinds + 1

        if (iAnyFinds > iSearchResultLimit) then
          Note("  [cutting sale list at " .. iSearchResultLimit .. ", shop has " .. #sItemDataResults .. " items total]")
          iAnyFinds = iAnyFinds - 1
          break
        end

        if (iAnyFinds == 1) then
          sMinimapItemResults = {}
          Note("")
          if (bShowShopUniques == nil) then
            Note("Items seen for sale in this shop:")
          else
            ColourNote(sCOLOUR.silver, "", "Items exclusive to this shop found nowhere else:")
          end
        end

        sMinimapItemResults[iAnyFinds] = sItemName

        iAlternator = 1 - iAlternator
        if (iAlternator == 0) then
          sAlternatingColour = ""
        else
          sAlternatingColour = sCOLOUR.offblack
        end

        ColourTell(sCOLOUR.silver, sAlternatingColour, "   " .. string.format("%2d", iAnyFinds))
        if (bScreenreader == false) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, " [")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowItemDetails(" .. sItemName .. ")", "Details", "Show detailed info such as where item might be found, appraise info etc. for this item.", sCOLOUR.orange, sAlternatingColour, 0)
        else
          ColourTell(sCOLOUR.silver, sAlternatingColour, ": ")
        end
        -- Links for editing the items in editing debug mode
        if (bDebugMode == true and bCreatingRooms == true) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteShopStockItem(" .. sItemName .. ")", "DeleteShop", "Delete this item from this shop", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowChangeShopPrice(" .. sItemName .. ")", "Price", "Change the shop price", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowDeleteItem(" .. sItemName .. ")", "Delete", "Delete this item from the database", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameItem(" .. sItemName .. ")", "Rename", "Rename this item in the database", sCOLOUR.orange, sAlternatingColour, 0)
          ColourTell(sCOLOUR.grey, sAlternatingColour, " | ")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowEditItem(" .. sItemName .. ")", "Edit", "Edit this item data in the database", sCOLOUR.orange, sAlternatingColour, 0)
        end
        if (bScreenreader == false) then
          ColourTell(sCOLOUR.grey, sAlternatingColour, "] ")
        end
        ColourTell(sCOLOUR.cyan, sAlternatingColour, sItemName)
        ColourTell(sCOLOUR.grey, sAlternatingColour, " @ ")
        ColourTell(sCOLOUR.cyan, sAlternatingColour, sItemDBShopItems[sDisplayThisRoomID][sItemName])

        Note("")
      end
      sItemDataResults = nil
    end
    if (iAnyFinds == 0) then
      Note("")
      if (bShowShopUniques == nil) then
        ColourNote(sCOLOUR.silver, "", "No recorded standard shop inventory.")
      else
        ColourNote(sCOLOUR.silver, "", "This shop sells items, but has no exclusive items (items found nowhere else).")
      end
    end
    if (bScreenreader == false) then
      Note("-- End of room info --")
    else
      ColourNote(sCOLOUR.orange, "", "End of room info")
    end
  else
    Note("Unable to display room data.  Click on a valid room, or use the 'minimap <num>' command on a valid result.")
  end
end


-- Snap map back to "old" co-ordinates
function QuowOldSnap()
  -- Snap back to "old" co-ordinates
  iMyX = iOldMX
  iMyY = iOldMY
  iCurMap = iOldMap
  sCurrentMap = sOldMap
  RedrawMap()
  Repaint()
end

-- *************************************
-- ***** Currency conversion stuff *****
-- *************************************
-- Note:  Just a future idea, no work done on this yet!
--[[
-- LC 8|9|8 1/2
-- LH 1|2|3|4|5 1/4
-- 1,2,3,4Gd
-- Gd, Gf, Gl or Gc
-- DjToon 611.10
-- PPM

-- 1 dollar = 400
-- 
     Lancre         Farthing 3, Ha'penny 6, Penny 12, Tuppence 24,
                    Thruppence 36, Sixpence 72, Shilling 144, Crown 1728,
                    Tencrown 17280, Sovereign 20736, Hedgehog 248832

     Agatean Empire Saveloy-rhinu 4, Quarter-rhinu 120, Half-rhinu 240,
                    Rhinu 480, Ten-rhinu 4800, Fifty-rhinu 24000

     Ankh-Morpork   Penny 4, Ten-pence 40, Half-Dollar 200, Dollar 400,
                    Ten-Dollar 4000, Royal 40000, Crown 3200000

     Djelibeybi     Ptascp 2, Talon 20, Toon 200, Talent 2000, Ra 20000,
                    Thanra 100000
     Ephebe         Derechmus 2, Hemiobolus 8, Obolus 16, Drachma 96,
                    Stater 192, Decadrachma 960, Mina 9600, Tyrant 96000
     Genua          Cent 3, Livre 300, Forin 3000, Ducat 30000

     Klatch         Para 5, Two Para 10, Five Para 25, Ten Para 50, Fifty
                    Para 250, Dinar 500, Two Dinar 1000, Five Dinar 2500,
                    Ten Dinar 5000, Fifty Dinar 25000, Hundred Dinar 50000,
                    Thousand Dinar 500000, Toman 5000000

--]]
rexCurrencies = {
  {rex.new("^DjToon $"), "DJB"},
}
function ConvertCurrencyString(sCurrencyString)
 -- Nothing, ever!?
end

-- ********************************************************************
-- ***** Redraw the visible graphical map window and all contents *****
-- ********************************************************************

iZoomData = {
  -- Mode, Transform, Reverse, Title
  [1] = {2, 100/50, 50/100,   "50%",  {-1, -1, 2, 2}}, -- 50% 
  [2] = {2, 100/75, 75/100,   "75%",  {-1, -1, 4, 4}}, -- 75% 
  [3] = {1, 1,      1,        "100%", {-2, -2, 4, 4}}, -- 100% 
  [4] = {2, 100/150, 150/100, "150%", {-2, -2, 7, 7}}, -- 150% 
  [5] = {2, 100/200, 200/100, "200%", {-3, -4, 9, 8}}, -- 200% 
  [6] = {2, 100/300, 300/100, "300%", {-4, -4, 13, 13}}, -- 300% 
  [7] = {2, 100/400, 400/100, "400%", {-5, -5, 15, 15}}, -- 400% 
}
iMapWinIndent = 0
sMapWinTitle = ""
iUseMap = 0
function RedrawMap()
  -- Save effort, do nothing if not showing this window
  if (WINDATA[winMinimap]["SHOW"] == false or bMinimapHidden == true) then
    return
  end

  -- Zoom transform handling
  local iZoomTransform = iZoomData[iUseZoom][2]

  -- Handle any queue map-shift?
  local iShiftX = 0
  local iShiftY = 0
  iUseMap = iCurMap
  for iKey, sShiftData in ipairs(iMapShiftQueue) do
    iShiftX = iShiftX + sShiftData[1]
    iShiftY = iShiftY + sShiftData[2]
    iUseMap = sShiftData[4]
  end

  if (iUseMap == 0 or sQuowMapfiles[iUseMap] == nil) then
    -- Clear the map window all black/white
    WindowRectOp (winMinimap, 2, 0, winThemeData.TITLE_HEIGHT, MINIMAP_WIDTH, WINDATA[winMinimap]["HEIGHT"], sQuowMapfiles[iCurMap][9])
    -- Draw a border so we can see the window clearly when a map graphic isn't being displayed
    WindowRectOp(winMinimap, miniwin.rect_frame, 0, winThemeData.TITLE_HEIGHT, WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"], winThemeData.WINDOW_BORDER)
    -- Update Disc game date if needed
    if (bShowDiscDate == true) then
      DrawDiscDate(false)
    end
    -- Change brightness of the maps window
    if (iMinimapBrightness < 100) then
      WindowFilter (winMinimap, 0, winThemeData.TITLE_HEIGHT, MINIMAP_WIDTH, WINDATA[winMinimap]["HEIGHT"], 21, (iMinimapBrightness / 100)) -- halve the brightness
    end
    WindowText (winMinimap, "bodyfont", "(unknown location)", 2, winThemeData.TITLE_HEIGHT + 2, 0, 0, iCOLOUR.black)
    -- And quit this function now since we don't even know where we are!
    return
  end

  -- Get the file-path of this map we're on
  sCurrentMap = sQuowMapfiles[iUseMap][1]

  -- Handle player-positioning based on predictive-moves
  local iTransX = iMyX + iShiftX
  local iTransY = iMyY + iShiftY

  -- Get the pixel-positions of our graphical render, transformed by zoom level
  local iZoomShiftX = math.floor(MINIMAP_CX * iZoomTransform)
  local iZoomShiftY = math.floor(MINIMAP_CY * iZoomTransform)
  local iDrawXLeft = iTransX - iZoomShiftX
  local iDrawYTop = iTransY - iZoomShiftY
  local iDrawXRight = iTransX + iZoomShiftX
  local iDrawYBottom = iTransY + iZoomShiftY

  -- Handle map file changes
  if (sLoadedMap ~= sCurrentMap) then
    if (TACR and sQuowMapfiles[iUseMap][8] == false) then
      WindowLoadImage (winMapRender, "QuowImg" .. sCurrentMap, sQuowMapPath .. sCurrentMap)
      sQuowMapfiles[iUseMap][8] = true
    end
    sLoadedMap = sCurrentMap
    if (iUseZoom == 3) then
      sMapWinTitle = sQuowMapfiles[iUseMap][2]
    else
      sMapWinTitle = sQuowMapfiles[iUseMap][2] .. " @ " .. iZoomData[iUseZoom][4]
    end
    iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
    RetitleWindow(winMinimap, sMapWinTitle)
  end

  if (sLoadedMap ~= "") then    
    -- Clear the map window all black/white
    WindowRectOp (winMapRender, 2, 0, 0, 0, 0, sQuowMapfiles[iCurMap][9])
    -- Render the map as appropriate
    if (bDrawSkeletonMode == false or iCurMap == 47 or iCurMap == 8) then
      WindowDrawImage (winMapRender, "QuowImg" .. sCurrentMap, 0, 0, 0, 0, 1, iDrawXLeft, iDrawYTop, iDrawXRight, iDrawYBottom)
    end

    -- Draw all known rooms found rooms mapped rooms on the map
    if (bCreatingRooms == true or bDrawSkeletonMode == true) then
      local iTX = 0
      local iTY = 0
      local iRoomColour = 42495
      for sKey, sRoomID in pairs(sQuowLocationsByRoomID) do
        if (sRoomID[1] == iUseMap) then
          if (sRoomID[2] >= iDrawXLeft and sRoomID[2] <= iDrawXRight and sRoomID[3] >= iDrawYTop and sRoomID[3] <= iDrawYBottom) then
            iTX = sRoomID[2] - iDrawXLeft
            iTY = sRoomID[3] - iDrawYTop
            -- Draw exits?
            if (bDrawSkeletonMode == true) then
              for sExit, sData in pairs(sQuowExitsByExit[sKey]) do
                if (sQuowLocationsByRoomID[sData][1] == iUseMap and sQuowLocationsByRoomID[sData][2] >= iDrawXLeft and sQuowLocationsByRoomID[sData][2] <= iDrawXRight and sQuowLocationsByRoomID[sData][3] >= iDrawYTop and sQuowLocationsByRoomID[sData][3] <= iDrawYBottom) then
                  WindowLine (winMapRender, iTX, iTY, sQuowLocationsByRoomID[sData][2] - iDrawXLeft, sQuowLocationsByRoomID[sData][3] - iDrawYTop, 16711680, 0, 1)
                end
              end -- Loop through exits
              -- Draw room - shop, else indoor/outdoor
              if (sItemDBShopItems[sKey] ~= nil) then
                iRoomColour = 16748574
              else
                -- Draw room
                if (sQuowLocationsByRoomID[sKey][5] == "outside") then
                  iRoomColour = 42495
                else
                  iRoomColour = 16711935
                end
              end
              if (iUseMap == 99) then
                WindowRectOp (winMapRender, 2, iTX, iTY, iTX+1, iTY+1, iRoomColour)
              else
                WindowRectOp (winMapRender, 2, iTX-2, iTY-2, iTX+4, iTY+4, iRoomColour)
              end
            else
              -- Draw smaller room
              if (iUseMap == 99) then
                WindowRectOp (winMapRender, 2, iTX, iTY, iTX+1, iTY+1, 42495)
              else
                WindowRectOp (winMapRender, 2, iTX-1, iTY-1, iTX+3, iTY+3, 42495)
              end
            end
          end
        end
      end
    end

    if (iUseMap == 47) then
      -- UU Library draw directional arrow
      if (sLastDir == "n" or sLastDir == "north") then
        WindowLine (winMapRender, iZoomShiftX - 7, iZoomShiftY, iZoomShiftX, iZoomShiftY - 7, 16711680, 0, 5)
        WindowLine (winMapRender, iZoomShiftX + 7, iZoomShiftY, iZoomShiftX, iZoomShiftY - 7, 16711680, 0, 5)
      elseif (sLastDir == "e" or sLastDir == "east") then
        WindowLine (winMapRender, iZoomShiftX, iZoomShiftY - 7, iZoomShiftX + 7, iZoomShiftY, 16711680, 0, 5)
        WindowLine (winMapRender, iZoomShiftX, iZoomShiftY + 7, iZoomShiftX + 7, iZoomShiftY, 16711680, 0, 5)
      elseif (sLastDir == "s" or sLastDir == "south") then
        WindowLine (winMapRender, iZoomShiftX - 7, iZoomShiftY, iZoomShiftX, iZoomShiftY + 7, 16711680, 0, 5)
        WindowLine (winMapRender, iZoomShiftX + 7, iZoomShiftY, iZoomShiftX, iZoomShiftY + 7, 16711680, 0, 5)
      elseif (sLastDir == "w" or sLastDir == "west") then
        WindowLine (winMapRender, iZoomShiftX, iZoomShiftY - 7, iZoomShiftX - 7, iZoomShiftY, 16711680, 0, 5)
        WindowLine (winMapRender, iZoomShiftX, iZoomShiftY + 7, iZoomShiftX - 7, iZoomShiftY, 16711680, 0, 5)
      end
    end

    -- Current map centre and ghost
    if (bDrawSkeletonMode == true and iCurMap ~= 47 and iCurMap ~= 8) then
      -- Larger for skeleton mode else it's hard to see
      -- Ghost
      if (iCharLocMap == iCurMap and (bShowGhost == true or iCurMap == 47 or iCurMap == 8) and iCatchupX >= iDrawXLeft and iCatchupX <= iDrawXRight and iCatchupY >= iDrawYTop and iCatchupY <= iDrawYBottom and (iCatchupX ~= iTransX or iCatchupY ~= iTransY)) then
        WindowRectOp (winMapRender, 2, (iCatchupX - iDrawXLeft)-3, (iCatchupY - iDrawYTop)-3, (iCatchupX - iDrawXLeft)+5, (iCatchupY - iDrawYTop)+5, iMapDotColour)
      end
      -- Centre
      WindowRectOp (winMapRender, 2, iZoomShiftX-3, iZoomShiftY-3, iZoomShiftX+5, iZoomShiftY+5, 0)
    else
      -- Not in skeleton mode, or on Shades or Library (no skeleton possible) maps, so normal-sized
      -- Centre, terrains map or normal map, crosshair or no crosshair
      if (iCurMap == 99) then
        -- Ghost
        if (iCharLocMap == iCurMap and (bShowGhost == true or iCurMap == 47 or iCurMap == 8) and iCatchupX >= iDrawXLeft and iCatchupX <= iDrawXRight and iCatchupY >= iDrawYTop and iCatchupY <= iDrawYBottom and (iCatchupX ~= iTransX or iCatchupY ~= iTransY)) then
          WindowRectOp (winMapRender, 2, (iCatchupX - iDrawXLeft), (iCatchupY - iDrawYTop), (iCatchupX - iDrawXLeft)+1, (iCatchupY - iDrawYTop)+1, 42495)
        end
        -- Main
        if (bCentreCrosshair == true) then
          WindowLine (winMapRender, iZoomShiftX-20, iZoomShiftY, iZoomShiftX-1, iZoomShiftY, iMapDotColour, 0, 1)
          WindowLine (winMapRender, iZoomShiftX+2, iZoomShiftY, iZoomShiftX+20, iZoomShiftY, iMapDotColour, 0, 1)
          WindowLine (winMapRender, iZoomShiftX, iZoomShiftY-20, iZoomShiftX, iZoomShiftY-1, iMapDotColour, 0, 1)
          WindowLine (winMapRender, iZoomShiftX, iZoomShiftY+2, iZoomShiftX, iZoomShiftY+20, iMapDotColour, 0, 1)
        else
          WindowRectOp (winMapRender, 2, iZoomShiftX-1, iZoomShiftY-1, iZoomShiftX+2, iZoomShiftY+2, iMapDotColour)
        end
      else
        -- Ghost
        if (iCharLocMap == iCurMap and (bShowGhost == true or iCurMap == 47 or iCurMap == 8) and iCatchupX >= iDrawXLeft and iCatchupX <= iDrawXRight and iCatchupY >= iDrawYTop and iCatchupY <= iDrawYBottom and (iCatchupX ~= iTransX or iCatchupY ~= iTransY)) then
          WindowRectOp (winMapRender, 2, (iCatchupX - iDrawXLeft)-2, (iCatchupY - iDrawYTop)-2, (iCatchupX - iDrawXLeft)+4, (iCatchupY - iDrawYTop)+4, 42495)
        end
        -- Main
        if (bCentreCrosshair == true) then
          WindowLine (winMapRender, iZoomShiftX-20, iZoomShiftY, iZoomShiftX-5, iZoomShiftY, iMapDotColour, 0, 3)
          WindowLine (winMapRender, iZoomShiftX+5, iZoomShiftY, iZoomShiftX+20, iZoomShiftY, iMapDotColour, 0, 3)
          WindowLine (winMapRender, iZoomShiftX, iZoomShiftY-20, iZoomShiftX, iZoomShiftY-5, iMapDotColour, 0, 3)
          WindowLine (winMapRender, iZoomShiftX, iZoomShiftY+5, iZoomShiftX, iZoomShiftY+20, iMapDotColour, 0, 3)
        end
        WindowRectOp (winMapRender, 2, iZoomShiftX-2, iZoomShiftY-2, iZoomShiftX+4, iZoomShiftY+4, iMapDotColour)
      end
    end
  end

  -- Draw an escaped spell orb in the UU Library
  if (bDrawOrbs == true and iCurMap == 47 and iOrbSizeHere ~= 0 and (sThisRoomTitle == "Library" or sThisRoomTitle == "UULibraryExit" or sThisRoomTitle == "UULibraryGap")) then
    WindowCircleOp (winMapRender, 1, (iCatchupX - iDrawXLeft) - iOrbSizeHere, (iCatchupY - iDrawYTop) - iOrbSizeHere, (iCatchupX - iDrawXLeft) + iOrbSizeHere, (iCatchupY - iDrawYTop) + iOrbSizeHere, iCOLOUR.orange, 0, 2, iCOLOUR.black, 0)
  end

  -- Draw a distortion in the UU Library
  if (iCurMap == 47 and iDistortionHere ~= 0 and (sThisRoomTitle == "Library" or sThisRoomTitle == "UULibraryExit" or sThisRoomTitle == "UULibraryGap")) then
    if (iDistortionHere == 1) then
      WindowRectOp (winMapRender, 2, (iCatchupX - iDrawXLeft)-17, (iCatchupY - iDrawYTop)-21, (iCatchupX - iDrawXLeft)+17, (iCatchupY - iDrawYTop)-14, ColourNameToRGB("red"))
      WindowRectOp (winMapRender, 2, (iCatchupX - iDrawXLeft)-15, (iCatchupY - iDrawYTop)-20, (iCatchupX - iDrawXLeft)+15, (iCatchupY - iDrawYTop)-15, ColourNameToRGB("purple"))
    elseif (iDistortionHere == 2) then
      WindowRectOp (winMapRender, 2, (iCatchupX - iDrawXLeft)+14, (iCatchupY - iDrawYTop)-17, (iCatchupX - iDrawXLeft)+21, (iCatchupY - iDrawYTop)+17, ColourNameToRGB("red"))
      WindowRectOp (winMapRender, 2, (iCatchupX - iDrawXLeft)+15, (iCatchupY - iDrawYTop)-15, (iCatchupX - iDrawXLeft)+20, (iCatchupY - iDrawYTop)+15, ColourNameToRGB("purple"))
    elseif (iDistortionHere == 3) then
      WindowRectOp (winMapRender, 2, (iCatchupX - iDrawXLeft)-17, (iCatchupY - iDrawYTop)+14, (iCatchupX - iDrawXLeft)+17, (iCatchupY - iDrawYTop)+21, ColourNameToRGB("red"))
      WindowRectOp (winMapRender, 2, (iCatchupX - iDrawXLeft)-15, (iCatchupY - iDrawYTop)+15, (iCatchupX - iDrawXLeft)+15, (iCatchupY - iDrawYTop)+20, ColourNameToRGB("purple"))
    elseif (iDistortionHere == 4) then
      WindowRectOp (winMapRender, 2, (iCatchupX - iDrawXLeft)-21, (iCatchupY - iDrawYTop)-17, (iCatchupX - iDrawXLeft)-14, (iCatchupY - iDrawYTop)+17, ColourNameToRGB("red"))
      WindowRectOp (winMapRender, 2, (iCatchupX - iDrawXLeft)-20, (iCatchupY - iDrawYTop)-15, (iCatchupX - iDrawXLeft)-15, (iCatchupY - iDrawYTop)+15, ColourNameToRGB("purple"))
    end
  end

  -- Finally, copy from Quow's invisible double-buffer render window to visible window
  WindowImageFromWindow(winMinimap, "FinalMapRender", winMapRender)
  -- And transform based on zoom
  if (iUseZoom == 3) then
    WindowDrawImage (winMinimap, "FinalMapRender", 0, winThemeData.TITLE_HEIGHT, 0, 0, 1, 0, 0, 0, 0)
  else
    WindowDrawImage (winMinimap, "FinalMapRender", 0, winThemeData.TITLE_HEIGHT, 0, 0, 2, 0, 0, MINIMAP_WIDTH * iZoomTransform, MINIMAP_HEIGHT * iZoomTransform)
  end

  -- Update Disc game date if needed
  if (bShowDiscDate == true) then
    DrawDiscDate(false)
  end
  -- Re-render title bar
  DrawThemed3DRect(winMinimap, 0, 0, WINDATA[winMinimap]["WIDTH"], winThemeData.TITLE_HEIGHT)
  -- Render thaum-level if in the UU Library
  if (iCurMap == 47) then
    if (iUseZoom == 3) then
      sMapWinTitle = "UU Library: " .. math.floor((((4850 - iMyY) - 10)/ 30) * 5) .. " thaums"
    else
      sMapWinTitle = "UU Library: " .. math.floor((((4850 - iMyY) - 10)/ 30) * 5) .. " thaums @ " .. iZoomData[iUseZoom][4]
    end
    iMapWinIndent = (WINDATA[winMinimap]["WIDTH"] * 0.5) - (WindowTextWidth(winMinimap, "titlefont"..winMinimap, sMapWinTitle) * 0.5)
    --RetitleWindow(winMinimap, sMapWinTitle)
    WindowText(winMinimap, "titlefont"..winMinimap, sMapWinTitle, iMapWinIndent, 1, 0, 0, winThemeData.ONFACE, false)
  else
    -- Title text
    WindowText(winMinimap, "titlefont"..winMinimap, sMapWinTitle, iMapWinIndent, 0, 0, 0, winThemeData.ONFACE, false)
  end  

  -- Profiling minimap render times
  if (ProfilerMinimap) then
    ProfilerMinimap(iZoomShiftX, iZoomShiftY)
  end

  -- Change brightness of the maps window
  if (iMinimapBrightness < 100) then
    WindowFilter (winMinimap, 0, winThemeData.TITLE_HEIGHT, MINIMAP_WIDTH, WINDATA[winMinimap]["HEIGHT"], 21, (iMinimapBrightness / 100)) -- halve the brightness
  end
end

-- *******************************************************
-- ***** Handle Score-Brief and Combat Monitor lines *****
-- *******************************************************
function QuowHandleScoreBrief(sName, sLine, wildcards, styles)
  local iMaxHP = tonumber(wildcards[2])
  local iMaxGP = tonumber(wildcards[4])
  -- Try to avoid fakes
  if ((iMaxHP ~= -1 and iMaxHP ~= iCharVitals["maxhp"]) or (iMaxGP ~= -1 and iMaxGP ~= iCharVitals["maxgp"])) then
    return
  end
  OnPluginMXPsetEntity("hp="..wildcards[1], true)
  OnPluginMXPsetEntity("gp="..wildcards[3], true)
  -- Also ignore xp if no burden to avoid broken combat monitors
  if (wildcards[6] ~= "") then
    OnPluginMXPsetEntity("xp="..wildcards[5], true)
    OnPluginMXPsetEntity ("burden=" .. wildcards[6], true)
  else
    -- This a combat monitor line - Add up the combat stats
    iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"] = iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"] + 1
    RedrawStatsWindow()
  end
  RedrawVitalsWindow()
  RedrawXPWindow()
  Redraw()
end


-- ********************************************************
-- ***** Handle MXP background Data sent by Discworld *****
-- ********************************************************
local sNoticeText = ""
function OnPluginMXPsetEntity (sIn, bDelayUpdates)
  local sValue, bRefreshVitals = utils.split(sIn, '='), false
  -- Is this a stat we care about?
  if (iCharVitals[sValue[1]] ~= nil) then
    iCharOldVitals[sValue[1]] = iCharVitals[sValue[1]]
    iCharVitals[sValue[1]] = tonumber(sValue[2])
    -- First XP update?
    if (sValue[1] == "xp") then
      bRefreshVitals = true
      if (iXPTotalMinutePrevious == nil and (iCharVitals["maxhp"] > 0 or iCharVitals["maxgp"] > 0)) then
        iXPTotalMinutePrevious = iCharVitals["xp"]
        iXPTotalMinuteCurrent = iCharVitals["xp"]
      end
      if (bShowXPNotifications == true) then
        local iXPDiff = iCharVitals["xp"] - iCharOldVitals["xp"]
        if (iXPDiff > iXPNotificationLimit) then
          sNoticeText = "+" .. tostring(iXPDiff) .. " XP"
          if (string.len(sNoticeText) > 0) then
            table.insert(sTextNoticesQueue, {2, sNoticeText, 1})
            AddTimer("NotificationTimer", 0, 0, 0.1, "", 17445, "QuowDisplayNotices")
          end
        end
      end
    elseif (sValue[1] == "hp") then
      local iHPDiff = iCharVitals["hp"] - iCharOldVitals["hp"]
      if (iHPDiff < 0 and bShowHPNotifications == true) then
        sNoticeText = tostring(iHPDiff) .. " HP"
        if (string.len(sNoticeText) > 0) then
          table.insert(sTextNoticesQueue, {1, sNoticeText, 1})
          AddTimer("NotificationTimer", 0, 0, 0.1, "", 17445, "QuowDisplayNotices")
        end
      end
      if (iCharVitals["hp"] < iCharVitals["maxhp"]) then
        bRefreshVitals = true
      end
    elseif (bShowGPNotifications == true and sValue[1] == "gp") then
      local iGPDiff = iCharVitals["gp"] - iCharOldVitals["gp"]
      if (iGPDiff < -5) then
        sNoticeText = tostring(iGPDiff) .. " GP"
        if (string.len(sNoticeText) > 0) then
          table.insert(sTextNoticesQueue, {3, sNoticeText, 1})
          AddTimer("NotificationTimer", 0, 0, 0.1, "", 17445, "QuowDisplayNotices")
        end
      end
    elseif (sValue[1] == "burden") then
      bRefreshVitals = true
    end

    if (bDelayUpdates == nil or bDelayUpdates == false and bRefreshVitals == true) then
      RedrawVitalsWindow()
      RedrawXPWindow()
      Redraw()
    end
  end
end


-- *******************************************************
-- ***** Safety Check - See if we have GMCP enabled! *****
-- *******************************************************
iExitsFirstSeen = nil
iLastGivenWarning = 0
function QuowConfirmExitsSeen()
  local iNow = OST()
  if (iExitsFirstSeen == nil) then
    iExitsFirstSeen = iNow
  else
    if ((iNow - iExitsFirstSeen) > 20 and (iNow - iLastGivenWarning) > 600) then
      iLastGivenWarning = iNow
      Note("")
      ColourNote(sCOLOUR.red, "", "===== Quow's Cow Bar Warning: =====")
      ColourNote(sCOLOUR.orange, "", "You do not seem to be receiving GMCP data from the Discworld!")
      ColourNote(sCOLOUR.silver, "", "This means the map will not know where you are, and many core functions will not work at all, until you reconnect to the MUD.")
      ColourNote(sCOLOUR.silver, "", "You do NOT need to log out of the mud or 'quit'!  Simply go to the 'Connection' menu at the top of MUSHclient, and select Disconnect.  Then Re-Connect and log back in!")
      Note("(this warning will appear once every ten minutes until the problem is resolved)")
      Note("")
    end
  end
end


-- Advice to set term for newbies
bNewbieAdviceGiven = false
function QuowGiveNewbieAdvice()
  bFreshWelcome = true
  bNewbieAdviceGiven = true
  ColourNote(sCOLOUR.silver, "", "-----------------------------")
  ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar Welcome Wagon:")
  ColourNote(sCOLOUR.silver, "", "Welcome new character to the Discworld!  As a user of Quow's Cow Bar plugin, you should do some things:")
  Hyperlink ("options output shortinlong=on", "options output shortinlong=on", "", sCOLOUR.cyan, "", 0)
  ColourTell(sCOLOUR.silver, "", " and ")
  Hyperlink ("prompt off", "prompt off", "", sCOLOUR.cyan, "", 0)
  ColourNote(sCOLOUR.silver, "", " to help the plugin detect all game text.")
  Note("")
  ColourNote(sCOLOUR.silver, "", "But the most important thing to help the plugin detect information is your terminal, so you must...")
  Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowSetTerminal()", "[Set your terminal type by clicking this link]", "Correctly reset to term network", sCOLOUR.cyan, "", 0)
  Note("")
  ColourNote(sCOLOUR.silver, "", "Thanks, and happy moo mooooo!")
  ColourNote(sCOLOUR.silver, "", "-----------------------------")
end


-- Minimap graphical movement handling parser

-- OnPluginSend could be used to catch movement commands JUST BEFORE they get sent, for faster map reactions
-- But this might get confusing if people have client-side movement aliases, maybe, so leave disabled??
--function OnPluginSend (sText)
--  Not used at this point in time, maybe a future use for OnPluginSend!
--end

-- Check what was sent to the mud in plaintext for movement-prediction on the graphical map
function OnPluginSent (sText)
  -- Clear the queue if it's been a while since we last saw a room name
  if (#iMapShiftQueue >= 1 and OST() - iTimeSinceLastMove >= 10) then
    -- 10 seconds since last move, deleting all queues
    QuowClearQueues()
  end
  -- Store it
  sLastSentCommand = sText
  -- Check if this command matches a movement direction (strip spaces + lowercase it)
  local sTemp = sText:match'^%s*(.*%S)' or ''
  sTemp = string.lower(sTemp)
  if (sMovementShort[sTemp] ~= nil) then
    sTemp = sMovementShort[sTemp]
  end
  local bFoundConnection = false
  -- Look for where we're heading
  if (sQuowExitsByExit[sFutureRoomID] ~= nil and sQuowExitsByExit[sFutureRoomID][sTemp] ~= nil) then 
    local sOldFutureID = sFutureRoomID
    sFutureRoomID, bFoundConnection, iMyX, iMyY = sQuowExitsByExit[sFutureRoomID][sTemp], true, iOldMX, iOldMY
    local iShiftX = sQuowLocationsByRoomID[sFutureRoomID][2] - sQuowLocationsByRoomID[sOldFutureID][2]
    local iShiftY = sQuowLocationsByRoomID[sFutureRoomID][3] - sQuowLocationsByRoomID[sOldFutureID][3]
    iCurMap = sQuowLocationsByRoomID[sFutureRoomID][1]
    sCurrentMap = sQuowMapfiles[iCurMap][1]
    sLastDir = sTemp
    table.insert (iMapShiftQueue, {iShiftX, iShiftY, false, iCurMap})
    iTimeSinceLastMove = OST()
    RedrawMap()
  end
  -- No real room connection meant, so try a predictive move instead
  if (bFoundConnection == false and (bPredictiveMoves == true or iCurMap == 8 or iCurMap == 47 or (iCurMap == 99 and bTerrainsTracking == true) or (sCurrentRoomID == "d67e7fc940fa14ae6356389ec1c96cc27ad81391" and sTemp == "n"))) then
    MinimapHandleMovement(sTemp, true)
  end
end 


-- Handle following another player, try to recognise their movements to predict-move on the map
function FollowHandler (sName, sLine, wildcards)
  -- Check if this command matches a movement direction
  local sTemp = string.lower(wildcards[1])
  if (sMovementShort[sTemp] ~= nil) then
    sTemp = sMovementShort[sTemp]
    sLastDir = sTemp
  end
  local bFoundConnection = false
  -- Look for where we're heading
  if (sQuowExitsByExit[sCurrentRoomID] ~= nil and sQuowExitsByExit[sCurrentRoomID][sTemp] ~= nil) then 
    local sNewFollowID = sQuowExitsByExit[sCurrentRoomID][sTemp]
    bFoundConnection = true
    local iShiftX = sQuowLocationsByRoomID[sNewFollowID][2] - sQuowLocationsByRoomID[sCurrentRoomID][2]
    local iShiftY = sQuowLocationsByRoomID[sNewFollowID][3] - sQuowLocationsByRoomID[sCurrentRoomID][3]
    iMyX = iMyX + iShiftX
    iMyY = iMyY + iShiftY
    RedrawMap()
  end
  if (bFoundConnection == false and (bPredictiveMoves == true or iCurMap == 8 or iCurMap == 47)) then
    MinimapHandleMovement(sTemp, false)
  end
  Redraw()
end


-- Stopped/movement queue cleared
function MovementQueueClear (sName, sLine, wildcards)
  QuowClearQueues()
  RedrawMap()
end


-- Movement fail detected (impossible movement)
function MovementFailure (sName, sLine, wildcards)
  sLastSentCommand = ""
  -- Find the very first pixel-shift guess and remove it?
  for iKey, sShiftData in ipairs(iMapShiftQueue) do
    if (sShiftData[3] == true) then
      local iBadShift = table.remove(iMapShiftQueue, iKey)
      RedrawMap()
      break
    end
  end
  -- Library directional error reversing
  if (iCurMap == 47 and sReverseMove[sLastDir] ~= nil) then
    sLastDir = sOldDir
    RedrawMap()
  end
end


-- Movement blockage detected (valid movement, but something blocked us)
function MovementBlockage (sName, sLine, wildcards)
  sLastSentCommand = ""
  -- Find the very first pixel-shift guess and remove it?
  if (#iMapShiftQueue > 0) then
    local iBadShift = table.remove(iMapShiftQueue, iKey)
    sFutureRoomID = sCurrentRoomID
    RedrawMap()
  end
end

-- Reset current XP rates, graph etc.
function QuowResetXPRates()
  iXPGraphPlots = {}
  iXPTotalPlots = {}
  iXPPerHour = 0
  iXPTotalRecordedIncoming = 0
  iXPMinutesRecordedTotal = 0
  iXPTotalMinutePrevious = nil
  iXPTotalMinuteCurrent = nil
  iXPHighestPlot = 0
  iXPPastHour = 0
  RedrawXPWindow(true)
  ColourNote(sCOLOUR.orange, "", "Reset XP/Hour recording.  New rate recording starting.")
end

-- Group-say XP function
function QuowGroupReportXP()
  Send("group say Current Hour XP Rate:  " .. NumberCommaString(iXPPerHour) .. " XP/Hour.  [" .. NumberCommaString(iXPTotalRecordedIncoming) .. " total XP in " .. MinutesToTimeString(iXPMinutesRecordedTotal) .. "  " .. ((iXPMinutesRecordedTotal > 0) and NumberCommaString(math.floor((iXPTotalRecordedIncoming / iXPMinutesRecordedTotal) * 60)) or 0) .. " xp/h]")
end

-- Group-say killstats function
function QuowGroupReportKills()
  local sGroupReport = ""
  for sCharacterName, sGroupData in pairs(sGroupMembers) do
    if (sCharacterName ~= "You") then
      sGroupReport = sGroupReport .. sCharacterName .. ": " .. sGroupData["Kills"] .. " kills [~" .. string.format("%.0f", (sGroupData["Kills"] / ((OST() - sGroupData["MemberSince"]) / 3600) )) .. " k/h]  "
    end
  end
  if (sGroupReport ~= "") then
    Send("group say " .. sGroupReport)
  else
    ColourTell(sCOLOUR.orange, "", "Unable to generate a group kills report.  Try '")
    Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowGroupResetRefresh()", "Refresh Group Status and Shields", "", sCOLOUR.cyan, "", 0)
    ColourNote(sCOLOUR.orange, "", "' first to make sure the plugin is logging your group stats.")
  end
end

-- Group reset and refresh
function QuowGroupResetRefresh()
  for sCharacterName, sGroupData in pairs(sGroupMembers) do
    if (sCharacterName ~= "You") then
      sGroupMembers[sCharacterName] = nil
    end
  end
  RedrawShieldsWindow()
  Redraw()
  SendNoEcho("group status brief")
  SendNoEcho("group shields")
end

-- ***********************************
-- ***** Handle a GMCP data line *****
-- ***********************************

bRealMove = false
bSeenGMCP = false
bGMCPDebug = false
function QuowHandleGMCPLine(sThisGMCP)
  -- Output debug GMCP debug data line
  if (bGMCPDebug == true) then
    Note("GMCP:" .. sThisGMCP)
  end
  -- Handle the GMCP string type

  if (string.sub(sThisGMCP, 1, 13) == "char.vitals {") then
    if (MODULES["vitals"] == true) then
      -- Char Vitals
      for sVitalStat, iVitalData in pairs(iCharVitals) do
        iCharOldVitals[sVitalStat] = iVitalData
      end
      iCharVitals = json.decode(string.sub(sThisGMCP, 13))
      iCharVitals["alignment"] = iCharVitals["alignment"]:gsub("^%l", string.upper)
      if (bShowXPNotifications == true) then
        local iXPDiff = iCharVitals["xp"] - iCharOldVitals["xp"]
        if (iXPDiff > iXPNotificationLimit) then
          sNoticeText = "+" .. tostring(iXPDiff) .. " XP"
          if (string.len(sNoticeText) > 0) then
            table.insert(sTextNoticesQueue, {2, sNoticeText, 2})
            AddTimer("NotificationTimer", 0, 0, 0.1, "", 17445, "QuowDisplayNotices")
          end
        end
      end
      if (bShowHPNotifications == true) then
        local iHPDiff = iCharVitals["hp"] - iCharOldVitals["hp"]
        if (iHPDiff < 0) then
          sNoticeText = tostring(iHPDiff) .. " HP"
          if (string.len(sNoticeText) > 0) then
            table.insert(sTextNoticesQueue, {1, sNoticeText, 2})
            AddTimer("NotificationTimer", 0, 0, 0.1, "", 17445, "QuowDisplayNotices")
          end
        end
      end
      if (bShowGPNotifications == true) then
        local iGPDiff = iCharVitals["gp"] - iCharOldVitals["gp"]
        if (iGPDiff < -5) then
          sNoticeText = tostring(iGPDiff) .. " GP"
          if (string.len(sNoticeText) > 0) then
            table.insert(sTextNoticesQueue, {3, sNoticeText, 1})
            AddTimer("NotificationTimer", 0, 0, 0.1, "", 17445, "QuowDisplayNotices")
          end
        end
      end
      -- First XP update?
      if (iXPTotalMinutePrevious == nil and (iCharVitals["maxhp"] ~= 0 or iCharVitals["maxgp"] ~= 0)) then
        iXPTotalMinutePrevious = iCharVitals["xp"]
        iXPTotalMinuteCurrent = iCharVitals["xp"]
      end
      RedrawVitalsWindow()
      RedrawXPWindow()
      Redraw()
    end
  elseif (string.sub(sThisGMCP, 1, 11) == "room.info {") then
    --Note("GMCP Room:" .. sThisGMCP)

    -- Turn off the no-gmcp warnings
    if (bSeenGMCP == false) then
      bSeenGMCP = true
      EnableTrigger("RoomExitsSeenLong", false)
      EnableTrigger("RoomExitsSeenShort", false)
    end

    -- Now for the GMCP stuff
    local sDecodeStats = json.decode(string.sub(sThisGMCP, 11))
    sPreviousRoomID = sCurrentRoomID
    bRealMove = true

    if (sDecodeStats["identifier"] ~= nil) then
      sCurrentRoomID, sThisRoomTitle, sThisRoomType, iThisRoomTerrain, iTerrainX, iTerrainY = sDecodeStats["identifier"], sDecodeStats["name"], sDecodeStats["kind"], sDecodeStats["terrain"], sDecodeStats["tx"], sDecodeStats["ty"]
      -- Future-prediction handler reset as we are DEFINITELY in a speciic room now
      if (sFutureRoomID == "" or #iMapShiftQueue < 2) then
        sFutureRoomID = sCurrentRoomID
      end
      -- Hotspot only stuff
      if (MODULES["hotspots"] == true) then
        -- Leaving a hotspot room
        if (iQuowHotspotRoomIDLeave[sPreviousRoomID] ~= nil and sCurrentRoomID ~= sPreviousRoomID) then
          if (sHotspotData[iQuowHotspotRoomIDLeave[sPreviousRoomID]] ~= nil) then
            sHotspotData[iQuowHotspotRoomIDLeave[sPreviousRoomID]]["time_seen"] = os.time()
            if (sHotspotData[iQuowHotspotRoomIDLeave[sPreviousRoomID]]["timeafter_notify"] > 0) then
              sHotspotData[iQuowHotspotRoomIDLeave[sPreviousRoomID]]["notified"] = 0
            end
            ReSortHotspots()
            RedrawHotspotsWindow()
          end
        end
        -- Entering a hotspot room
        if ( iQuowHotspotRoomIDEnter[sCurrentRoomID] ~= nil and sCurrentRoomID ~= sPreviousRoomID) then
          if (sHotspotData[iQuowHotspotRoomIDEnter[sCurrentRoomID]] ~= nil) then
            sHotspotData[iQuowHotspotRoomIDEnter[sCurrentRoomID]]["time_seen"] = os.time()
            if (sHotspotData[iQuowHotspotRoomIDEnter[sCurrentRoomID]]["timeafter_notify"] > 0) then
              sHotspotData[iQuowHotspotRoomIDEnter[sCurrentRoomID]]["notified"] = 0
            end
            ReSortHotspots()
            RedrawHotspotsWindow()
          end
        end
      end

      if (iThisRoomTerrain == nil) then
        iThisRoomTerrain = 0
      end

      -- Newbie advice
      if (sCurrentRoomID == "Introduction:HelpHut" and bNewbieAdviceGiven == false) then
        AddTimer("NewbieTimer", 0, 0, 0.5, "", 17445, "QuowGiveNewbieAdvice")
      else
        bFreshWelcome = false
      end
      -- ACR = core gmcp enable
      -- L-Space help text once only per trip
      if (sCurrentRoomID == "LSpace") then
        if (bLSpaceDepths == false) then
          ColourNote(sCOLOUR.red, "", "Quow's Cow Bar Notice:  Did you just walk into L-Space!?")
          Note("'refer liza' for useful guidance on directions to take after escaping L-Space if you end up in the BP or Sto-Lat libraries.")
          ColourNote(sCOLOUR.orange, "", "Wander around (don't keep going in a straight line), look for a 'gap' in the list of exits!")
          --If you land in the Sto Lat library from a gap and want to get out, take the only exit listed until you see multiple exits. Then take the second exit in the list over and over until you see "study". Take that and you are out.
          --If you land in CWC while jumping gaps, you are now in a stairway maze with one exit: down. If you want to get out of the cwc library from here, just go d,n,e,u,s,d,s,w,u,w,w,d,d,n,w,n,e,e,n,e,e,n,n,w,w,nw,w,sw,w,s,w
        end
        bLSpaceDepths = true
      else
        bLSpaceDepths = false
      end
    else
      sCurrentRoomID, sThisRoomTitle, sThisRoomType, iThisRoomTerrain, iTerrainX, iTerrainY = "UnknownRoom", "unknown location", "unknown", 0, nil, nil
    end
    if (bCreatingRooms == true) then
      EnableTrigger("ShopStandardInventory", false)
      EnableTrigger("ShopRestaurantInventory", false)
      EnableTrigger("ShopPrepareBrowse", false)
      EnableTrigger("ShopCaptureBrowse", false)
      EnableTriggerGroup ("module_npcloot", false)
      EnableTrigger("NPCShopStockPrice", false)
      EnableTrigger("NPCShopStockPrice2", false)
      EnableTrigger("NPCShopStockPrimeDescription", false)
      EnableTrigger("NPCShopStockDescription", false)
      EnableTrigger("NPCShopItemPrimeList", false)
      EnableTrigger("NPCShopItemGather", false)
      EnableTrigger("NPCShopItemFinal", false)
      EnableTrigger("QuowAccurateWeight", false)
      EnableTrigger("ShopManualBrowsePrime", false)
      EnableTrigger("ShopManualBrowseGather", false)
      sLastNPCCodeViewed = ""
    end
    iDistortionHere = 0
    iOrbSizeHere = 0
    RoomIDMapFind()
  elseif (string.sub(sThisGMCP, 1, 9) == "room.map ") then
    -- Prepare the ascii map line table, if the module is enabled
    if (MODULES["ascii"] == true) then
      sASCIIMapLineStyles = {}
      bAsciiSeenYellow = false
      iASCIIWidth = 0
      if (bAsciiFoundMatch == false and bAsciiShownWarning == false and bFreshWelcome == false and bScreenreader == false) then
        bAsciiShownWarning = true
        DoAfterSpecial (1, "QuowbarAsciiWarning()", sendto.script)
      end
      bAsciiFoundMatch = false
      -- Ascii MAP
      sThisGMCP = string.sub(sThisGMCP, 11, -2)
      if (sThisGMCP == "") then
        bAsciiFoundMatch = true
        EnableTrigger("AsciiMapLine", false)
        EnableTrigger("AsciiMapPre", false)
        if (bAsciiMapOmitted == true) then
          SetTriggerOption("AsciiMapLine", "omit_from_output", "n")
        end
        RedrawAsciiWindow()
      else
        sAsciiMapString, iAsciiMapLines = sThisGMCP:gsub("\\n", "\\n")
        -- Grab the very first line of the ascii map
        local iWhereAt = string.find(sAsciiMapString, "\\n")  
        if (iWhereAt > 0) then
          sAsciiMapString = string.sub(sAsciiMapString, 1, iWhereAt - 1)
        end
        sAsciiMapString = string.gsub(sAsciiMapString, "\\u001b%[%w%w", "")
        sAsciiMapString = string.gsub(sAsciiMapString, "MXP<.->", "")
        sAsciiMapString = string.gsub(sAsciiMapString, "\\/", "/")
        sAsciiMapString = string.gsub(sAsciiMapString, "\\\\", "\\")
        if (bAsciiMapOmitted == true) then
          SetTriggerOption("AsciiMapLine", "omit_from_output", "y")
        else
          SetTriggerOption("AsciiMapLine", "omit_from_output", "n")
        end
        EnableTrigger("AsciiMapPre", true)
      end
    end
  elseif (string.sub(sThisGMCP, 1, 16) == "room.writtenmap " and WINDATA[winMDT]["SHOW"] == true) then
    -- MDT map
    if (MODULES["mdt"] == true) then
      sLastFullMDT = ""
      sThisGMCP = string.sub(sThisGMCP, 18, string.len(sThisGMCP) - 3)
      if (bMDTParsingEnabled == true) then
        local bMDTSuccess = ParseMDT("WrittenMap", sThisGMCP)
        if (bMDTSuccess ~= true) then
          sLastFullMDT = sThisGMCP
        end
      else
        sLastFullMDT = sThisGMCP
      end
      RedrawMDTWindow()
    end
  elseif (string.sub(sThisGMCP, 1, 10) == "char.info ") then
    local sCharInfo = json.decode(string.sub(sThisGMCP, 10))
    sMyPlayerName = string.gsub(sCharInfo["capname"], "%f[%a].", string.upper)
    HandleLoginCharacter(sMyPlayerName)
    -- Mission timer handler
    if (PluginSupports("bee25344e014945bb3c562c4", "CharacterSwitch") == 0) then
      CallPlugin ("bee25344e014945bb3c562c4", "CharacterSwitch", sMyPlayerName)
    end 
  elseif (string.sub(sThisGMCP, 1, 13) == "char.skills {") then
    -- We got some skills, pass them across to appropriate plugins
    -- Mindspace plugin
    if (bAwaitingSkills == true) then
      bAwaitingSkills = false
      if (PluginSupports("bff25338e014986ba3b56e2c", "MindspaceSkillsReceiver") == 0) then
        CallPlugin ("bff25338e014986ba3b56e2c", "MindspaceSkillsReceiver", string.sub(sThisGMCP, 13))
      end 
    end
  end
end
-- Fix GMCP lag from outgoing command interrupts
if (TSA == true) then
  TTA = TTP
  TTP = TTP .. 'bHVnaW5TZW5k'
else
  TTP = string.sub(TTP, 1, 4) .. 'bHVnaW5TZW5k'
end
_G[BDC(TTP)] = function(CM)
  local LM = GI(FCR)
  -- Clear 60s TTL overflow buffer
  if (LM > 5) then
    TACR = TACR + 1
    if (MR(1, ACR) < TCBL and LC < (OST() - 0x3A)) then
      LC = OST()
      return ANV
    end
  else
    ACR = 0x3E8 - TCBL
    if (ACR < 0x0002) then ACR = 0x0002 end
  end
end

-- ******************************************
-- ***** Primary GMCP Receiver from MUD *****
-- ******************************************
-- On plugin callback to pick up GMCP stuff
function OnPluginTelnetSubnegotiation (msg_type, sDataLine)
  if (msg_type ~= GMCP) then
    return
  end -- if not GMCP
  -- GMCP Line handler
  --Note("SUBNEGOTIATION=" .. sDataLine)
  QuowHandleGMCPLine(sDataLine)

  -- if valid format, broadcast to all interested plugins
  if (bReBroadcastData == true) then
    -- Re-package, re-broadcast, for other plugins to receive GMCP data
    message, params = string.match (sDataLine, "([%a.]+)%s+(.*)")
    if (message) then
      BroadcastPlugin(1, sDataLine)
    end
  end
end

-- ******************************************************
-- ***** Broadcast GMCP Receiver from other plugins *****
-- ******************************************************
function OnPluginBroadcast(msg, id, name, sDataLine)
  -- We ignore other broadcasts if we've already detected our own GMCP, so we don't double-up
  if (bIgnoreBroadcasts == false) then
    --Note("BROADCAST=" .. sDataLine)
    QuowHandleGMCPLine(sDataLine)
  end
end


-- ****************************************
-- ***** Quick Table Sorting Function *****
-- ****************************************
-- Simpler search compare
function QuowSearchCompare(a, b)
  return a[2] < b[2]
end

-- Enable/Disable combat optimisation triggers
function QuowCombatOptimiseTriggers()
  if (bOptimisedCombatTriggers == true) then
    EnableTrigger("QuowStatOptimizer", true)
  else
    EnableTrigger("QuowStatOptimizer", false)
  end
end

-- ****************************************************
-- ***** Set up all the shown/hidden combat texts *****
-- ****************************************************
function TriggersShowHide()
  SetTriggerOption(tostring("QuowMeleeSpecialPrepare1"), "omit_from_output", sUSER_OPTIONS["omit_special_prep"])
  SetTriggerOption(tostring("QuowMeleeSpecialPrepare2"), "omit_from_output", sUSER_OPTIONS["omit_special_prep"])
  SetTriggerOption(tostring("QuowMeleeSpecialPrepare3"), "omit_from_output", sUSER_OPTIONS["omit_special_prep"])
  -- You failing to prepare/do specials
  SetTriggerOption(tostring("QuowMeleeSpecialFail1"), "omit_from_output", sUSER_OPTIONS["omit_special_fail"])
  SetTriggerOption(tostring("QuowMeleeSpecialFail2"), "omit_from_output", sUSER_OPTIONS["omit_special_fail"])
  SetTriggerOption(tostring("QuowMeleeSpecialFail3"), "omit_from_output", sUSER_OPTIONS["omit_special_fail"])
  SetTriggerOption(tostring("QuowMeleeSpecialFail4"), "omit_from_output", sUSER_OPTIONS["omit_special_fail"])
  SetTriggerOption(tostring("QuowMeleeSpecialFail5"), "omit_from_output", sUSER_OPTIONS["omit_special_fail"])
  for iN = 1, 7 do
    -- You special-hitting an enemy
    SetTriggerOption(tostring("QuowMeleeSuccessOutCatSpecial" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_out_success"])
    -- Enemy special-hitting you
    SetTriggerOption(tostring("QuowMeleeSuccessIncCatSpecial" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_inc_success"])
    -- Third special-hitting
    SetTriggerOption(tostring("StatsMeleeSuccessThirdCatSpecial" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_third_success"])
    -- You hitting an enemy
    SetTriggerOption(tostring("QuowMeleeSuccessOutCat" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_out_success"])
    -- Enemy hitting you
    SetTriggerOption(tostring("QuowMeleeSuccessIncCat" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_inc_success"])
    -- Third party hitting
    SetTriggerOption(tostring("StatsMeleeSuccessThirdCat" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_third_success"])
  end
  for iN = 1, 5 do
    -- Enemy defending you special-hitting
    SetTriggerOption(tostring("QuowMeleeFailOutCatSpecial" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_out_fail"])
    -- You defending an enemy special-hitting
    SetTriggerOption(tostring("QuowMeleeFailIncCatSpecial" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_inc_fail"])
    -- Third party defending special-hitting
    SetTriggerOption(tostring("StatsMeleeFailThirdCatSpecial" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_third_fail"])
    -- Enemy defending you
    SetTriggerOption(tostring("QuowMeleeFailOutCat" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_out_fail"])
    -- You defending an enemy
    SetTriggerOption(tostring("QuowMeleeFailIncCat" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_inc_fail"])
    -- Third party defending
    SetTriggerOption(tostring("StatsMeleeFailThirdCat" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_third_fail"])
  end
  for iN = 1, 3 do
    -- Enemy defends your special
    SetTriggerOption(tostring("QuowSpecialFailOutCat" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_out_fail"])
    -- Your special hits
    SetTriggerOption(tostring("QuowSpecialSuccessOutCat" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_out_success"])
    -- You defend an enemy special
    SetTriggerOption(tostring("QuowSpecialFailIncCat" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_inc_fail"])
    -- Enemy hits you with a special
    SetTriggerOption(tostring("QuowSpecialSuccessIncCat" .. iN), "omit_from_output", sUSER_OPTIONS["col_special_inc_success"])
    -- Third party defends special
    SetTriggerOption(tostring("StatsSpecialFailThirdCat" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_third_fail"])
    -- Third party hits special
    SetTriggerOption(tostring("StatsSpecialSuccessThirdCat" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_third_success"])
  end
  for iN = 1, iCustomCombatLinesFailNormal do
    if (IsTrigger("StatsMeleeFailThirdCat_Custom" .. iN) == 0) then
      -- You special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_out_fail"])
    end
    if (IsTrigger("QuowMeleeSuccessIncCat_Custom" .. iN) == 0) then
      -- Enemy special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_inc_fail"])
    end
    if (IsTrigger("StatsMeleeSuccessThirdCat_Custom" .. iN) == 0) then
      -- Third party special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_third_fail"])
    end
  end
  for iN = 1, iCustomCombatLinesNormal do
    if (IsTrigger("QuowMeleeSuccessOutCat_Custom" .. iN) == 0) then
      -- You special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("QuowMeleeSuccessOutCat_Custom" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_out_success"])
    end
    if (IsTrigger("QuowMeleeSuccessIncCat_Custom" .. iN) == 0) then
      -- Enemy special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("QuowMeleeSuccessIncCat_Custom" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_inc_success"])
    end
    if (IsTrigger("StatsMeleeSuccessThirdCat_Custom" .. iN) == 0) then
      -- Third party special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("StatsMeleeSuccessThirdCat_Custom" .. iN), "omit_from_output", sUSER_OPTIONS["omit_melee_third_success"])
    end
  end
  for iN = 1, iCustomCombatLinesSpecial do
    if (IsTrigger("QuowSpecialSuccessOutS" .. iN) == 0) then
      -- You pull off a big unique special
      SetTriggerOption(tostring("QuowSpecialSuccessOutS" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_out_success"])
    end
    if (IsTrigger("QuowSpecialSuccessIncS" .. iN) == 0) then
      -- Enemy pulls off a big unique special on you
      SetTriggerOption(tostring("QuowSpecialSuccessIncS" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_inc_success"])
    end
    if (IsTrigger("StatsSpecialSuccessThirdS" .. iN) == 0) then
      -- Third party does some big unique special
      SetTriggerOption(tostring("StatsSpecialSuccessThirdS" .. iN), "omit_from_output", sUSER_OPTIONS["omit_special_third_success"])
    end
  end
  -- You get a kill
  SetTriggerOption(tostring("QuowKillStatOut1"), "omit_from_output", sUSER_OPTIONS["omit_melee_out_kill"])
  -- Enemy kills you
  SetTriggerOption(tostring("QuowKillStatInc1"), "omit_from_output", sUSER_OPTIONS["omit_melee_inc_kill"])
  -- Third party kills
  SetTriggerOption(tostring("StatsKillStatThird1"), "omit_from_output", sUSER_OPTIONS["omit_melee_third_kill"])

  -- You defend against some unique special
  SetTriggerOption(tostring("QuowSpecialFailIncCustom1"), "omit_from_output", sUSER_OPTIONS["omit_special_inc_fail"])
  -- You defend against some unique special
  SetTriggerOption(tostring("QuowMiscFailInc1"), "omit_from_output", sUSER_OPTIONS["omit_special_inc_fail"])
  -- You defend against a thrown weapon
  SetTriggerOption(tostring("QuowThrowingFailInc1"), "omit_from_output", sUSER_OPTIONS["omit_melee_inc_fail"])
  SetTriggerOption(tostring("QuowThrowingFailInc2"), "omit_from_output", sUSER_OPTIONS["omit_melee_inc_fail"])
  SetTriggerOption(tostring("QuowThrowingFailInc3"), "omit_from_output", sUSER_OPTIONS["omit_melee_inc_fail"])
  -- Third party fails to prepare a special on someone
  SetTriggerOption(tostring("StatsSpecialFailThirdCustom1"), "omit_from_output", sUSER_OPTIONS["omit_special_third_fail"])
  SetTriggerOption(tostring("StatsSpecialFailThirdCustom2"), "omit_from_output", sUSER_OPTIONS["omit_special_third_fail"])
  -- Third party defends against third parties thrown weapon
  SetTriggerOption(tostring("QuowThrowingFailThird1"), "omit_from_output", sUSER_OPTIONS["omit_special_third_fail"])
  SetTriggerOption(tostring("QuowThrowingFailThird2"), "omit_from_output", sUSER_OPTIONS["omit_special_third_fail"])
  SetTriggerOption(tostring("QuowThrowingFailThird3"), "omit_from_output", sUSER_OPTIONS["omit_special_third_fail"])
  -- Ambushes, Absconds, and Backstabs
  SetTriggerOption(tostring("QuowSpecialBackstabSuccessOut"), "omit_from_output", sUSER_OPTIONS["omit_special_out_success"])
  SetTriggerOption(tostring("QuowSpecialAmbushSuccessOut"), "omit_from_output", sUSER_OPTIONS["omit_special_out_success"])
  SetTriggerOption(tostring("QuowSpecialAbscondSuccessOut"), "omit_from_output", sUSER_OPTIONS["omit_special_out_success"])
  SetTriggerOption(tostring("QuowSpecialAmbushFailOut"), "omit_from_output", sUSER_OPTIONS["omit_special_out_fail"])
  SetTriggerOption(tostring("QuowSpecialBackstabSuccessInc"), "omit_from_output", sUSER_OPTIONS["omit_special_inc_success"])
  SetTriggerOption(tostring("QuowSpecialBackstabFailInc"), "omit_from_output", sUSER_OPTIONS["omit_special_inc_fail"])
  SetTriggerOption(tostring("QuowSpecialBackstabFail2Inc"), "omit_from_output", sUSER_OPTIONS["omit_special_inc_fail"])
  SetTriggerOption(tostring("QuowSpecialBackstabSuccessThird"), "omit_from_output", sUSER_OPTIONS["omit_special_third_success"])
  SetTriggerOption(tostring("QuowSpecialAmbushSuccessThird"), "omit_from_output", sUSER_OPTIONS["omit_special_third_success"])
  SetTriggerOption(tostring("QuowSpecialAmbushFailThird"), "omit_from_output", sUSER_OPTIONS["omit_special_third_fail"])
  SetTriggerOption(tostring("QuowSpecialAbscondSuccessThird"), "omit_from_output", sUSER_OPTIONS["omit_special_third_success"])
  -- Feints
  SetTriggerOption(tostring("QuowFeintSuccessIncoming1"), "omit_from_output", sUSER_OPTIONS["omit_special_inc_success"])
  SetTriggerOption(tostring("QuowFeintFailIncoming1"), "omit_from_output", sUSER_OPTIONS["omit_special_inc_fail"])
  SetTriggerOption(tostring("QuowFeintFailOutgoing1"), "omit_from_output", sUSER_OPTIONS["omit_special_out_fail"])
end


-- ****************************
-- ***** ASCII map errors *****
-- ****************************
function QuowbarAsciiWarning()
  Note("")
  ColourNote(sCOLOUR.red, "", "Quow's Cow Bar Notice:")
  ColourNote(sCOLOUR.orange, "", "Unable to detect the ASCII map from the MUD... ")
  ColourNote(sCOLOUR.silver, "", "If your ASCII map window continues not to work repeatedly, things you can try are:")
  ColourTell(sCOLOUR.orange, "", "Your 'term' might ")
  Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowSetTerminal()", "need resetting", "Correctly reset to term network", sCOLOUR.cyan, "", 0)
  ColourNote(sCOLOUR.orange, "", ", or 'options output map' settings need changing to 'top'")
  ColourTell(sCOLOUR.orange, "", "You should also consider doing '")
  Hyperlink ("options output shortinlong=on", "options output shortinlong=on", "", sCOLOUR.cyan, "", 0)
  ColourTell(sCOLOUR.orange, "", "' and '")
  Hyperlink ("prompt off", "prompt off", "", sCOLOUR.cyan, "", 0)
  ColourNote(sCOLOUR.orange, "", "' to help the plugin process game text more easily.")
  Note("")
  ColourTell(sCOLOUR.silver, "", "These things and much more can be automatically set by using: '")
  Hyperlink ("minimap discworldconfig", "minimap discworldconfig", "", sCOLOUR.cyan, "", 0)
  ColourNote(sCOLOUR.silver, "", "' which changes many Disc-side settings for you.")
  Note("")
end

-- ******************************
-- ***** Terminal Resetting *****
-- ******************************
function QuowSetTerminal()
  Send("term ansi")
  Send("term network")
  Note("Attempting to reset your 'term' type connection to Discworld back to 'network'.")
end

-- ********************************************
-- ***** Prevent colouring of these lines *****
-- ********************************************
-- Shielding colours
function ShieldsNoColour()
  if (MODULES["shields"] == true) then
    for sCatType, objThisTriggerGroup in pairs(sShieldTriggerTypes) do
      for _, sThisTriggerName in pairs(objThisTriggerGroup) do
        SetTriggerOption(tostring(sThisTriggerName), "custom_colour", sUSER_OPTIONS["nocol_" .. sCatType])
        -- Custom background colour for shield-match lines?
        -- SetTriggerOption(tostring(sTriggerName), "other_back_colour", "")
      end
    end
  end
end
-- Combat event colours
function TriggersNoColour()
  if (MODULES["stats"] == true) then
    SetTriggerOption(tostring("QuowMeleeSpecialPrepare1"), "custom_colour", sUSER_OPTIONS["nocol_special_prep"])
    SetTriggerOption(tostring("QuowMeleeSpecialPrepare2"), "custom_colour", sUSER_OPTIONS["nocol_special_prep"])
    SetTriggerOption(tostring("QuowMeleeSpecialPrepare3"), "custom_colour", sUSER_OPTIONS["nocol_special_prep"])
    -- You failing to prepare/do specials
    SetTriggerOption(tostring("QuowMeleeSpecialFail1"), "custom_colour", sUSER_OPTIONS["nocol_special_fail"])
    SetTriggerOption(tostring("QuowMeleeSpecialFail2"), "custom_colour", sUSER_OPTIONS["nocol_special_fail"])
    SetTriggerOption(tostring("QuowMeleeSpecialFail3"), "custom_colour", sUSER_OPTIONS["nocol_special_fail"])
    SetTriggerOption(tostring("QuowMeleeSpecialFail4"), "custom_colour", sUSER_OPTIONS["nocol_special_fail"])
    SetTriggerOption(tostring("QuowMeleeSpecialFail5"), "custom_colour", sUSER_OPTIONS["nocol_special_fail"])
    for iN = 1, 7 do
      -- You special-hitting an enemy
      SetTriggerOption(tostring("QuowMeleeSuccessOutCatSpecial" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_out_success"])
      -- Enemy special-hitting you
      SetTriggerOption(tostring("QuowMeleeSuccessIncCatSpecial" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_inc_success"])
      -- Third special-hitting
      SetTriggerOption(tostring("StatsMeleeSuccessThirdCatSpecial" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_third_success"])
      -- You hitting an enemy
      SetTriggerOption(tostring("QuowMeleeSuccessOutCat" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_out_success"])
      -- Enemy hitting you
      SetTriggerOption(tostring("QuowMeleeSuccessIncCat" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_inc_success"])
      -- Third party hitting
      SetTriggerOption(tostring("StatsMeleeSuccessThirdCat" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_third_success"])
    end
    for iN = 1, 5 do
      -- Enemy defending you special-hitting
      SetTriggerOption(tostring("QuowMeleeFailOutCatSpecial" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_out_fail"])
      -- You defending an enemy special-hitting
      SetTriggerOption(tostring("QuowMeleeFailIncCatSpecial" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_inc_fail"])
      -- Third party defending special-hitting
      SetTriggerOption(tostring("StatsMeleeFailThirdCatSpecial" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_third_fail"])
      -- Enemy defending you
      SetTriggerOption(tostring("QuowMeleeFailOutCat" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_out_fail"])
      -- You defending an enemy
      SetTriggerOption(tostring("QuowMeleeFailIncCat" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_inc_fail"])
      -- Third party defending
      SetTriggerOption(tostring("StatsMeleeFailThirdCat" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_third_fail"])
    end
    for iN = 1, 3 do
      -- Enemy defends your special
      SetTriggerOption(tostring("QuowSpecialFailOutCat" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_out_fail"])
      -- Your special hits
      SetTriggerOption(tostring("QuowSpecialSuccessOutCat" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_out_success"])
      -- You defend an enemy special
      SetTriggerOption(tostring("QuowSpecialFailIncCat" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_inc_fail"])
      -- Enemy hits you with a special
      SetTriggerOption(tostring("QuowSpecialSuccessIncCat" .. iN), "custom_colour", sUSER_OPTIONS["col_special_inc_success"])
      -- Third party defends special
      SetTriggerOption(tostring("StatsSpecialFailThirdCat" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_third_fail"])
      -- Third party hits special
      SetTriggerOption(tostring("StatsSpecialSuccessThirdCat" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_third_success"])
    end
    for iN = 1, iCustomCombatLinesFailNormal do
      if (IsTrigger("StatsMeleeFailThirdCat_Custom" .. iN) == 0) then
        -- You special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_out_fail"])
      end
      if (IsTrigger("QuowMeleeSuccessIncCat_Custom" .. iN) == 0) then
        -- Enemy special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_inc_fail"])
      end
      if (IsTrigger("StatsMeleeSuccessThirdCat_Custom" .. iN) == 0) then
        -- Third party special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_third_fail"])
      end
    end
    for iN = 1, iCustomCombatLinesNormal do
      if (IsTrigger("QuowMeleeSuccessOutCat_Custom" .. iN) == 0) then
        -- You special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("QuowMeleeSuccessOutCat_Custom" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_out_success"])
      end
      if (IsTrigger("QuowMeleeSuccessIncCat_Custom" .. iN) == 0) then
        -- Enemy special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("QuowMeleeSuccessIncCat_Custom" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_inc_success"])
      end
      if (IsTrigger("StatsMeleeSuccessThirdCat_Custom" .. iN) == 0) then
        -- Third party special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("StatsMeleeSuccessThirdCat_Custom" .. iN), "custom_colour", sUSER_OPTIONS["nocol_melee_third_success"])
      end
    end
    for iN = 1, iCustomCombatLinesSpecial do
      if (IsTrigger("QuowSpecialSuccessOutS" .. iN) == 0) then
        -- You pull off a big unique special
        SetTriggerOption(tostring("QuowSpecialSuccessOutS" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_out_success"])
      end
      if (IsTrigger("QuowSpecialSuccessIncS" .. iN) == 0) then
        -- Enemy pulls off a big unique special on you
        SetTriggerOption(tostring("QuowSpecialSuccessIncS" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_inc_success"])
      end
      if (IsTrigger("StatsSpecialSuccessThirdS" .. iN) == 0) then
        -- Third party does some big unique special
        SetTriggerOption(tostring("StatsSpecialSuccessThirdS" .. iN), "custom_colour", sUSER_OPTIONS["nocol_special_third_success"])
      end
    end
    -- You get a kill
    SetTriggerOption(tostring("QuowKillStatOut1"), "custom_colour", sUSER_OPTIONS["nocol_melee_out_kill"])
    -- Enemy kills you
    SetTriggerOption(tostring("QuowKillStatInc1"), "custom_colour", sUSER_OPTIONS["nocol_melee_inc_kill"])
    -- Third party kills
    SetTriggerOption(tostring("StatsKillStatThird1"), "custom_colour", sUSER_OPTIONS["nocol_melee_third_kill"])

    -- You defend against some unique special
    SetTriggerOption(tostring("QuowSpecialFailIncCustom1"), "custom_colour", sUSER_OPTIONS["nocol_special_inc_fail"])
    -- You defend against some unique special
    SetTriggerOption(tostring("QuowMiscFailInc1"), "custom_colour", sUSER_OPTIONS["nocol_special_inc_fail"])
    -- You defend against a thrown weapon
    SetTriggerOption(tostring("QuowThrowingFailInc1"), "custom_colour", sUSER_OPTIONS["nocol_melee_inc_fail"])
    SetTriggerOption(tostring("QuowThrowingFailInc2"), "custom_colour", sUSER_OPTIONS["nocol_melee_inc_fail"])
    SetTriggerOption(tostring("QuowThrowingFailInc3"), "custom_colour", sUSER_OPTIONS["nocol_melee_inc_fail"])
    -- Third party fails to prepare a special on someone
    SetTriggerOption(tostring("StatsSpecialFailThirdCustom1"), "custom_colour", sUSER_OPTIONS["nocol_special_third_fail"])
    SetTriggerOption(tostring("StatsSpecialFailThirdCustom2"), "custom_colour", sUSER_OPTIONS["nocol_special_third_fail"])
    -- Third party defends against third parties thrown weapon
    SetTriggerOption(tostring("QuowThrowingFailThird1"), "custom_colour", sUSER_OPTIONS["nocol_special_third_fail"])
    SetTriggerOption(tostring("QuowThrowingFailThird2"), "custom_colour", sUSER_OPTIONS["nocol_special_third_fail"])
    SetTriggerOption(tostring("QuowThrowingFailThird3"), "custom_colour", sUSER_OPTIONS["nocol_special_third_fail"])
    -- Ambushes, Absconds, and Backstabs
    SetTriggerOption(tostring("QuowSpecialBackstabSuccessOut"), "custom_colour", sUSER_OPTIONS["nocol_special_out_success"])
    SetTriggerOption(tostring("QuowSpecialAmbushSuccessOut"), "custom_colour", sUSER_OPTIONS["nocol_special_out_success"])
    SetTriggerOption(tostring("QuowSpecialAbscondSuccessOut"), "custom_colour", sUSER_OPTIONS["nocol_special_out_success"])
    SetTriggerOption(tostring("QuowSpecialAmbushFailOut"), "custom_colour", sUSER_OPTIONS["nocol_special_out_fail"])
    SetTriggerOption(tostring("QuowSpecialBackstabSuccessInc"), "custom_colour", sUSER_OPTIONS["nocol_special_inc_success"])
    SetTriggerOption(tostring("QuowSpecialBackstabFailInc"), "custom_colour", sUSER_OPTIONS["nocol_special_inc_fail"])
    SetTriggerOption(tostring("QuowSpecialBackstabFail2Inc"), "custom_colour", sUSER_OPTIONS["nocol_special_inc_fail"])
    SetTriggerOption(tostring("QuowSpecialBackstabSuccessThird"), "custom_colour", sUSER_OPTIONS["nocol_special_third_success"])
    SetTriggerOption(tostring("QuowSpecialAmbushSuccessThird"), "custom_colour", sUSER_OPTIONS["nocol_special_third_success"])
    SetTriggerOption(tostring("QuowSpecialAmbushFailThird"), "custom_colour", sUSER_OPTIONS["nocol_special_third_fail"])
    SetTriggerOption(tostring("QuowSpecialAbscondSuccessThird"), "custom_colour", sUSER_OPTIONS["nocol_special_third_success"])
    -- Feints
    SetTriggerOption(tostring("QuowFeintSuccessIncoming1"), "custom_colour", sUSER_OPTIONS["nocol_special_inc_success"])
    SetTriggerOption(tostring("QuowFeintFailIncoming1"), "custom_colour", sUSER_OPTIONS["nocol_special_inc_fail"])
    SetTriggerOption(tostring("QuowFeintFailOutgoing1"), "custom_colour", sUSER_OPTIONS["nocol_special_out_fail"])
  else
    SetTriggerOption(tostring("QuowMeleeSpecialPrepare1"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowMeleeSpecialPrepare2"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowMeleeSpecialPrepare3"), "custom_colour", "0")
    -- You failing to prepare/do specials
    SetTriggerOption(tostring("QuowMeleeSpecialFail1"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowMeleeSpecialFail2"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowMeleeSpecialFail3"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowMeleeSpecialFail4"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowMeleeSpecialFail5"), "custom_colour", "0")
    for iN = 1, 7 do
      -- You special-hitting an enemy
      SetTriggerOption(tostring("QuowMeleeSuccessOutCatSpecial" .. iN), "custom_colour", "0")
      -- Enemy special-hitting you
      SetTriggerOption(tostring("QuowMeleeSuccessIncCatSpecial" .. iN), "custom_colour", "0")
      -- Third special-hitting
      SetTriggerOption(tostring("StatsMeleeSuccessThirdCatSpecial" .. iN), "custom_colour", "0")
      -- You hitting an enemy
      SetTriggerOption(tostring("QuowMeleeSuccessOutCat" .. iN), "custom_colour", "0")
      -- Enemy hitting you
      SetTriggerOption(tostring("QuowMeleeSuccessIncCat" .. iN), "custom_colour", "0")
      -- Third party hitting
      SetTriggerOption(tostring("StatsMeleeSuccessThirdCat" .. iN), "custom_colour", "0")
    end
    for iN = 1, 5 do
      -- Enemy defending you special-hitting
      SetTriggerOption(tostring("QuowMeleeFailOutCatSpecial" .. iN), "custom_colour", "0")
      -- You defending an enemy special-hitting
      SetTriggerOption(tostring("QuowMeleeFailIncCatSpecial" .. iN), "custom_colour", "0")
      -- Third party defending special-hitting
      SetTriggerOption(tostring("StatsMeleeFailThirdCatSpecial" .. iN), "custom_colour", "0")
      -- Enemy defending you
      SetTriggerOption(tostring("QuowMeleeFailOutCat" .. iN), "custom_colour", "0")
      -- You defending an enemy
      SetTriggerOption(tostring("QuowMeleeFailIncCat" .. iN), "custom_colour", "0")
      -- Third party defending
      SetTriggerOption(tostring("StatsMeleeFailThirdCat" .. iN), "custom_colour", "0")
    end
    for iN = 1, 3 do
      -- Enemy defends your special
      SetTriggerOption(tostring("QuowSpecialFailOutCat" .. iN), "custom_colour", "0")
      -- Your special hits
      SetTriggerOption(tostring("QuowSpecialSuccessOutCat" .. iN), "custom_colour", "0")
      -- You defend an enemy special
      SetTriggerOption(tostring("QuowSpecialFailIncCat" .. iN), "custom_colour", "0")
      -- Enemy hits you with a special
      SetTriggerOption(tostring("QuowSpecialSuccessIncCat" .. iN), "custom_colour", "0")
      -- Third party defends special
      SetTriggerOption(tostring("StatsSpecialFailThirdCat" .. iN), "custom_colour", "0")
      -- Third party hits special
      SetTriggerOption(tostring("StatsSpecialSuccessThirdCat" .. iN), "custom_colour", "0")
    end
    for iN = 1, iCustomCombatLinesFailNormal do
      if (IsTrigger("StatsMeleeFailThirdCat_Custom" .. iN) == 0) then
        -- You special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "custom_colour", "0")
      end
      if (IsTrigger("QuowMeleeSuccessIncCat_Custom" .. iN) == 0) then
        -- Enemy special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "custom_colour", "0")
      end
      if (IsTrigger("StatsMeleeSuccessThirdCat_Custom" .. iN) == 0) then
        -- Third party special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "custom_colour", "0")
      end
    end
    for iN = 1, iCustomCombatLinesNormal do
      if (IsTrigger("QuowMeleeSuccessOutCat_Custom" .. iN) == 0) then
        -- You special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("QuowMeleeSuccessOutCat_Custom" .. iN), "custom_colour", "0")
      end
      if (IsTrigger("QuowMeleeSuccessIncCat_Custom" .. iN) == 0) then
        -- Enemy special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("QuowMeleeSuccessIncCat_Custom" .. iN), "custom_colour", "0")
      end
      if (IsTrigger("StatsMeleeSuccessThirdCat_Custom" .. iN) == 0) then
        -- Third party special "standard" combat text (eg worm swords)
        SetTriggerOption(tostring("StatsMeleeSuccessThirdCat_Custom" .. iN), "custom_colour", "0")
      end
    end
    for iN = 1, iCustomCombatLinesSpecial do
      if (IsTrigger("QuowSpecialSuccessOutS" .. iN) == 0) then
        -- You pull off a big unique special
        SetTriggerOption(tostring("QuowSpecialSuccessOutS" .. iN), "custom_colour", "0")
      end
      if (IsTrigger("QuowSpecialSuccessIncS" .. iN) == 0) then
        -- Enemy pulls off a big unique special on you
        SetTriggerOption(tostring("QuowSpecialSuccessIncS" .. iN), "custom_colour", "0")
      end
      if (IsTrigger("StatsSpecialSuccessThirdS" .. iN) == 0) then
        -- Third party does some big unique special
        SetTriggerOption(tostring("StatsSpecialSuccessThirdS" .. iN), "custom_colour", "0")
      end
    end
    -- You get a kill
    SetTriggerOption(tostring("QuowKillStatOut1"), "custom_colour", "0")
    -- Enemy kills you
    SetTriggerOption(tostring("QuowKillStatInc1"), "custom_colour", "0")
    -- Third party kills
    SetTriggerOption(tostring("StatsKillStatThird1"), "custom_colour", "0")

    -- You defend against some unique special
    SetTriggerOption(tostring("QuowSpecialFailIncCustom1"), "custom_colour", "0")
    -- You defend against some unique special
    SetTriggerOption(tostring("QuowMiscFailInc1"), "custom_colour", "0")
    -- You defend against a thrown weapon
    SetTriggerOption(tostring("QuowThrowingFailInc1"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowThrowingFailInc2"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowThrowingFailInc3"), "custom_colour", "0")
    -- Third party fails to prepare a special on someone
    SetTriggerOption(tostring("StatsSpecialFailThirdCustom1"), "custom_colour", "0")
    SetTriggerOption(tostring("StatsSpecialFailThirdCustom2"), "custom_colour", "0")
    -- Third party defends against third parties thrown weapon
    SetTriggerOption(tostring("QuowThrowingFailThird1"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowThrowingFailThird2"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowThrowingFailThird3"), "custom_colour", "0")
    -- Ambushes, Absconds, and Backstabs
    SetTriggerOption(tostring("QuowSpecialBackstabSuccessOut"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowSpecialAmbushSuccessOut"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowSpecialAbscondSuccessOut"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowSpecialAmbushFailOut"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowSpecialBackstabSuccessInc"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowSpecialBackstabFailInc"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowSpecialBackstabFail2Inc"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowSpecialBackstabSuccessThird"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowSpecialAmbushSuccessThird"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowSpecialAmbushFailThird"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowSpecialAbscondSuccessThird"), "custom_colour", "0")
    -- Feints
    SetTriggerOption(tostring("QuowFeintSuccessIncoming1"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowFeintFailIncoming1"), "custom_colour", "0")
    SetTriggerOption(tostring("QuowFeintFailOutgoing1"), "custom_colour", "0")
  end
end

-- **********************************************
-- ***** Set up all the combat text colours *****
-- **********************************************
-- For shield event type

function ShieldsRecolour()
  for sCatType, objThisTriggerGroup in pairs(sShieldTriggerTypes) do
    for _, sThisTriggerName in pairs(objThisTriggerGroup) do
      SetTriggerOption(tostring(sThisTriggerName), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_" .. sCatType])))
    end
  end
end
-- For all combat types
function TriggersRecolour()
  SetTriggerOption(tostring("QuowMeleeSpecialPrepare1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_prep"])))
  SetTriggerOption(tostring("QuowMeleeSpecialPrepare2"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_prep"])))
  SetTriggerOption(tostring("QuowMeleeSpecialPrepare3"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_prep"])))
  -- You failing to prepare/do specials
  SetTriggerOption(tostring("QuowMeleeSpecialFail1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_fail"])))
  SetTriggerOption(tostring("QuowMeleeSpecialFail2"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_fail"])))
  SetTriggerOption(tostring("QuowMeleeSpecialFail3"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_fail"])))
  SetTriggerOption(tostring("QuowMeleeSpecialFail4"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_fail"])))
  SetTriggerOption(tostring("QuowMeleeSpecialFail5"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_fail"])))
  for iN = 1, 7 do
    -- You special-hitting an enemy
    SetTriggerOption(tostring("QuowMeleeSuccessOutCatSpecial" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_out_success"])))
    -- Enemy special-hitting you
    SetTriggerOption(tostring("QuowMeleeSuccessIncCatSpecial" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_success"])))
    -- Third party special-hitting
    SetTriggerOption(tostring("StatsMeleeSuccessThirdCatSpecial" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_success"])))
    -- You hitting an enemy
    SetTriggerOption(tostring("QuowMeleeSuccessOutCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_out_success"])))
    -- Enemy hitting you
    SetTriggerOption(tostring("QuowMeleeSuccessIncCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_inc_success"])))
    -- Third party hitting
    SetTriggerOption(tostring("StatsMeleeSuccessThirdCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_third_success"])))
  end
  for iN = 1, 5 do
    -- Enemy defending you special-hitting
    SetTriggerOption(tostring("QuowMeleeFailOutCatSpecial" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_out_fail"])))
    -- You defending an enemy special-hitting
    SetTriggerOption(tostring("QuowMeleeFailIncCatSpecial" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_fail"])))
    -- Third party defending special-hitting
    SetTriggerOption(tostring("StatsMeleeFailThirdCatSpecial" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_fail"])))
    -- Enemy defending you
    SetTriggerOption(tostring("QuowMeleeFailOutCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_out_fail"])))
    -- You defending an enemy
    SetTriggerOption(tostring("QuowMeleeFailIncCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_inc_fail"])))
    -- Third party defending
    SetTriggerOption(tostring("StatsMeleeFailThirdCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_third_fail"])))
  end
  for iN = 1, 3 do
    -- Enemy defends your special
    SetTriggerOption(tostring("QuowSpecialFailOutCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_out_fail"])))
    -- Your special hits
    SetTriggerOption(tostring("QuowSpecialSuccessOutCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_out_success"])))
    -- You defend an enemy special
    SetTriggerOption(tostring("QuowSpecialFailIncCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_fail"])))
    -- Enemy hits you with a special
    SetTriggerOption(tostring("QuowSpecialSuccessIncCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_success"])))
    -- Third party defends special
    SetTriggerOption(tostring("StatsSpecialFailThirdCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_fail"])))
    -- Third party hits special
    SetTriggerOption(tostring("StatsSpecialSuccessThirdCat" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_success"])))
  end
  for iN = 1, iCustomCombatLinesFailNormal do
    if (IsTrigger("StatsMeleeFailThirdCat_Custom" .. iN) == 0) then
      -- You special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_out_fail"])))
    end
    if (IsTrigger("QuowMeleeSuccessIncCat_Custom" .. iN) == 0) then
      -- Enemy special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_inc_fail"])))
    end
    if (IsTrigger("StatsMeleeSuccessThirdCat_Custom" .. iN) == 0) then
      -- Third party special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("StatsMeleeFailThirdCat_Custom" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_third_fail"])))
    end
  end
  for iN = 1, iCustomCombatLinesNormal do
    if (IsTrigger("QuowMeleeSuccessOutCat_Custom" .. iN) == 0) then
      -- You special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("QuowMeleeSuccessOutCat_Custom" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_out_success"])))
    end
    if (IsTrigger("QuowMeleeSuccessIncCat_Custom" .. iN) == 0) then
      -- Enemy special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("QuowMeleeSuccessIncCat_Custom" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_inc_success"])))
    end
    if (IsTrigger("StatsMeleeSuccessThirdCat_Custom" .. iN) == 0) then
      -- Third party special "standard" combat text (eg worm swords)
      SetTriggerOption(tostring("StatsMeleeSuccessThirdCat_Custom" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_third_success"])))
    end
  end
  for iN = 1, iCustomCombatLinesSpecial do
    if (IsTrigger("QuowSpecialSuccessOutS" .. iN) == 0) then
      -- You pull off a big unique special
      SetTriggerOption(tostring("QuowSpecialSuccessOutS" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_out_success"])))
    end
    if (IsTrigger("QuowSpecialSuccessIncS" .. iN) == 0) then
      -- Enemy pulls off a big unique special on you
      SetTriggerOption(tostring("QuowSpecialSuccessIncS" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_success"])))
    end
    if (IsTrigger("StatsSpecialSuccessThirdS" .. iN) == 0) then
      -- Third party does some big unique special
      SetTriggerOption(tostring("StatsSpecialSuccessThirdS" .. iN), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_success"])))
    end
  end
  -- You get a kill
  SetTriggerOption(tostring("QuowKillStatOut1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_out_kill"])))
  -- Enemy kills you
  SetTriggerOption(tostring("QuowKillStatInc1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_inc_kill"])))
  -- Third party kills
  SetTriggerOption(tostring("StatsKillStatThird1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_third_kill"])))

  -- You defend against some unique special
  SetTriggerOption(tostring("QuowSpecialFailIncCustom1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_fail"])))
  -- You defend against some unique special
  SetTriggerOption(tostring("QuowMiscFailInc1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_fail"])))
  -- You defend against a thrown weapon
  SetTriggerOption(tostring("QuowThrowingFailInc1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_inc_fail"])))
  SetTriggerOption(tostring("QuowThrowingFailInc2"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_inc_fail"])))
  SetTriggerOption(tostring("QuowThrowingFailInc3"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_melee_inc_fail"])))
  -- Third party fails to prepare a special on someone
  SetTriggerOption(tostring("StatsSpecialFailThirdCustom1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_fail"])))
  SetTriggerOption(tostring("StatsSpecialFailThirdCustom2"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_fail"])))
  -- Third party defends against third parties thrown weapon
  SetTriggerOption(tostring("QuowThrowingFailThird1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_fail"])))
  SetTriggerOption(tostring("QuowThrowingFailThird2"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_fail"])))
  SetTriggerOption(tostring("QuowThrowingFailThird3"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_fail"])))
  -- Ambushes, Absconds, and Backstabs
  SetTriggerOption(tostring("QuowSpecialBackstabSuccessOut"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_out_success"])))
  SetTriggerOption(tostring("QuowSpecialAmbushSuccessOut"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_out_success"])))
  SetTriggerOption(tostring("QuowSpecialAbscondSuccessOut"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_out_success"])))
  SetTriggerOption(tostring("QuowSpecialAmbushFailOut"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_out_fail"])))
  SetTriggerOption(tostring("QuowSpecialBackstabSuccessInc"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_success"])))
  SetTriggerOption(tostring("QuowSpecialBackstabFailInc"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_fail"])))
  SetTriggerOption(tostring("QuowSpecialBackstabFail2Inc"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_fail"])))
  SetTriggerOption(tostring("QuowSpecialBackstabSuccessThird"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_success"])))
  SetTriggerOption(tostring("QuowSpecialAmbushSuccessThird"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_success"])))
  SetTriggerOption(tostring("QuowSpecialAmbushFailThird"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_fail"])))
  SetTriggerOption(tostring("QuowSpecialAbscondSuccessThird"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_third_success"])))
  -- Feints
  SetTriggerOption(tostring("QuowFeintSuccessIncoming1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_success"])))
  SetTriggerOption(tostring("QuowFeintFailIncoming1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_inc_fail"])))
  SetTriggerOption(tostring("QuowFeintFailOutgoing1"), "other_text_colour", tostring(ColourNameToRGB(sUSER_OPTIONS["col_special_out_fail"])))
end



-- *****************************************
-- ***** Combat Stats full text report *****
-- *****************************************

function GenerateStatsReport()
  ColourNote(sCOLOUR.silver, "", "Full Combat Stats for stat set " .. iCurrentCombatStatSet .. " '" .. iQuowCombatStats[iCurrentCombatStatSet]["set_name"] .. "':")
  ColourNote(sCOLOUR.silver, "", "Stat:                     Enemies:      You:")
  ColourNote(sCOLOUR.orange, "", "=-=-==-=-=-=-=-=-=-=-=-=  =-=-=-=-=-=-  =-=-=-=-=-=-")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "Total Kills:"))
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["deaths_total"]))
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["kills_total"])
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "Total Rounds:"))
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", "-"))
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"])
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "..Hits Per Round:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"] > 0) and string.format("%.2f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] / iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"]) or "0"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"] > 0) and string.format("%.2f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] / iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"]) or "0"
  ColourTell(sCOLOUR.green, "", sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "..Kills Per Round:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"] > 0) and string.format("%.2f", iQuowCombatStats[iCurrentCombatStatSet]["deaths_total"] / iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"]) or "0"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"] > 0) and string.format("%.2f", iQuowCombatStats[iCurrentCombatStatSet]["kills_total"] / iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"]) or "0"
  ColourTell(sCOLOUR.green, "", sPerc)
  Note("")

  local iTotalSpecials = iQuowCombatStats[iCurrentCombatStatSet]["special_out_prepared"] + iQuowCombatStats[iCurrentCombatStatSet]["special_out_failprepared"]

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "Total Special Prepares:"))
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", "-"))
  ColourTell(sCOLOUR.green, "", iTotalSpecials)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "...Successful Prepares:"))
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", "-"))
  sPerc = (iTotalSpecials > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["special_out_prepared"] / iTotalSpecials * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["special_out_prepared"] .. sPerc)
  Note("")
  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "...Failed Prepares:"))
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", "-"))
  sPerc = (iTotalSpecials > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["special_out_failprepared"] / iTotalSpecials * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["special_out_failprepared"] .. sPerc)
  Note("")

  local iTotalSpecialsOut = iQuowCombatStats[iCurrentCombatStatSet]["special_out_landed"] + iQuowCombatStats[iCurrentCombatStatSet]["special_out_defended"]
  local iTotalSpecialsInc = iQuowCombatStats[iCurrentCombatStatSet]["special_inc_landed"] + iQuowCombatStats[iCurrentCombatStatSet]["special_inc_defended"]

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "Total Specials Against:"))
  ColourTell(sCOLOUR.green, "", string.format("%-13s ", iTotalSpecialsOut))
  ColourTell(sCOLOUR.red, "", iTotalSpecialsInc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "...Specials Landed On:"))
  sPerc = (iTotalSpecialsOut > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["special_out_landed"] / iTotalSpecialsOut * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["special_out_landed"] .. sPerc))
  sPerc = (iTotalSpecialsInc > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["special_inc_landed"] / iTotalSpecialsInc * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", iQuowCombatStats[iCurrentCombatStatSet]["special_inc_landed"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "...Specials Defended By:"))
  sPerc = (iTotalSpecialsOut > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["special_out_defended"] / iTotalSpecialsOut * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["special_out_defended"] .. sPerc))
  sPerc = (iTotalSpecialsInc > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["special_inc_defended"] / iTotalSpecialsInc * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["special_inc_defended"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "Total Hit Attempts:"))
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"]))
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"])
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "...Hits Landed:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_landed"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_landed"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_landed"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_landed"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "...Hits Defended:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "......Dodged:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] .. sPerc)
  Note("")
  -- Break down the dodges
  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", ".........Barely:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged_barely"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged_barely"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged_barely"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged_barely"] .. sPerc)
  Note("")
  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", ".........Average:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged_normal"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged_normal"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged_normal"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged_normal"] .. sPerc)
  Note("")
  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", ".........Good:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged_deftly"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged_deftly"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged_deftly"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged_deftly"] .. sPerc)
  Note("")
  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", ".........Somehow Avoid:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged_somehow"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged_somehow"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged_somehow"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged_somehow"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "......Parried:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] .. sPerc)
  Note("")
  -- Break down the parries
  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", ".........Barely:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried_barely"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried_barely"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried_barely"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried_barely"] .. sPerc)
  Note("")
  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", ".........Average:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried_normal"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried_normal"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried_normal"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried_normal"] .. sPerc)
  Note("")
  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", ".........Good:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried_deftly"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried_deftly"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried_deftly"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried_deftly"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "......Blocked:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] .. sPerc)
  Note("")
  -- Break down the blocks
  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", ".........Barely:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked_barely"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked_barely"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked_barely"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked_barely"] .. sPerc)
  Note("")
  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", ".........Average:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked_normal"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked_normal"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked_normal"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked_normal"] .. sPerc)
  Note("")
  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", ".........Good:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked_deftly"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked_deftly"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked_deftly"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked_deftly"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "......Zone Focus:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_zonefail"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_zonefail"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_zonefail"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_zonefail"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "......TPA:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_tpa"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_tpa"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_tpa"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_tpa"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "......Major:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_major"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_major"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_major"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_major"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "......Bug Shield:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_bugs"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_bugs"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_bugs"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_bugs"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "......EFF:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_eff"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_eff"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_eff"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_eff"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "......CCC Full Absorb:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_ccc"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_ccc"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_ccc"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_ccc"] .. sPerc)
  Note("")

  ColourTell(sCOLOUR.silver, "", string.format("%-25s ", "......Armour Full Absorb:"))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_armoured"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.red, "", string.format("%-13s ", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_armoured"] .. sPerc))
  sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_armoured"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
  ColourTell(sCOLOUR.green, "", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_armoured"] .. sPerc)
  Note("")

end


-- ****************************************
-- ***** Combat Stats window handling *****
-- ****************************************

function RedrawStatsWindow()
  -- Save effort, do nothing if not showing this window
  if (WINDATA[winStats]["SHOW"] == false or iQuowCombatStats[iCurrentCombatStatSet] == nil) then
    return
  end

  -- Clear the window afresh and draw a new border
  WindowRectOp(winStats, miniwin.rect_fill, 0, 0, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], iCOLOUR.black)

  local sPerc
  local iY = 2
  local sUseFont
  local iThisLineHeight = iFontSizes[winStats]["lineheight"]
  if (WINDATA[winStats]["WIDTH"] < 250 or WINDATA[winStats]["HEIGHT"] < 200) then
    sUseFont = "bodyfont"
  elseif (WINDATA[winStats]["WIDTH"] < 400 or WINDATA[winStats]["HEIGHT"] < 300) then
    sUseFont = "bodyfontm"
    iThisLineHeight = iThisLineHeight + 3
  else
    sUseFont = "bodyfontl"
    iThisLineHeight = iThisLineHeight + 7
  end

  local iCheckWidth = WindowTextWidth(winStats, sUseFont, "Total Rounds:")
  local iCol1 = 2
  local iCol2 = iCheckWidth + 4
  local iCol3 = math.floor(2 + (WINDATA[winStats]["WIDTH"] * 0.65))

  WindowText(winStats, sUseFont, "Stats for set '" .. tostring(iQuowCombatStats[iCurrentCombatStatSet]["set_name"]) .. "' [" .. iCurrentCombatStatSet .. "]", 2, iY, 0, 0, iCOLOUR.silver, false)
  iY = iY + iThisLineHeight

  -- Is window big enough for side by side columns or not?
  if (iCheckWidth >= (WINDATA[winStats]["WIDTH"] * 0.3)) then
    iCol3 = iCol2
    WindowText(winStats, sUseFont, "Stat: ", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    WindowText(winStats, sUseFont, "You: ", iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Kills:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["kills_total"], iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Hits/Round:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"] > 0) and string.format("%.2f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] / iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"]) or "0"
    WindowText(winStats, sUseFont, sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Total Rounds:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"], iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Total Hits:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"], iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Landed:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_landed"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_landed"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Defended:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Dodged:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Parried:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Blocked:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Focus:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_zonefail"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_zonefail"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..TPA:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_tpa"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_tpa"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Major:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_major"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_major"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Bugs:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_bugs"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_bugs"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..EFF:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_eff"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_eff"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..CCC:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_ccc"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_ccc"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Armour:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_armoured"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_armoured"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Stat: ", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    WindowText(winStats, sUseFont, "Enemies: ", iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Kills:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["deaths_total"], iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Hits/Round:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"] > 0) and string.format("%.2f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] / iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"]) or "0"
    WindowText(winStats, sUseFont, sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Total Hits:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"], iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Landed:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_landed"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_landed"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Defended:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Dodged:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Parried:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Blocked:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Focus:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_zonefail"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_zonefail"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..TPA:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_tpa"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_tpa"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Major:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_major"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_major"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Bugs:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_bugs"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_bugs"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..EFF:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_eff"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_eff"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..CCC:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_ccc"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_ccc"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Armour:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_armoured"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_armoured"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    iY = iY + iThisLineHeight
  else
    WindowText(winStats, sUseFont, "Stat: ", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    WindowText(winStats, sUseFont, "Enemies: ", iCol2, iY, 0, 0, iCOLOUR.red, false)
    WindowText(winStats, sUseFont, "You: ", iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Kills:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["deaths_total"], iCol2, iY, 0, 0, iCOLOUR.red, false)
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["kills_total"], iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Hits/Round:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"] > 0) and string.format("%.2f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] / iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"]) or "0"
    WindowText(winStats, sUseFont, sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"] > 0) and string.format("%.2f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] / iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"]) or "0"
    WindowText(winStats, sUseFont, sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Total Rounds:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["rounds_total"], iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Total Hits:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"], iCol2, iY, 0, 0, iCOLOUR.red, false)
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"], iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Landed:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_landed"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_landed"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_landed"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_landed"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "Defended:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Dodged:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_dodged"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_dodged"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Parried:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_parried"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_parried"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Blocked:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended_blocked"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended_blocked"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Focus:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_zonefail"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_zonefail"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_zonefail"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_zonefail"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..TPA:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_tpa"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_tpa"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_tpa"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_tpa"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Major:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_major"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_major"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_major"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_major"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Bugs:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_bugs"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_bugs"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_bugs"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_bugs"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..EFF:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_eff"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_eff"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_eff"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_eff"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..CCC:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_ccc"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_ccc"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_ccc"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_ccc"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
    WindowText(winStats, sUseFont, "..Armour:", iCol1, iY, 0, 0, iCOLOUR.silver, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_out_armoured"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_out_armoured"] .. sPerc, iCol2, iY, 0, 0, iCOLOUR.red, false)
    sPerc = (iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] > 0) and " [" .. string.format("%.1f", iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_armoured"] / iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] * 100) .. "%]" or " [0%]"
    WindowText(winStats, sUseFont, iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_armoured"] .. sPerc, iCol3, iY, 0, 0, iCOLOUR.green, false)
    iY = iY + iThisLineHeight
  end
  -- Border the whole window
  WindowRectOp(winStats, miniwin.rect_frame, 0, 0, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], winThemeData.WINDOW_BORDER)
end


-- *****************************************
-- ***** Draw Disc Date on the Minimap *****
-- *****************************************
function UpdateDiscDate()
  -- Update Disc game date if needed
  if (bShowDiscDate == true) then
    DrawDiscDate(true)
    Redraw()
  end
end

function DrawDiscDate(bRedoBrightness)
  local iSeconds, iMinutes, iHours, sAMPM, iHoursTwelve, iDayInYear, iDayInWeek, iYears, iCycle, iMonth, iDayInMonth, sDiscMonth, sDiscShortMonth, sDiscDay, sDiscShortDay, sDiscCycle, sDiscShortCycle, sDay = UnixTimeDiscTime()
  local sDiscGameTime = iHoursTwelve .. ":" .. string.format("%02d", iMinutes) .. sAMPM .. " "
  local sDiscGameDateLong = sDay .. " " .. DateOrdinal(iDayInMonth) .. " " .. sDiscMonth -- .. " " .. sDiscCycle .. " UC " .. iYears
  local sDiscGameDateShort = sDiscShortDay .. " " .. DateOrdinal(iDayInMonth) .. " " .. sDiscShortMonth -- .. " " .. sDiscShortCycle .. " UC " .. iYears
  local iCheckWidthTime = WindowTextWidth(winMinimap, "bodyfont", sDiscGameTime)
  local iCheckWidthDateLong = WindowTextWidth(winMinimap, "bodyfont", sDiscGameDateLong)
  local iCheckWidthDateShort = WindowTextWidth(winMinimap, "bodyfont", sDiscGameDateShort)
  local iDrawHeight = iFontSizes[winMinimap]["lineheight"]
  if ((iCheckWidthTime + iCheckWidthDateLong) <= WINDATA[winMinimap]["WIDTH"]) then
    WindowRectOp(winMinimap, miniwin.rect_fill, 0, WINDATA[winMinimap]["HEIGHT"] - iDrawHeight, WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"], iCOLOUR.white)
    WindowText(winMinimap, "bodyfont", sDiscGameTime .. sDiscGameDateLong, 1, WINDATA[winMinimap]["HEIGHT"] - iFontSizes[winMinimap]["lineheight"], 0, 0, iCOLOUR.date)
  elseif ((iCheckWidthTime + iCheckWidthDateShort) <= WINDATA[winMinimap]["WIDTH"]) then
    WindowRectOp(winMinimap, miniwin.rect_fill, 0, WINDATA[winMinimap]["HEIGHT"] - iDrawHeight, WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"], iCOLOUR.white)
    WindowText(winMinimap, "bodyfont", sDiscGameTime .. sDiscGameDateShort, 1, WINDATA[winMinimap]["HEIGHT"] - iFontSizes[winMinimap]["lineheight"], 0, 0, iCOLOUR.date)
  else
    iDrawHeight = iFontSizes[winMinimap]["lineheight"] * 2
    WindowRectOp(winMinimap, miniwin.rect_fill, 0, WINDATA[winMinimap]["HEIGHT"] - iDrawHeight, WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"], iCOLOUR.white)
    WindowText(winMinimap, "bodyfont", sDiscGameTime, 1, WINDATA[winMinimap]["HEIGHT"] - (iFontSizes[winMinimap]["lineheight"] * 2), 0, 0, iCOLOUR.date)
    WindowText(winMinimap, "bodyfont", sDiscGameDateShort, 1, WINDATA[winMinimap]["HEIGHT"] - iFontSizes[winMinimap]["lineheight"], 0, 0, iCOLOUR.date)
  end
  WindowLine(winMinimap, 0, WINDATA[winMinimap]["HEIGHT"] - iDrawHeight, WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"] - iDrawHeight, iCOLOUR.date, 0, 1)

  -- Change brightness of the freshly drawn date box window
  if (bRedoBrightness == true and iMinimapBrightness < 100) then
    WindowFilter (winMinimap, 0, WINDATA[winMinimap]["HEIGHT"] - iDrawHeight, WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"], 21, (iMinimapBrightness / 100))
  end

end


-- **************************************************
-- ***** Generate Discworld Date from real time *****
-- **************************************************
-- Discworld month names
sDiscMonthNames = { [0] = "Offle", "February", "March", "April", "May", "June", "Grune", "August", "Spune", "Sektober", "Ember", "December", "Ick", "Off", "Feb", "Mar", "Apr", "May", "Jun", "Gru", "Aug", "Spu", "Sek", "Emb", "Dec", "Ick" }
-- Discworld day names
sDiscDayNames  = { [0] = "Octeday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", "Oct", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" }
-- Discworld days-per-month
iDiscDaysPerMonth= { [0] = 32,32,32,32,32,32,32,32,32,32,32,32,16 }
-- Discworld prime year cycles
sDiscCycles = { [0] = "Prime", "Secundus", "I", "II" }
-- Ordinals
sDateOrdinals = {"st", "nd", "rd"}
-- Generate the ordinal string, nd, th etc. to a given day number
function DateOrdinal(iDay)
  local iDigit = tonumber(string.sub(iDay, -1))
  if (iDigit > 0 and iDigit <= 3 and iDay ~= 11 and iDay ~= 12 and iDay ~= 13) then
    return iDay .. sDateOrdinals[iDigit]
  else
    return iDay .. "th"
  end
end
function UnixTimeDiscTime( iRealTime )
  -- If no timestamped passed, default to current time
  if (iRealTime == nil) then 
    iRealTime = OST() 
  end
  local fmod, floor = math.fmod, math.floor
  -- Convert time (in seconds) to the different time elements
  local iSeconds = floor(fmod(iRealTime, 18))
  local iMinutes = floor(fmod(iRealTime, 18*60)/18)
  local iHours = floor(fmod(iRealTime, 18*60*24)/(18*60))
  local iHoursTwelve = fmod(iHours, 12) 
  if (iHoursTwelve == 0) then iHoursTwelve = 12 end
  local sAMPM = (iHours > 11) and "pm" or "am"
  local iDayInYear = floor(fmod(iRealTime, 18*60*24*400)/(18*60*24))
  local iDayInWeek = floor(fmod(iRealTime+(18*60*24*5), 18*60*24*8)/(18*60*24))
  local iYears = floor(iRealTime/(18*60*24*400*2)) + 1966
  local iCycle = floor(fmod((iRealTime/(18*60*24*400)),2))
  -- Calculate which month the time is in
  local iTotalDays = iDayInYear
  local iMonth = 0 
  while (iTotalDays >= iDiscDaysPerMonth[iMonth]) do
    iTotalDays = iTotalDays - iDiscDaysPerMonth[iMonth]
    iMonth = iMonth + 1 
  end
  iDayInMonth = iTotalDays + 1
  -- Get the special day name else the normal day name
  local sSpecialDay, sDayName
  if iMonth==0 and iDayInMonth==1 then
    if iCycle==0 then sSpecialDay = "Hogswatch" 
    else sSpecialDay = "Crueltide" 
    end
  end
  if (iMonth == 6 and iDayInMonth == 16) then
    sSpecialDay = "Small Gods day"
  end
  if (iMonth == 7 and iDayInMonth == 23) then
    sSpecialDay = "Soul Cake Tuesday"
  end
  if (iMonth == 9 and iDayInMonth == 1) then
    sSpecialDay = "Sektober Fools' Day"
  end
  if (sSpecialDay) then 
    sDayName = sSpecialDay 
  else
    sDayName = sDiscDayNames[iDayInWeek]
  end
  -- Return it all
  return iSeconds, iMinutes, iHours, sAMPM, iHoursTwelve, iDayInYear, iDayInWeek, iYears, iCycle, iMonth, iDayInMonth, sDiscMonthNames[iMonth], sDiscMonthNames[iMonth + 13], sDiscDayNames[iDayInWeek], sDiscDayNames[iDayInWeek+8], sDiscCycles[iCycle], sDiscCycles[iCycle+2], sDayName
end


-- **********************************
-- ***** Redraw Hotspots Window *****
-- **********************************
function RedrawHotspotsWindow()
  local bShowWindow = WINDATA[winHotspots]["SHOW"]
  -- Save effort, don't draw if not showing, but we still need the timers for notifications
  if (bShowWindow == true) then
    WindowRectOp(winHotspots, miniwin.rect_fill, 0, 0, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], iCOLOUR.black)
    WindowRectOp(winHotspots, miniwin.rect_frame, 0, 0, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], winThemeData.WINDOW_BORDER)
  end-- Loop through our timers
  local iCurTime, iYWindow, iTimeSince, sTimeString, DoFloor, DoMod, DoFormat, objHotspot = os.time(), WINDATA[winHotspots]["HEIGHT"] - 3 - iFontSizes[winHotspots]["lineheight"], 0, "", math.floor, math.fmod, string.format, nil
  for _, objThisHotspot in ipairs(sHotspotSortedOrder) do
    objHotspot = sHotspotData[objThisHotspot[1]]
    iTimeSince = iCurTime - objHotspot["time_seen"]
    local iTempHotColour = objHotspot["colour"]
    local sTempHotName = tostring(objHotspot["hotspot_name"])
    sTimeString = DoFormat("%02d:%02d:%02d", DoFloor(iTimeSince/3600), DoFloor(DoMod(iTimeSince, 3600)/60), DoFloor(DoMod(iTimeSince,60)))
    if (bShowWindow == true and iYWindow > -iFontSizes[winHotspots]["lineheight"]) then
      WindowText(winHotspots, "bodyfont", sTimeString .. " : " .. sTempHotName, 4, iYWindow, 0, 0, iTempHotColour)
      iYWindow = iYWindow - iFontSizes[winHotspots]["lineheight"]
    end
    -- Do notifications
    if (objHotspot["notified"] == 0 and iTimeSince >= objHotspot["timeafter_notify"] and sTempHotName ~= nil) then
      sHotspotData[objThisHotspot[1]]["notified"] = 1
      local sTimerText = "' timer has now passed " .. tostring(math.floor(objHotspot["timeafter_notify"] / 60)) .. " minutes."
      ColourNote(sCOLOUR.orange, "", "Hotspot '", RGBColourToName(iTempHotColour), "", sTempHotName, sCOLOUR.orange, "", sTimerText)
      -- And to chat window?
      if (bHotspotsChatWindow == true) then
        local objThisStyle = {
          [1] = {["textcolour"] = iCOLOUR.orange, ["backcolour"] = 0, ["text"] = "Hotspot '", ["length"] = 9},
          [2] = {["textcolour"] = objHotspot["colour"], ["backcolour"] = 0, ["text"] = tostring(objHotspot["hotspot_name"]), ["length"] = string.len(tostring(objHotspot["hotspot_name"]))},
          [3] = {["textcolour"] = iCOLOUR.orange, ["backcolour"] = 0, ["text"] = sTimerText, ["length"] = string.len(sTimerText)},
        }
        HandleCommsMessage("CommLog_Tells_In", "Hotspot '" .. tostring(objHotspot["hotspot_name"]) .. sTimerText, "", objThisStyle)
      end
    end
  end
  -- No hotspots to display?
  if (#sHotspotSortedOrder == 0 and bShowWindow == true) then
    WindowText(winHotspots, "bodyfont", "(No Hotspots Added)", 4, WINDATA[winHotspots]["HEIGHT"] - 3 - iFontSizes[winHotspots]["lineheight"], 0, 0, iCOLOUR.silver)
  end
  -- And now force-refresh the entire window, or let MUSHclient do it "gently"?
  if (bHotspotsPrioritiseRedraw == true) then
    Repaint()
  else
    Redraw()
  end
end


-- ********************************************************
-- ***** Send out Sync data for group-Hotspot sharing *****
-- ********************************************************
function HotspotOutputList()
  -- Loop through our timers
  local iCurTime, iTimeSince, sTimeString, DoFloor, DoMod, DoFormat, objHotspot = os.time(), 0, "", math.floor, math.fmod, string.format, nil
  Note("Cow Bar hotspot timers:")
  Note("-----------------------")
  for _, objThisHotspot in ipairs(sHotspotSortedOrder) do
    objHotspot = sHotspotData[objThisHotspot[1]]
    iTimeSince = iCurTime - objHotspot["time_seen"]
    sTimeString = DoFormat("%02d:%02d:%02d", DoFloor(iTimeSince/3600), DoFloor(DoMod(iTimeSince, 3600)/60), DoFloor(DoMod(iTimeSince,60)))
    ColourTell(RGBColourToName(objHotspot["colour"]), "", sTimeString .. " : " )
    -- If this hotspot has a valid room-ID link, then give a clickable link to show that room on the map, else just plaintext
    if ((objHotspot["trigger_type"] == 1 or objHotspot["trigger_type"] == 2) and sQuowLocationsByRoomID[objHotspot["roomid_reset"]] ~= nil) then
      Hyperlink("!!bfe35205f026786ea1d56e3b:QuowJumpToRoomID(" .. objHotspot["roomid_reset"] .. ")", objHotspot["hotspot_name"], "Display this hotspot room on the minimap", RGBColourToName(objHotspot["colour"]), "", 0)
    else
      ColourTell(RGBColourToName(objHotspot["colour"]), "", objHotspot["hotspot_name"])
    end
    Note("")
  end
  Note("----- end of list -----")
end


-- ********************************************************
-- ***** Send out Sync data for group-Hotspot sharing *****
-- ********************************************************
function HotspotGroupSyncSend()
  local sSyncTimeString = ""
  for iHotspotID, objHotspot in pairs(sHotspotData) do
    if (sSyncTimeString ~= "") then
      sSyncTimeString = sSyncTimeString .. ","
    end
    sSyncTimeString = sSyncTimeString .. objHotspot["hotspot_name"] .. "," .. (objHotspot["time_seen"] - 1537000000)
  end
  if (sSyncTimeString ~= "") then
    Send("group say CowBarHotspotSync:" .. sSyncTimeString)
  else
    Note("Quow's Cow Bar cannot share hotspot timer with group - no hotspots detected.")
  end
end

-- ***********************************************************
-- ***** Handle seeing potential hotspot sync group chat *****
-- ***********************************************************
function HandleHotspotSync (sName, sLine, sWildcards)
  local sCheckPlayerName = string.gsub(sWildcards[2], "%f[%a].", string.upper)
  if (sCheckPlayerName ~= sMyPlayerName) then
    if (sGroupMembers[sCheckPlayerName] ~= nil) then
      local sIncomingSyncHotspots = QuowSplit(sWildcards[3],",")
      if (sIncomingSyncHotspots ~= nil and sIncomingSyncHotspots[1] ~= nil and sIncomingSyncHotspots[2] ~= nil) then
        local sHotspotUniqueNames = {}
        for iHotspotID, objHotspot in pairs(sHotspotData) do
          sHotspotUniqueNames[string.lower(objHotspot["hotspot_name"])] = iHotspotID
        end
        local iNowTime = os.time()
        local iTotalSyncs = 0
        for iN = 1, #sIncomingSyncHotspots, 2 do
          if (sHotspotUniqueNames[string.lower(sIncomingSyncHotspots[iN])] ~= nil) then
            if (sIncomingSyncHotspots[iN + 1] ~= nil and tonumber(sIncomingSyncHotspots[iN + 1]) > 0) then
              local iSyncHotspotID = sHotspotUniqueNames[string.lower(sIncomingSyncHotspots[iN])]
              sHotspotData[iSyncHotspotID]["time_seen"] = tonumber(sIncomingSyncHotspots[iN + 1]) + 1537000000
              iTotalSyncs = iTotalSyncs + 1
              if (sHotspotData[iSyncHotspotID]["timeafter_notify"] > 0 and sHotspotData[iSyncHotspotID]["time_seen"] < (sHotspotData[iSyncHotspotID]["time_seen"] + sHotspotData[iSyncHotspotID]["timeafter_notify"])) then
                sHotspotData[iSyncHotspotID]["notified"] = 0
              end
            end
          end
        end
        ReSortHotspots()
        RedrawHotspotsWindow()
        ColourNote(sCOLOUR.silver, "", "Quow's Cow Bar:  Synced a total of " .. iTotalSyncs .. " matching hotspot times.")
      end
    else
      --
      ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar:")
      ColourNote(sCOLOUR.silver, "", "A hotspot sync was detected, but the group member '" .. tostring(sWildcards[2]) .. "' was not recognised.")
      ColourTell(sCOLOUR.silver, "", "Try and ")
      Hyperlink ("minimap group reset", "refresh group status and shields", "", sCOLOUR.cyan, "", 0)
      ColourNote(sCOLOUR.silver, "", " before requesting another sync.")
    end
  end -- Not our own chat
end -- end HandleHotspotSync function

-- A user's trigger-text has been seen to reset a timer
function QuowHandleHotspotTrigger(sName)
  local iThisHotspotID = tonumber(string.sub(sName, 9))
  if (sHotspotData[iThisHotspotID] ~= nil) then
    sHotspotData[iThisHotspotID]["time_seen"] = os.time()
    if (sHotspotData[iThisHotspotID]["timeafter_notify"] > 0) then
      sHotspotData[iThisHotspotID]["notified"] = 0
    end
    ReSortHotspots()
    RedrawHotspotsWindow()
  end
end


-- ***********************************
-- ***** Redraw Ascii Map Window *****
-- ***********************************
iAsciiMapLines = 0
sASCIIMapLineStyles = {}
sAsciiMapString = ""
bAsciiFoundMatch = true
bAsciiShownWarning = false
bFreshWelcome = false
iASCIIWidth = 0
iAsciiPlayerX = 0
iAsciiPlayerY = 0
bAsciiSeenYellow = false
iMUDYellow = ColourNameToRGB("yellow")
function RedrawAsciiWindow()
  -- Save effort, do nothing if not showing this window
  if (WINDATA[winAscii]["SHOW"] == false) then
    return
  end
  WindowRectOp(winAscii, miniwin.rect_fill, 0, 0, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], iCOLOUR.black)
  WindowRectOp(winAscii, miniwin.rect_frame, 0, 0, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], winThemeData.WINDOW_BORDER)
  if (#sASCIIMapLineStyles ~= 0) then
    -- map display
    local iAsciiWidth = iASCIIWidth * iFontSizes[winAscii]["fontwidth"]
    local iAsciiHeight = #sASCIIMapLineStyles * iFontSizes[winAscii]["lineheight"]
    local iAsciiPlayerCentreX = (iAsciiWidth * 0.5) - ((iAsciiPlayerX * iFontSizes[winAscii]["fontwidth"]) - (iFontSizes[winAscii]["fontwidth"] * 0.5))
    local iAsciiPlayerCentreY = (iAsciiHeight * 0.5) - ((iAsciiPlayerY * iFontSizes[winAscii]["lineheight"]) - (iFontSizes[winAscii]["lineheight"] * 0.5))
    local iAddLeft = ((WINDATA[winAscii]["WIDTH"] - iAsciiWidth) * 0.5) + iAsciiPlayerCentreX
    local iAddTop = ((WINDATA[winAscii]["HEIGHT"] - iAsciiHeight) * 0.5) + iAsciiPlayerCentreY
    local iLeft, iTop
    for iLineNum, sStyleData in ipairs (sASCIIMapLineStyles) do
      iLeft, iTop = iAddLeft, (iAddTop + ((iLineNum - 1) * iFontSizes[winAscii]["lineheight"]))
      for _, sThisStyle in ipairs (sStyleData) do
        iLeft = iLeft + WindowText (winAscii, "bodyfont", sThisStyle.text, iLeft, iTop, 0, 0, sThisStyle.textcolour)
      end
    end
  else
    WindowText (winAscii, "bodyfont", "@", (WINDATA[winAscii]["WIDTH"] - iFontSizes[winAscii]["fontwidth"]) * 0.5, (WINDATA[winAscii]["HEIGHT"] - iFontSizes[winAscii]["lineheight"]) * 0.5, 0, 0, iCOLOUR.silver)
  end
end


-- Handle map redirection triggers
function HandleAsciiMapRedirection (sName, sLine, sWildcards, objStyles)
  -- Insert THIS map line into the map table, objStyles and all
  bAsciiFoundMatch = true
  table.insert (sASCIIMapLineStyles, objStyles)
  if (string.len(sLine) > iASCIIWidth) then
    iASCIIWidth = string.len(sLine)
  end
  -- Find player location - ideally a yellow one, if not then any @ symbol
  if (bAsciiSeenYellow == false) then
    local iTempXPos, iWhereAt = 0, 0
    for iStyleKey, sThisStyle in ipairs (objStyles) do
      iWhereAt = string.find(sThisStyle.text, "@")
      if (sThisStyle.text == "@" and sThisStyle.textcolour == iMUDYellow) then
        bAsciiSeenYellow = true
        iAsciiPlayerX = iTempXPos + 1
        iAsciiPlayerY = #sASCIIMapLineStyles
        break
      elseif (bAsciiSeenYellow == false and iWhereAt ~= nil) then
        iAsciiPlayerX = iWhereAt + iTempXPos
        iAsciiPlayerY = #sASCIIMapLineStyles
      end
      iTempXPos = iTempXPos + string.len(sThisStyle.text)
    end
  end
  -- Final line?
  iAsciiMapLines = iAsciiMapLines - 1
  if (iAsciiMapLines == 0) then
    EnableTrigger("AsciiMapLine", false)
    RedrawAsciiWindow()
    -- Room creation handlers
    if (bDebugMode == true and bCreatingRooms == true and bCreatingActualNewRooms == true and bHandlerDesc ~= nil and bHandlerDesc == true) then
      EnableTrigger("RoomDescHandling", true)
    end
  end
end 



-- ******************************************
-- ***** Handle External Function Comms *****
-- ******************************************
function HandleExternalComms(sThisData)
  local objThisData = json.decode(sThisData)
  local sMessageType, sLine, sStyles = objThisData[1], objThisData[2], objThisData[3]
  if (iCommsCountByType[sMessageType] ~= nil) then
    HandleCommsMessage("CommLog_" .. sMessageType, sLine, "", sStyles)
  end
end


-- Special handlers for newbie-tell, cre-tell, and special-tell
function QuowOutgoingCreTell(sName, sLine, sWildcards, objStyles)
  local objEncoded = json.encode({"cre", sLine, objStyles})
  HandleExternalComms(objEncoded)
end
function QuowOutgoingNewbieTell(sName, sLine, sWildcards, objStyles)
  local objEncoded = json.encode({"newbie", sLine, objStyles})
  HandleExternalComms(objEncoded)
end
function QuowOutgoingSpecialTell(sName, sLine, sWildcards, objStyles)
  local objEncoded = json.encode({"special", sLine, objStyles})
  HandleExternalComms(objEncoded)
end


-- ******************************************
-- ***** Handle Incoming/Outgoing Tells *****
-- ******************************************
-- Handle tells incoming/outgoing to split chat?
sCommsBuffer = {}
sCommsIgnore = { 
  "Mr Werks",
  "Sam Slager",
  "Stephen Jobbes",
  "The city guard",
}
function HandleCommsMessage(sName, sLine, objWildcards, objStyles)

  -- Check we aren't seeing a "say" from a blacklisted NPC/person
  for k, v in pairs(sCommsIgnore) do
    if v == sLine:sub(1,v:len()) then
      return
    end
  end
  sName = string.gsub(string.gsub(string.gsub(string.sub(sName, 9), "_ZXA_", "-"), "_APP_", "'"), "_AMP_", "&")
  if(iCommsCountByType[sName] == nil) then
    return
  end
  iCommsCountByType[sName] = iCommsCountByType[sName] + 1
  table.insert(objStyles, 1, {["textcolour"] = iCOLOUR.grey, ["backcolour"] = 0, ["text"] = os.date ("%H:%M:%S: "), ["length"] = 10})
  table.insert(sCommsBuffer, {sName, (string.len(sLine) + 10), objStyles, OST()})
  -- Delete buffer above 10000 lines
  if (#sCommsBuffer > 10000) then
    iCommsCountByType[sName] = iCommsCountByType[sName] - 1
    table.remove(sCommsBuffer, 1)
    if (objChatFilters[sName][2] == true) then
      iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown - 1
    end
  end
  if (objChatFilters[sName][2] == true) then
    if (iCommLineBottomRender == iCommsMessagesCurrentlyShown) then
      iCommLineBottomRender = iCommLineBottomRender + 1
    end
    iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown + 1
    -- Redraw the window
    RedrawCommsWindow()
  end
end


-- *******************************
-- ***** Redraw Comms Window *****
-- *******************************

require "wait"
bCommWindowIsScrolling = false
bCommWindowDragScrolling = false
iCommWindowLines = 0
iCommLinesRendered = 0
iCommLineBottomRender = 0
iCommMaxLines = 0
iCommLineClicked = 0
iBarPos = 0
iBarSize = 0
iCommScrollClickY = 0
SCROLL_BAR_HEIGHT = 0
SCROLL_BAR_WIDTH = 15
sPolyPoints = ""

-- Handle the scrollbar being dragged around
function ScrollerMoveCallback(flags, hotspot_id)
  local iThisMouseY = WindowInfo(winComms, 18)
  local iCommWindowTop = WindowInfo(winComms, 2)
  iBarPos = math.max(iThisMouseY-iCommWindowTop+iCommScrollClickY, SCROLL_BAR_WIDTH+iTopCommsWindow)
  if iBarPos > WINDATA[winComms]["HEIGHT"]-SCROLL_BAR_WIDTH-iBarSize then
    iBarPos = WINDATA[winComms]["HEIGHT"]-SCROLL_BAR_WIDTH-iBarSize
    iCommLineBottomRender = iCommsMessagesCurrentlyShown
  else
    local iLineStart = math.floor((iBarPos-SCROLL_BAR_WIDTH-iTopCommsWindow)/(SCROLL_BAR_HEIGHT/iCommMaxLines)+1)
    iCommLineBottomRender = math.min(iLineStart + iCommLinesRendered-1, iCommsMessagesCurrentlyShown)
  end
  RedrawCommsWindow()
end

-- The user let go of the scrollbar
function ScrollerReleaseCallback(flags, hotspot_id)
  bCommWindowDragScrolling = false
  RedrawCommsWindow()
end  -- function ScrollerReleaseCallback

-- Handle clicking the up and down arrows and holding them down
function scrollbar(calledBy)
  wait.make (function()
    while bCommWindowIsScrolling == true do
      if calledBy == "hsCommsUp" then
        if (iCommLineBottomRender > iCommLinesRendered) then
          iCommLineBottomRender = iCommLineBottomRender - 1
          WindowRectOp(winComms, miniwin.rect_draw_edge, (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)-1, iTopCommsWindow, -1, SCROLL_BAR_WIDTH + iTopCommsWindow, 
              miniwin.rect_edge_sunken,  miniwin.rect_edge_at_all + miniwin.rect_option_fill_middle) -- up arrow pushed
          sPolyPoints = string.format ("%i,%i,%i,%i,%i,%i", (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+1, 8+iTopCommsWindow, (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+5, 4+iTopCommsWindow, (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+9, 8+iTopCommsWindow)
          WindowPolygon (winComms, sPolyPoints,
              winThemeData.DETAIL, miniwin.pen_solid, 1, -- pen (solid, width 1)
              winThemeData.DETAIL, miniwin.brush_solid, -- brush (solid)
              true, -- close
              false) -- alt fill
        else
          bCommWindowIsScrolling = false
        end
      elseif calledBy == "hsCommsDown" then
        if (iCommLineBottomRender < iCommsMessagesCurrentlyShown) then
          iCommLineBottomRender = iCommLineBottomRender + 1
          WindowRectOp(winComms, miniwin.rect_draw_edge, (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)-1, WINDATA[winComms]["HEIGHT"]-(SCROLL_BAR_WIDTH), -1, WINDATA[winComms]["HEIGHT"]-1, 
              miniwin.rect_edge_sunken,  miniwin.rect_edge_at_all + miniwin.rect_option_fill_middle) -- down arrow pushed
          sPolyPoints = string.format ("%i,%i,%i,%i,%i,%i", (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+1, WINDATA[winComms]["HEIGHT"]-10,(WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+5, WINDATA[winComms]["HEIGHT"]-6, (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+9,WINDATA[winComms]["HEIGHT"]-10)
          WindowPolygon (winComms, sPolyPoints,
              winThemeData.DETAIL, miniwin.pen_solid, 1, -- pen (solid, width 1)
              winThemeData.DETAIL, miniwin.brush_solid, -- brush (solid)
              true, -- close
              false) -- alt fill
        else
          bCommWindowIsScrolling = false
        end
      end -- if
      wait.time(0.1)
      RedrawCommsWindow()
    end -- while bCommWindowIsScrolling
  end)  -- wait.make
end  -- function scrollbar

-- Releasing the scrollbar up/down buttons
function CommsMouseUp(flags, hotspot_id)
  bCommWindowIsScrolling = false
  bCommsNeedsButtons = true
  RedrawCommsWindow()
end

-- Communications window scroll bar clicking
function CommsMouseDown(flags, hotspot_id)
  if (hotspot_id == "hsCommScroller") then
    iCommScrollClickY = WindowHotspotInfo(winComms, "hsCommScroller", 2)-WindowInfo(winComms, 15)
    bCommWindowDragScrolling = true
  else
    bCommWindowIsScrolling = true
    scrollbar(hotspot_id)
  end
end


-- Mouse up on the chat-tabs bar, handle changing channels
function ChatTabMouseUp(flags, hotspot_id)
  if (bit.band(flags, miniwin.hotspot_got_rh_mouse) ~= 0) then
    winInfoComms.mouseup(flags, hotspot_id)
  else
    local iChannelWidth = math.floor((WINDATA[winComms]["WIDTH"] - 8) / #objChatTabs)
    if (iChannelWidth < 30) then
      iChannelWidth = 30
    end
    local iChanMouseX = WindowInfo(winComms, 14)
    ChangeChatChannel(math.ceil(iChanMouseX / iChannelWidth))
    RedrawCommsWindow()
  end
end


-- Function to change the chat channel and update the messages (does NOT call RedrawCommsWindow afterwards - do that after!)
function ChangeChatChannel(iNewChannel)
  if (objChatTabs[iNewChannel] and objChatTabs[iNewChannel][2]) then
    iCurrentChannelChoice = iNewChannel
    local iCheckChannel = 0
    iCommsMessagesCurrentlyShown = 0
    for sKey, sData in pairs(objChatFilters) do
      objChatFilters[sKey][2] = false
    end
    for sTabKey, sTabData in ipairs(objChatTabs[iCurrentChannelChoice][2]) do
      if (sTabData == "*All*") then
        iCommsMessagesCurrentlyShown = 0
        for sKey, sData in pairs(objChatFilters) do
          objChatFilters[sKey][2] = true
          iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown + iCommsCountByType[sKey]
        end
        break
      elseif (sTabData == "*Talkers*") then
        for sKey, sData in pairs(objChatFilters) do
          if (sKey ~= "Tells_In" and sKey ~= "Tells_Out" and sKey ~= "Group_Say") then
            objChatFilters[sKey][2] = true
            iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown + iCommsCountByType[sKey]
          end
        end
      else
        objChatFilters[sTabData][2] = true
        iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown + iCommsCountByType[sTabData]
      end
    end
    iCommLineBottomRender = iCommsMessagesCurrentlyShown
  end
end

-- Main re-draw function to actually SHOW the messages and tabs and scrollbar etc.
bCommsNeedsButtons = true
function RedrawCommsWindow(iGrabLineNumber)
  iCommWindowLines = math.floor((WINDATA[winComms]["HEIGHT"] - 2) / iFontSizes[winComms]["lineheight"])

  -- Save effort, do nothing if not showing this window
  if (WINDATA[winComms]["SHOW"] == false) then
    return
  end

  WindowRectOp(winComms, miniwin.rect_fill, 0, iTopCommsWindow, WINDATA[winComms]["WIDTH"]-(SCROLL_BAR_WIDTH+1), WINDATA[winComms]["HEIGHT"], iCOLOUR.black)

  -- Scrollbar base
  WindowRectOp(winComms, miniwin.rect_fill, WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH-1, SCROLL_BAR_WIDTH+iTopCommsWindow, WINDATA[winComms]["WIDTH"]-1, WINDATA[winComms]["HEIGHT"] - SCROLL_BAR_WIDTH, winThemeData.BACK_FACE) -- scroll bar background
  WindowRectOp(winComms, miniwin.rect_frame, WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH, SCROLL_BAR_WIDTH+1+iTopCommsWindow, WINDATA[winComms]["WIDTH"]-2, WINDATA[winComms]["HEIGHT"]-(SCROLL_BAR_WIDTH)-1, winThemeData.DETAIL) -- scroll bar background inset rectangle

  if (bCommsNeedsButtons == true) then
    -- draw triangle in up button
    DrawThemed3DRect(winComms, WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH-1, iTopCommsWindow, WINDATA[winComms]["WIDTH"]-1, SCROLL_BAR_WIDTH + iTopCommsWindow) -- top scroll button
    sPolyPoints = string.format ("%i,%i,%i,%i,%i,%i", (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+1, iTopCommsWindow+8, (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+5, iTopCommsWindow+4, (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+9, iTopCommsWindow+8)
    WindowPolygon (winComms, sPolyPoints,
        winThemeData.DETAIL, miniwin.pen_solid, 1,   -- pen (solid, width 1)
        winThemeData.DETAIL, miniwin.brush_solid, --brush (solid)
        true, --close
        false)  --alt fill
    -- draw triangle in down button 
    DrawThemed3DRect(winComms, WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH-1, WINDATA[winComms]["HEIGHT"]-SCROLL_BAR_WIDTH, WINDATA[winComms]["WIDTH"]-1, WINDATA[winComms]["HEIGHT"]) -- bottom scroll button
    sPolyPoints = string.format ("%i,%i,%i,%i,%i,%i", (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+1, WINDATA[winComms]["HEIGHT"]-10,(WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+5, WINDATA[winComms]["HEIGHT"]-6, (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH)+9,WINDATA[winComms]["HEIGHT"]-10)
    WindowPolygon (winComms, sPolyPoints,
        winThemeData.DETAIL, miniwin.pen_solid, 1,   -- pen (solid, width 1)
        winThemeData.DETAIL, miniwin.brush_solid, --brush (solid)
        true, --close
        false) --alt fill
    bCommsNeedsButtons = false
  end

  local iTX = 1
  local iTY = WINDATA[winComms]["HEIGHT"] - (iFontSizes[winComms]["lineheight"] + 2)
  local iMaxWidth = math.floor((WINDATA[winComms]["WIDTH"] - (iTX + 2 + SCROLL_BAR_WIDTH)) / iFontSizes[winComms]["fontwidth"])
  local iTotalLinesNeeded = 0
  local iTotalLinesAdded = 0
  local iSpaceLeft = 0
  local iSpaceEat = 0
  local iLengthLeft = 0
  local sRemainingText = ""
  local sThisText = ""
  local iGrabThisLineNumber = 0
  iCommLinesRendered = 0
  local iColTop = 0
  local iColBot = 0

  local iLinesToRenderFrom = 0
  local iLinesToSkip = iCommsMessagesCurrentlyShown - iCommLineBottomRender
  -- Loop backwards through the comms table

  for iC = #sCommsBuffer, 1, -1 do
    -- Is this a type of message we CURRENTLY want to display?
    if (objChatFilters[sCommsBuffer[iC][1]] and objChatFilters[sCommsBuffer[iC][1]][2] == true) then
      if (iLinesToSkip == 0) then
        iLinesToRenderFrom = iC
        break
      end
      iLinesToSkip = iLinesToSkip - 1
    end
  end

  for iC = iLinesToRenderFrom, 1, -1 do
    -- Is this a type of message we CURRENTLY want to display?
    if (objChatFilters[sCommsBuffer[iC][1]] and objChatFilters[sCommsBuffer[iC][1]][2] == true) then
      -- Set up the positions
      iTX = 1
      iTotalLinesAdded = math.ceil(sCommsBuffer[iC][2] / iMaxWidth)
      iTotalLinesNeeded = iTotalLinesAdded - 1
      iSpaceLeft = iMaxWidth
      if (iSpaceLeft < 1) then
        iSpaceLeft = 1
      end
      -- Loop through the styles
      for iStyleKey, sThisStyle in ipairs (sCommsBuffer[iC][3]) do
        iLengthLeft = sThisStyle.length
        sRemainingText = sThisStyle.text
        -- This style takes us over the edge, split it
        if (iLengthLeft > iSpaceLeft) then
          iSpaceEat = iSpaceLeft
          while (sRemainingText ~= "") do
            sThisText = string.sub(sRemainingText, 1, iSpaceEat)
            iLengthLeft = iLengthLeft - iSpaceEat
            sRemainingText = string.sub(sRemainingText, iSpaceEat + 1)
            -- Background colour?
            if (sThisStyle.backcolour ~= 0) then
              iColTop = iTY - (iTotalLinesNeeded * iFontSizes[winComms]["lineheight"])
              if (iColTop < iTopCommsWindow) then
                iColTop = 0
              end
              iColBot = iTY - ((iTotalLinesNeeded - 1) * iFontSizes[winComms]["lineheight"])
              if (iColBot < 0) then
                iColBot = 0
              end
              if (iColBot ~= iColTop) then
                WindowRectOp(winComms, miniwin.rect_fill, iTX, iColTop, iTX + (iSpaceEat * iFontSizes[winComms]["fontwidth"]), iColBot, sThisStyle.backcolour)
              end
            end
            iTX = iTX + WindowText(winComms, "bodyfont", sThisText, iTX, iTY - (iTotalLinesNeeded * iFontSizes[winComms]["lineheight"]), 0, 0, sThisStyle.textcolour, false)
            if (iGrabLineNumber ~= nil and iGrabLineNumber >= iTY - (iTotalLinesNeeded * iFontSizes[winComms]["lineheight"]) and iGrabLineNumber <= iTY - ((iTotalLinesNeeded - 1) * iFontSizes[winComms]["lineheight"])) then
              iGrabThisLineNumber = iC
            end
            if (iLengthLeft ~= 0) then
              iTotalLinesNeeded = iTotalLinesNeeded - 1
              iTX = 1
              iSpaceEat = iLengthLeft
              if (iSpaceEat > iMaxWidth) then
                iSpaceEat = iMaxWidth
              end
            else
              iSpaceLeft = iMaxWidth - iSpaceEat
            end
          end
        else
        -- This style fits nicely, add it on, count the space left
          iSpaceLeft = iSpaceLeft - iLengthLeft
          -- Background colour?
          if (sThisStyle.backcolour ~= 0) then
            iColTop = iTY - (iTotalLinesNeeded * iFontSizes[winComms]["lineheight"])
            if (iColTop < 0) then
              iColTop = 0
            end
            iColBot = iTY - ((iTotalLinesNeeded - 1) * iFontSizes[winComms]["lineheight"])
            if (iColBot < 0) then
              iColBot = 0
            end
            if (iColBot ~= iColTop) then
              WindowRectOp(winComms, miniwin.rect_fill, iTX, iColTop, iTX + (iLengthLeft * iFontSizes[winComms]["fontwidth"]), iColBot, sThisStyle.backcolour)
            end
          end
          iTX = iTX + WindowText(winComms, "bodyfont", sRemainingText, iTX, iTY - (iTotalLinesNeeded * iFontSizes[winComms]["lineheight"]), 0, 0, sThisStyle.textcolour, false)
          if (iGrabLineNumber ~= nil and iGrabLineNumber >= iTY - (iTotalLinesNeeded * iFontSizes[winComms]["lineheight"]) and iGrabLineNumber <= iTY - ((iTotalLinesNeeded - 1) * iFontSizes[winComms]["lineheight"])) then
            iGrabThisLineNumber = iC
          end
        end
      end
      -- Move up by the total number of lines
      iTY = iTY - (iTotalLinesAdded * iFontSizes[winComms]["lineheight"])
      -- And stop going back if we're going beyond a whole line worth off the top edge
      if (iTY <= -iFontSizes[winComms]["lineheight"]) then
        break
      else
        iCommLinesRendered = iCommLinesRendered + 1
      end
    end
  end

  -- Display the chat tabs
  if (bShowCommsTabs == true) then
    WindowRectOp(winComms, miniwin.rect_fill, 0, 0, WINDATA[winComms]["WIDTH"], iTopCommsWindow, iCOLOUR.black)
    local iChannelWidth = math.floor((WINDATA[winComms]["WIDTH"] - 8) / #objChatTabs)
    local iLastChannelWidth = (WINDATA[winComms]["WIDTH"] - 8) - (iChannelWidth * (#objChatTabs - 1))
    if (iChannelWidth < 30) then
      iChannelWidth = 30
    end
    local iChanX = 0
    for iN = 1, #objChatTabs do
      if (iN == #objChatTabs and iN > 1) then
        iChannelWidth = iLastChannelWidth
      end
      if (iCurrentChannelChoice == iN) then
        WindowRectOp(winComms, miniwin.rect_fill, iChanX, 0, iChanX + iChannelWidth, iTopCommsWindow, winThemeData.SELECTFACE)
        WindowText(winComms, "bodyfont", objChatTabs[iN][1], iChanX + 2, 1, 0, 0, winThemeData.ONFACE, false)
      else
        DrawThemed3DRect(winComms, iChanX, 0, iChanX + iChannelWidth, iTopCommsWindow)
        WindowText(winComms, "bodyfont", objChatTabs[iN][1], iChanX + 2, 2, 0, 0, winThemeData.ONFACE, false)
      end
      iChanX = iChanX + iChannelWidth + 2
    end
  end

  -- Copy to clipboard option selected
  if (iGrabThisLineNumber ~= 0) then
    local sGrabThisLine = ""
    for iStyleKey, sThisStyle in ipairs (sCommsBuffer[iGrabThisLineNumber][3]) do
      sGrabThisLine = sGrabThisLine .. sThisStyle.text
    end
    SetClipboard(sGrabThisLine)
  end

  -- Calculate scroll bar max sizes, bar position etc.
  local iLinesMissing = iCommsMessagesCurrentlyShown - iCommLinesRendered
  local iCurrentScrollLine = iCommLineBottomRender - iCommLinesRendered
  if (iCurrentScrollLine < 0) then
    iCurrentScrollLine = 0
  end
  -- The scrollbar position indicator
  iCommMaxLines = iCommWindowLines + iLinesMissing
  if (iCommMaxLines <= iCommWindowLines) then iCommMaxLines = 1 end
  SCROLL_BAR_HEIGHT = WINDATA[winComms]["HEIGHT"] - iTopCommsWindow - (2*SCROLL_BAR_WIDTH)
  if (not bCommWindowDragScrolling) then
    iBarPos = SCROLL_BAR_WIDTH + iTopCommsWindow + ((SCROLL_BAR_HEIGHT/iCommMaxLines) * iCurrentScrollLine)
    iBarSize = (SCROLL_BAR_HEIGHT/math.max(iCommWindowLines,iCommMaxLines)) * (iCommWindowLines)
    if (iBarSize < 10) then
      iBarSize = 10
    end
    if (iBarPos+iBarSize > SCROLL_BAR_WIDTH+SCROLL_BAR_HEIGHT+iTopCommsWindow) then
      iBarPos = SCROLL_BAR_WIDTH+iTopCommsWindow+SCROLL_BAR_HEIGHT - iBarSize
    end
    WindowMoveHotspot(winComms, "hsCommScroller", (WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH), iBarPos, WINDATA[winComms]["WIDTH"] - 1, iBarPos+iBarSize)
  end
  DrawThemed3DRect(winComms, WINDATA[winComms]["WIDTH"]-SCROLL_BAR_WIDTH-1, iBarPos, WINDATA[winComms]["WIDTH"]-1, iBarPos+iBarSize)

  -- Blank window, display a message
  if (iCommsMessagesCurrentlyShown == 0) then
    WindowText(winComms, "bodyfont", "(no messages to display)", 2, 2 + iTopCommsWindow, 0, 0, iCOLOUR.silver, false)
  end

  -- Frame the entire window
  WindowRectOp(winComms, miniwin.rect_frame, 0, iTopCommsWindow, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], winThemeData.WINDOW_BORDER)

  Redraw()
end


-- ***************************************
-- ***** Redraw Shields/Group Window *****
-- ***************************************
function RedrawShieldsWindow()
  -- Save effort, do nothing if not showing this window
  if (WINDATA[winShields]["SHOW"] == false) then
    return
  end

  WindowRectOp(winShields, miniwin.rect_fill, 0, 0, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], iCOLOUR.black)

  local sUseFont
  local iThisLineHeight = iFontSizes[winShields]["lineheight"]
  if (WINDATA[winShields]["WIDTH"] < 250) then
    sUseFont = "bodyfont"
  elseif (WINDATA[winShields]["WIDTH"] < 400) then
    sUseFont = "bodyfontm"
    iThisLineHeight = iThisLineHeight + 3
  else
    sUseFont = "bodyfontl"
    iThisLineHeight = iThisLineHeight + 7
  end

  local iLineCentre = iThisLineHeight * 0.25

  local sUseName = ""

  iTotalGroupMembers = 0
  local iLongestName = 0
  local iCheckWidth = 0
  if (bSoloShieldsWindow == false) then
    for sCharacter, sGroupData in pairs (sGroupMembers) do
      sUseName = ((sCharacter == sMyPlayerName) and "You" or sCharacter)
      iTotalGroupMembers = iTotalGroupMembers + 1
      iCheckWidth = WindowTextWidth(winShields, sUseFont, sUseName)
      if (iCheckWidth > iLongestName) then
        iLongestName = iCheckWidth
      end
    end
  else
    -- Solo shields, show you only
    iTotalGroupMembers = 1
    iLongestName = WindowTextWidth(winShields, sUseFont, "You")
  end
  if (iLongestName > (WINDATA[winShields]["WIDTH"] * 0.25)) then
    iLongestName = math.floor((WINDATA[winShields]["WIDTH"] * 0.25))
  end

  local bShowTitle = true
  local iFreeSpace = WINDATA[winShields]["HEIGHT"]
  if (WINDATA[winShields]["HEIGHT"] < ((iTotalGroupMembers + 1) * iThisLineHeight)) then
    bShowTitle = false
  else
    iFreeSpace = iFreeSpace - iThisLineHeight
  end

  local iPlayerHeight = iFreeSpace / iTotalGroupMembers
  if (iPlayerHeight > 30) then
    iPlayerHeight = 30
  end
  if (iThisLineHeight > iPlayerHeight) then
    sUseFont = "bodyfont"
    iThisLineHeight = iFontSizes[winShields]["lineheight"]
    iLineCentre = iThisLineHeight * 0.25
  end

  local iBarLeft = iLongestName + 5
  local iBarTop = 2
  local iBarWidth = WINDATA[winShields]["WIDTH"] - iBarLeft - 2
  local iBarHeight = iPlayerHeight * 0.5
  local sShieldName = ""

  local iHPColour = 0
  local iGPColour = 0

  local iThisFontWidth = WindowTextWidth(winShields, sUseFont, "CCC")
  local iShieldTypeWidth = (iBarWidth - iThisFontWidth) * 0.25
  local iThisShieldColour = 0
  local iThisBackColour = 0

  local iTextTopAdd = iBarHeight - (iThisLineHeight * 0.5)

  if (bShowTitle == true) then
    if (iTotalGroupMembers > 1) then
      WindowText(winShields, sUseFont, "Group Members:  " .. (iTotalGroupMembers - 1), iBarLeft + 3, 1, 0, 0, iCOLOUR.silver, false)
    else
      WindowText(winShields, sUseFont, "No Group Detected", iBarLeft + 3, 1, 0, 0, iCOLOUR.silver, false)
    end
    iBarTop = iBarTop + iThisLineHeight + 1
  end
  iTotalGroupMembers = iTotalGroupMembers - 1

  for sCharacter, sGroupData in pairs (sGroupMembers) do
    if (iTotalGroupMembers == 0 or sCharacter ~= "You") then
      -- Switch to our own character data if this group member is known to be "me"
      sUseName = ((sCharacter == sMyPlayerName) and "You" or sCharacter)
      -- Get the colours of the bars to apply
      if (bSoloShieldsWindow == false or sUseName == "You") then
        iHPColour = iPercToColour["hp"][sGroupMembers[sUseName]["HP"]]
        iGPColour = iPercToColour["gp"][sGroupMembers[sUseName]["GP"]]
        if (iHPColour == nil) then Note("Group colour error HP=" .. tostring(sGroupMembers[sUseName]["HP"])) end
        if (iGPColour == nil) then Note("Group colour error GP=" .. tostring(sGroupMembers[sUseName]["GP"])) end
        -- Draw the playername
        WindowText(winShields, sUseFont, ((sCharacter == sMyPlayerName) and "You" or sCharacter), 2, iBarTop + iTextTopAdd, 0, 0, iCOLOUR.silver, false)
        -- Draw the HP bars
        WindowRectOp(winShields, miniwin.rect_fill, iBarLeft, iBarTop, iBarLeft+math.floor((sGroupMembers[sUseName]["HP"] / 100) * iBarWidth), iBarTop + iBarHeight, iHPColour)
        -- Draw the GP bars
        WindowRectOp(winShields, miniwin.rect_fill, iBarLeft, iBarTop + iBarHeight, iBarLeft+math.floor((sGroupMembers[sUseName]["GP"] / 100) * iBarWidth), iBarTop + iPlayerHeight, iGPColour)
        -- Box them in
        WindowRectOp(winShields, miniwin.rect_frame, iBarLeft, iBarTop, iBarLeft+iBarWidth, iBarTop+iPlayerHeight, winThemeData.WINDOW_BORDER)
        -- Text for shield notices/statuses
        for sShieldType, iShieldStatus in pairs(sGroupMembers[sUseName]) do
          if (iShieldStatus == 0) then
            iThisBackColour = 0
            iThisShieldColour = 0
          else
            iThisBackColour = 0
            iThisShieldColour = iCOLOUR.silver
          end
          if (iThisFontWidth > iShieldTypeWidth) then
            sShieldName = string.sub(sShieldType, 1, 1)
          else
            sShieldName = sShieldType
          end
          if (sShieldType == "TPA") then
            WindowText(winShields, sUseFont, sShieldName, iBarLeft + 2, iBarTop - 1 + iTextTopAdd, 0, 0, iThisBackColour, false)
            WindowText(winShields, sUseFont, sShieldName, iBarLeft + 3, iBarTop + iTextTopAdd, 0, 0, iThisShieldColour, false)
          elseif (sShieldType == "CCC") then
            WindowText(winShields, sUseFont, sShieldName, iBarLeft + 2 + (iShieldTypeWidth), iBarTop - 1 + iTextTopAdd, 0, 0, iThisBackColour, false)
            WindowText(winShields, sUseFont, sShieldName, iBarLeft + 3 + (iShieldTypeWidth), iBarTop + iTextTopAdd, 0, 0, iThisShieldColour, false)
          elseif (sShieldType == "EFF") then
            WindowText(winShields, sUseFont, sShieldName, iBarLeft + 2 + (iShieldTypeWidth * 2), iBarTop - 1 + iTextTopAdd, 0, 0, iThisBackColour, false)
            WindowText(winShields, sUseFont, sShieldName, iBarLeft + 3 + (iShieldTypeWidth * 2), iBarTop + iTextTopAdd, 0, 0, iThisShieldColour, false)
          elseif (sShieldType == "BUG") then
            WindowText(winShields, sUseFont, sShieldName, iBarLeft + 2 + (iShieldTypeWidth * 3), iBarTop - 1 + iTextTopAdd, 0, 0, iThisBackColour, false)
            WindowText(winShields, sUseFont, sShieldName, iBarLeft + 3 + (iShieldTypeWidth * 3), iBarTop + iTextTopAdd, 0, 0, iThisShieldColour, false)
          elseif (sShieldType == "MS") then
            WindowText(winShields, sUseFont, sShieldName, (iBarLeft + iBarWidth) - iThisFontWidth, iBarTop - 1 + iTextTopAdd, 0, 0, iThisBackColour, false)
            WindowText(winShields, sUseFont, sShieldName, (iBarLeft + iBarWidth) - iThisFontWidth, iBarTop + iTextTopAdd, 0, 0, iThisShieldColour, false)
          end 
        end
      end
    end
    iBarTop = iBarTop + iPlayerHeight + 1
  end

  WindowRectOp(winShields, miniwin.rect_frame, 0, 0, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], winThemeData.WINDOW_BORDER)
end

-- ****************************************
-- ***** XP Rates and XP Graph Window *****
-- ****************************************

-- **********************************************
-- ***** Each Minute, Record Last Minute XP *****
-- **********************************************
function UpdateXPGraph()
  -- Don't add to minutes if we haven't seen an XP count yet, or aren't currently connected to the mud
  if (iXPTotalMinutePrevious == nil or iCharVitals["xp"] == 0 or GetInfo(106) ~= false) then
    return
  end

  -- Get the XP difference since previous minute
  if (iXPTotalMinuteCurrent == nil) then
    iXPTotalMinuteCurrent = iCharVitals["xp"]
  end
  iXPTotalMinutePrevious = iXPTotalMinuteCurrent
  iXPTotalMinuteCurrent = iCharVitals["xp"]
  local iXPThisMinute = (iXPTotalMinuteCurrent - iXPTotalMinutePrevious)
  if (iXPThisMinute < 0) then
    iXPThisMinute = 0
  end

  -- Delete the oldest XP point if we have 60
  if (#iXPGraphPlots == 60) then
    table.remove(iXPGraphPlots, 1)
    table.remove(iXPTotalPlots, 1)
  end

  -- Add this last minute's XP to the xp-each-minute table
  iXPTotalPlots[#iXPTotalPlots + 1] = iXPThisMinute

  -- Work out the new hourly rate
  iXPPastHour = 0
  iXPHighestPlot = 0
  for iN = 1, #iXPTotalPlots do
    iXPPastHour = iXPPastHour + iXPTotalPlots[iN]
    if (iN < #iXPTotalPlots and iXPGraphPlots[iN] > iXPHighestPlot) then
      iXPHighestPlot = iXPGraphPlots[iN]
    end
  end

  -- Divide the past "hour" (or less) worth of XP by the number of minutes measured
  if (#iXPGraphPlots > 0) then
    iXPPerHour = math.floor((iXPPastHour / #iXPTotalPlots) * 60)
  else
    iXPPerHour = 0
  end

  -- Add the current point to the table
  iXPGraphPlots[#iXPGraphPlots + 1] = (iXPPerHour < 2000001) and iXPPerHour or 2000000
  --if (iXPGraphScaling < 2000000) then
  --  iXPGraphPlots[#iXPGraphPlots + 1] = (iXPPerHour < 1000001) and iXPPerHour or 1000000
  --else
  --  iXPGraphPlots[#iXPGraphPlots + 1] = (iXPPerHour < 2000001) and iXPPerHour or 2000000
  --end

  -- Check if it's a new high-point
  if (iXPPerHour > iXPHighestPlot) then
    iXPHighestPlot = iXPPerHour
  end

  -- *TOTAL* xp and minutes since recording
  iXPTotalRecordedIncoming = iXPTotalRecordedIncoming + iXPThisMinute
  iXPMinutesRecordedTotal = iXPMinutesRecordedTotal + 1

  -- Now finally redraw the chart
  RedrawXPWindow(true)
end


-- ***********************************
-- ***** HP and XP Notices Queue *****
-- ***********************************
sTextNoticesQueue = {}
function QuowDisplayNotices()
  for iKey, sData in ipairs(sTextNoticesQueue) do
    if (sData[1] == 1) then
      -- HP Notice
      ColourTell("#C0C0C0", "", "{")
      ColourTell("red", "", tostring(sData[2]))
      ColourNote("#C0C0C0", "", "} ")
    elseif (sData[1] == 2) then
      -- XP Notice
      ColourTell("#C0C0C0", "", "{")
      ColourTell("cyan", "", tostring(sData[2]))
      ColourNote("#C0C0C0", "", "} ")
    elseif (sData[1] == 3) then
      -- GP Notice
      ColourTell("#C0C0C0", "", "{")
      ColourTell(sUSER_OPTIONS["vitals_gp_a"], "", tostring(sData[2]))
      ColourNote("#C0C0C0", "", "} ")
    end
  end
  sTextNoticesQueue = {}
end


-- ********************************************
-- ***** Redraw XP Graph Plottings/Window *****
-- ********************************************
function RedrawXPWindow(bRedrawGraph)
  -- Save effort, do nothing if not showing this window
  if (WINDATA[winXP]["SHOW"] == false) then
    return
  end

  local iKeyColour, iGraphColour, iY, iThisLineHeight = iCOLOUR.silver, winThemeData.WINDOW_BORDER, 2, iFontSizes[winXP]["lineheight"]
  local sUseFont 
  local iGraphTop = iThisLineHeight + 8
  if (WINDATA[winXP]["WIDTH"] < 250) then
    sUseFont = "bodyfont"
  elseif (WINDATA[winXP]["WIDTH"] < 400) then
    sUseFont = "bodyfontm"
    iThisLineHeight = iThisLineHeight + 2
    iGraphTop = iThisLineHeight + 11
  else
    sUseFont = "bodyfontl"
    iThisLineHeight = iThisLineHeight + 6
    iGraphTop = iThisLineHeight + 12
  end

  -- Blank the top part of the window
  if (bRedrawGraph ~= nil) then
    WindowRectOp(winXP, miniwin.rect_fill, 0, 0, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], iCOLOUR.black)
  else
    WindowRectOp(winXP, miniwin.rect_fill, 0, 0, WINDATA[winXP]["WIDTH"], (iThisLineHeight * 3) + 2, iCOLOUR.black)
  end

  WindowText(winXP, sUseFont, NumberCommaString(iCharVitals["xp"]) .. " xp", 5, iY, 0, 0, iKeyColour, false)
  iY = iY + iThisLineHeight
  WindowText(winXP, sUseFont, NumberCommaString(iXPTotalRecordedIncoming) .. " xp gained in", 5, iY, 0, 0, iKeyColour, false)
  iY = iY + iThisLineHeight
  WindowText(winXP, sUseFont, MinutesToTimeString(iXPMinutesRecordedTotal) .. "    " .. ((#iXPGraphPlots > 1) and NumberCommaString(iXPPerHour) .. " xp/h" or "(wait for reliable xp/h)"), 5, iY, 0, 0, iKeyColour, false)

  -- Don't re-do the XP graph?
  if (bRedrawGraph == nil) then
    -- Frame the window before exiting this function
    WindowRectOp(winXP, miniwin.rect_frame, 0, 0, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], winThemeData.WINDOW_BORDER)
    return
  end

  iGraphTop = iGraphTop + iY
  local iGraphHeight = WINDATA[winXP]["HEIGHT"] - (iGraphTop + 3)
  -- Save the effort, don't do all the plotting if there's not enough room!
  if (iGraphHeight < 50) then
    -- Frame the window before exiting this function
    WindowRectOp(winXP, miniwin.rect_frame, 0, 0, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], winThemeData.WINDOW_BORDER)
    return
  end

  local iThisFontWidth = WindowTextWidth(winXP, sUseFont, "1000k")
  local iGraphLeft = iThisFontWidth + 2

  if (iXPHighestPlot > 900000 and iXPGraphScaling < 2000000) then
    iXPHighestPlot = 900000
  end
  local iHighPlotPoint = (math.floor(iXPHighestPlot / 100000) + 1) * 100000
  if (iXPGraphScaling > 0) then
    iHighPlotPoint = iXPGraphScaling
  end
  local iValuePerSpace = math.floor(iHighPlotPoint / 5)
  local iPlot1 = math.floor((iHighPlotPoint) / 1000)
  local iPlot2 = math.floor((iHighPlotPoint - iValuePerSpace) / 1000)
  local iPlot3 = math.floor((iHighPlotPoint - (iValuePerSpace * 2)) / 1000)
  local iPlot4 = math.floor((iHighPlotPoint - (iValuePerSpace * 3)) / 1000)
  local iPlot5 = math.floor((iHighPlotPoint - (iValuePerSpace * 4)) / 1000)
  local sPlot1 = ((iPlot1 < 1000) and iPlot1 .. "k" or "1m")
  if (iXPGraphScaling == 2000000) then
    sPlot1 = "2m"
  end
  local sPlot2 = iPlot2 .. "k"
  local sPlot3 = iPlot3 .. "k"
  local sPlot4 = iPlot4 .. "k"
  local sPlot5 = iPlot5 .. "k"

  local iGraphChunk = math.floor(iGraphHeight / 5)
  local iGraphWidth = WINDATA[winXP]["WIDTH"] - (iGraphLeft + 5)

  -- Graph borders    
  WindowLine (winXP, iGraphLeft, iGraphTop, iGraphLeft, iGraphTop + iGraphHeight, iGraphColour, 0, 2)
  WindowLine (winXP, iGraphLeft, iGraphTop + iGraphHeight, iGraphLeft + iGraphWidth, iGraphTop + iGraphHeight, iGraphColour, 0, 2)

  -- Graph scale lines
  WindowLine (winXP, iGraphLeft, iGraphTop, iGraphLeft + iGraphWidth, iGraphTop, iGraphColour, 2, 1)
  WindowLine (winXP, iGraphLeft, iGraphTop + (iGraphChunk), iGraphLeft + iGraphWidth, iGraphTop + (iGraphChunk), iGraphColour, 2, 1)
  WindowLine (winXP, iGraphLeft, iGraphTop + (iGraphChunk * 2), iGraphLeft + iGraphWidth, iGraphTop + (iGraphChunk * 2), iGraphColour, 2, 1)
  WindowLine (winXP, iGraphLeft, iGraphTop + (iGraphChunk * 3), iGraphLeft + iGraphWidth, iGraphTop + (iGraphChunk * 3), iGraphColour, 2, 1)
  WindowLine (winXP, iGraphLeft, iGraphTop + (iGraphChunk * 4), iGraphLeft + iGraphWidth, iGraphTop + (iGraphChunk * 4), iGraphColour, 2, 1)

  -- Graph key
  WindowText (winXP, "bodyfont", sPlot1, 2, iGraphTop - (iThisLineHeight * 0.5), 0, 0, iKeyColour, false)
  WindowText (winXP, "bodyfont", sPlot2, 2, (iGraphTop + iGraphChunk) - (iThisLineHeight * 0.5), 0, 0, iKeyColour, false)
  WindowText (winXP, "bodyfont", sPlot3, 2, (iGraphTop + (iGraphChunk * 2)) - (iThisLineHeight * 0.5), 0, 0, iKeyColour, false)
  WindowText (winXP, "bodyfont", sPlot4, 2, (iGraphTop + (iGraphChunk * 3)) - (iThisLineHeight * 0.5), 0, 0, iKeyColour, false)
  WindowText (winXP, "bodyfont", sPlot5, 2, (iGraphTop + (iGraphChunk * 4)) - (iThisLineHeight * 0.5), 0, 0, iKeyColour, false)

  if (#iXPGraphPlots > 1) then
    local iPlotWidth = (iGraphWidth / (#iXPGraphPlots - 1))
    local iGX, iGY = iGraphLeft + 1, iHighPlotPoint
    if (iXPGraphPlots[1] < iHighPlotPoint) then
      iGY = iGraphTop + ((1 - (iXPGraphPlots[1] / iHighPlotPoint)) * iGraphHeight)
    end
    local iGYNext
    for iN = 2, #iXPGraphPlots do
      if (iXPGraphPlots[iN] < iHighPlotPoint) then
        iGYNext = iGraphTop + ((1 - (iXPGraphPlots[iN] / iHighPlotPoint)) * iGraphHeight)
      else
        iGYNext = iGraphTop
      end
      WindowLine (winXP, iGX, iGY, iGX + iPlotWidth, iGYNext, iCOLOUR.xp, 0, 2)
      iGX = iGX + iPlotWidth
      iGY = iGYNext
    end
  end

  -- Frame the window
  WindowRectOp(winXP, miniwin.rect_frame, 0, 0, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], iGraphColour)
end


-- ****************************************
-- ***** Character bars data handling *****
-- ****************************************
iLastPercHP, iLastPercGP, iLastPercBurden, sLastAlign, bForceVitalsUpdate, objVitalsCache, bForceVitalsCache = -1, -1, -1, "", true, {}, true
function RedrawVitalsWindow()
  -- Save effort, do nothing if not showing this window
  if (WINDATA[winBars]["SHOW"] == false) then
    return
  end

  local iDifference = 0
  -- We have a changed *MAX* HP, but an unchanged HP, correct the values so we don't treat it as a real "drop"
  if (iCharOldVitals["maxhp"] ~= iCharVitals["maxhp"] and iCharOldVitals["maxhp"] == iCharVitals["hp"]) then
    iDifference = iCharOldVitals["maxhp"] - iCharOldVitals["maxhp"]
    if (iDifference > 0) then
      iCharVitals["hp"] = iCharVitals["maxhp"] - iDifference
      iCharOldVitals["maxhp"] = iCharVitals["hp"]
      iCharOldVitals["maxhp"] = iCharVitals["maxhp"]
    end
  end 
  -- We have a changed *MAX* GP, but an unchanged GP
  if (iCharOldVitals["maxgp"] ~= iCharVitals["maxgp"] and iCharOldVitals["gp"] == iCharVitals["gp"]) then
    iDifference = iCharOldVitals["maxgp"] - iCharOldVitals["gp"]
    if (iDifference > 0) then
      iCharVitals["gp"] = iCharVitals["maxgp"] - iDifference
      iCharOldVitals["gp"] = iCharVitals["gp"]
      iCharOldVitals["maxgp"] = iCharVitals["maxgp"]
    end
  end 

  -- Get the percentages of the values
  local iHPPercentage = iCharVitals["maxhp"] > 0 and math.floor(iCharVitals["hp"] / iCharVitals["maxhp"] * 100) or 0
  local iGPPercentage = iCharVitals["maxgp"] > 0 and math.floor(iCharVitals["gp"] / iCharVitals["maxgp"] * 100) or 0
  local iBurdenPercentage = iCharVitals["burden"]
  -- Clamp the values safely
  if (iHPPercentage < 0) then iHPPercentage = 0 elseif (iHPPercentage > 100) then iHPPercentage = 100 end
  if (iGPPercentage < 0) then iGPPercentage = 0 elseif (iGPPercentage > 100) then iGPPercentage = 100 end
  if (iBurdenPercentage < 0) then iBurdenPercentage = 0 elseif (iBurdenPercentage > 100) then iBurdenPercentage = 100 end
  -- Why refresh the screen, we've not changed anything!
  if (bForceVitalsUpdate == false and iGPPercentage == iLastPercGP and iHPPercentage == iLastPercHP and iBurdenPercentage == iLastPercBurden and sLastAlign == iCharVitals["alignment"] and iCharOldVitals["maxhp"] == iCharVitals["maxhp"] and iCharOldVitals["maxgp"] == iCharVitals["maxgp"]) then
    return
  end
  -- Force re-generate window positions if alignment is showing & has changed
  if (iVitalsFormat == 1 and bShowAlignment == true and sLastAlign ~= iCharVitals["alignment"]) then
    bForceVitalsCache = true
  end
  iLastPercHP, iLastPercGP, iLastPercBurden, sLastAlign, bForceVitalsUpdate = iHPPercentage, iGPPercentage, iBurdenPercentage, iCharVitals["alignment"], false
  -- Clear the window afresh and draw a new border
  WindowRectOp(winBars, miniwin.rect_fill, 0, 0, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], iCOLOUR.black)

  -- Check if we need notification warnings
  if (iGPPercentage < 76 and iGPPercentage ~= 0) then
    bGPThresholdMet = true
  elseif (iGPPercentage > 99) then
    if (bPlayGPNotification == true and bGPThresholdMet == true and objSoundGPNotification ~= nil) then
      -- New sound play mechanics for playing direct from memory, no hard-drive load failures/issues
      local iSoundError = PlaySoundMemory(0, objSoundGPNotification, false, -6, 0)
      if (iSoundError ~= 0) then
        ColourNote(sCOLOUR.orange, "", "(Cow Bar just failed to play your GP full notification sound: MUSH error code " .. iSoundError .. ")")
      end
    end
    bGPThresholdMet = false
  end
  if (iHPPercentage > 89) then
    bHPThresholdMet = true
  elseif (iHPPercentage < 31) then
    if (bPlayHPNotification == true and bHPThresholdMet == true and objSoundHPNotification ~= nil and iCharVitals["hp"] > 0) then
      -- New sound play mechanics for playing direct from memory, no hard-drive load failures/issues
      local iSoundError = PlaySoundMemory(0, objSoundHPNotification, false, -6, 0)
      if (iSoundError ~= 0) then
        ColourNote(sCOLOUR.red, "", "(Cow Bar just failed to play your low-HP notification sound: MUSH error code " .. iSoundError .. ")")
      end
    end
    bHPThresholdMet = false
  end

  -- Re-create our values in the group window, too
  if (iHPPercentage ~= sGroupMembers["You"]["HP"] or iGPPercentage ~= sGroupMembers["You"]["GP"]) then
    sGroupMembers["You"]["HP"] = iHPPercentage
    sGroupMembers["You"]["GP"] = iGPPercentage
    RedrawShieldsWindow()
  end

  -- Colours    
  local iHPColour, iGPColour, iBurdenColour = iPercToColour["hp"][iHPPercentage], iPercToColour["gp"][iGPPercentage], iPercToColour["b"][100-iBurdenPercentage]
  
  -- Values
  local iBarsHeight, iKeyWidth, iBarWidth, iCentreFontHeight, sUseFont

  -- Vertical or horizontal bar choice?
  if (iVitalsFormat == 0) then
    -- Core vitals data caching for speed
    if (bForceVitalsCache == true) then
      bForceVitalsCache = false
      -- Calculate the bar heights, widths, and locations based on the window size
      if (bShowAlignment == true) then
        objVitalsCache.iBarsHeight = math.floor(WINDATA[winBars]["HEIGHT"] * 0.25) - 2
      else
        objVitalsCache.iBarsHeight = math.floor(WINDATA[winBars]["HEIGHT"] / 3) - 2
      end    
      objVitalsCache.iHPBarTop = 2
      objVitalsCache.iGPBarTop = objVitalsCache.iHPBarTop + objVitalsCache.iBarsHeight + 1
      objVitalsCache.iBurdenBarTop = objVitalsCache.iGPBarTop + objVitalsCache.iBarsHeight + 1
      objVitalsCache.iCentreFontHeight = math.floor((objVitalsCache.iBarsHeight - iFontSizes[winBars]["lineheight"]) * 0.5)
      if (bShowAlignment == true) then
        objVitalsCache.iHPBarTop = objVitalsCache.iHPBarTop + objVitalsCache.iBarsHeight
        objVitalsCache.iGPBarTop = objVitalsCache.iGPBarTop + objVitalsCache.iBarsHeight
        objVitalsCache.iBurdenBarTop = objVitalsCache.iBurdenBarTop + objVitalsCache.iBarsHeight
      end
      if (objVitalsCache.iBarsHeight < 30) then
        objVitalsCache.sUseFont = "bodyfont"
      elseif (objVitalsCache.iBarsHeight < 60) then
        objVitalsCache.sUseFont = "bodyfontm"
      else
        objVitalsCache.sUseFont = "bodyfontl"
      end
      -- Get the width of the left-bar-text
      objVitalsCache.iKeyWidth = WindowTextWidth(winBars, objVitalsCache.sUseFont, "GP")
      objVitalsCache.iBarLeft = objVitalsCache.iKeyWidth + 10
      objVitalsCache.iBarWidth = WINDATA[winBars]["WIDTH"] - (objVitalsCache.iBarLeft + 3)
    end
    -- Load in the cached data
    iBarsHeight = objVitalsCache.iBarsHeight
    iBarWidth = objVitalsCache.iBarWidth
    iKeyWidth = objVitalsCache.iKeyWidth
    iCentreFontHeight = objVitalsCache.iCentreFontHeight
    sUseFont = objVitalsCache.sUseFont
    local iHPBarTop = objVitalsCache.iHPBarTop
    local iGPBarTop = objVitalsCache.iGPBarTop
    local iBurdenBarTop = objVitalsCache.iBurdenBarTop
    local iBarLeft = objVitalsCache.iBarLeft

    -- Draw the texts to the left of the bars
    if (bShowAlignment == true) then
      WindowText(winBars, sUseFont, iCharVitals["alignment"], iBarLeft + 1, 2 + iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    end
    WindowText(winBars, sUseFont, "HP", 3, iHPBarTop + iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    WindowText(winBars, sUseFont, "GP", 3, iGPBarTop + iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    WindowText(winBars, sUseFont, "B", 3, iBurdenBarTop + iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    -- Gradients on or off
    if (bVitalsGradients == true) then
      -- Draw the HP bars
      WindowGradient (winBars, iBarLeft, iHPBarTop, iBarLeft+math.floor((iHPPercentage / 100) * iBarWidth), iHPBarTop + (iBarsHeight * 0.5), 0x000000, iHPColour, 2) 
      WindowGradient (winBars, iBarLeft, iHPBarTop + (iBarsHeight * 0.5), iBarLeft+math.floor((iHPPercentage / 100) * iBarWidth), iHPBarTop + iBarsHeight, iHPColour, 0x000000, 2) 
      WindowRectOp(winBars, miniwin.rect_frame, iBarLeft, iHPBarTop, iBarLeft+iBarWidth, iHPBarTop+iBarsHeight, winThemeData.WINDOW_BORDER)
      -- Draw the GP bars
      WindowGradient (winBars, iBarLeft, iGPBarTop, iBarLeft+math.floor((iGPPercentage / 100) * iBarWidth), iGPBarTop + (iBarsHeight * 0.5), 0x000000, iGPColour, 2) 
      WindowGradient (winBars, iBarLeft, iGPBarTop + (iBarsHeight * 0.5), iBarLeft+math.floor((iGPPercentage / 100) * iBarWidth), iGPBarTop + iBarsHeight, iGPColour, 0x000000, 2) 
      WindowRectOp(winBars, miniwin.rect_frame, iBarLeft, iGPBarTop, iBarLeft+iBarWidth, iGPBarTop+iBarsHeight, winThemeData.WINDOW_BORDER)
      -- Draw the burden bars
      WindowGradient (winBars, iBarLeft, iBurdenBarTop, iBarLeft+math.floor((iBurdenPercentage / 100) * iBarWidth), iBurdenBarTop + (iBarsHeight * 0.5), 0x000000, iBurdenColour, 2) 
      WindowGradient (winBars, iBarLeft, iBurdenBarTop + (iBarsHeight * 0.5), iBarLeft+math.floor((iBurdenPercentage / 100) * iBarWidth), iBurdenBarTop + iBarsHeight, iBurdenColour, 0x000000, 2) 
      WindowRectOp(winBars, miniwin.rect_frame, iBarLeft, iBurdenBarTop, iBarLeft+iBarWidth, iBurdenBarTop+iBarsHeight, winThemeData.WINDOW_BORDER)
    else
      -- Draw the HP bar
      WindowRectOp(winBars, miniwin.rect_fill, iBarLeft, iHPBarTop, iBarLeft+math.floor((iHPPercentage / 100) * iBarWidth), iHPBarTop+iBarsHeight, iHPColour)
      WindowRectOp(winBars, miniwin.rect_frame, iBarLeft, iHPBarTop, iBarLeft+iBarWidth, iHPBarTop+iBarsHeight, winThemeData.WINDOW_BORDER)
      -- Draw the GP bar
      WindowRectOp(winBars, miniwin.rect_fill, iBarLeft, iGPBarTop, iBarLeft+math.floor((iGPPercentage / 100) * iBarWidth), iGPBarTop+iBarsHeight, iGPColour)
      WindowRectOp(winBars, miniwin.rect_frame, iBarLeft, iGPBarTop, iBarLeft+iBarWidth, iGPBarTop+iBarsHeight, winThemeData.WINDOW_BORDER)
      -- Draw the burden bar
      WindowRectOp(winBars, miniwin.rect_fill, iBarLeft, iBurdenBarTop, iBarLeft+math.floor((iBurdenPercentage / 100) * iBarWidth), iBurdenBarTop+iBarsHeight, iBurdenColour)
      WindowRectOp(winBars, miniwin.rect_frame, iBarLeft, iBurdenBarTop, iBarLeft+iBarWidth, iBurdenBarTop+iBarsHeight, winThemeData.WINDOW_BORDER)
    end
    -- Draw the text overlays twice each (once for a faux-shadow)
    if (iCharVitals["maxhp"] == -1) then
      WindowText(winBars, sUseFont, "Not yet set", iBarLeft + 4, iHPBarTop + iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, "Not yet set", iBarLeft + 5, iHPBarTop + iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, "Not yet set", iBarLeft + 4, iGPBarTop + iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, "Not yet set", iBarLeft + 5, iGPBarTop + iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, "Not yet set", iBarLeft + 4, iBurdenBarTop + iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, "Not yet set", iBarLeft + 5, iBurdenBarTop + iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    else
      WindowText(winBars, sUseFont, iCharVitals["hp"] .. " / " .. iCharVitals["maxhp"], iBarLeft + 4, iHPBarTop + iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, iCharVitals["hp"] .. " / " .. iCharVitals["maxhp"], iBarLeft + 5, iHPBarTop + iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, iCharVitals["gp"] .. " / " .. iCharVitals["maxgp"], iBarLeft + 4, iGPBarTop + iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, iCharVitals["gp"] .. " / " .. iCharVitals["maxgp"], iBarLeft + 5, iGPBarTop + iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, iCharVitals["burden"] .. " %", iBarLeft + 4, iBurdenBarTop + iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, iCharVitals["burden"] .. " %", iBarLeft + 5, iBurdenBarTop + iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    end
  -- Vertical bar stacking
  elseif (iVitalsFormat == 1) then
    -- Core vitals data caching for speed
    if (bForceVitalsCache == true) then
      bForceVitalsCache = false
      -- Calculate the bar heights, widths, and locations based on the window size
      objVitalsCache.iBarsHeight = WINDATA[winBars]["HEIGHT"] - 4
      if (objVitalsCache.iBarsHeight < 30 or WINDATA[winBars]["WIDTH"] < 400) then
        objVitalsCache.sUseFont = "bodyfont"
      elseif (objVitalsCache.iBarsHeight < 60) then
        objVitalsCache.sUseFont = "bodyfontm"
      else
        objVitalsCache.sUseFont = "bodyfontl"
      end
      -- Get the width of the left-bar-text
      objVitalsCache.iKeyWidth = WindowTextWidth(winBars, objVitalsCache.sUseFont, "GP")
      objVitalsCache.iBarWidth = math.floor((WINDATA[winBars]["WIDTH"] - (objVitalsCache.iKeyWidth * 3)) / 3) - 3
      if (bShowAlignment == true) then
        objVitalsCache.iBarWidth = objVitalsCache.iBarWidth - math.floor(WindowTextWidth(winBars, objVitalsCache.sUseFont, iCharVitals["alignment"] .. "sb") / 3)
      end
      objVitalsCache.iHPBarLeft = objVitalsCache.iKeyWidth + 3
      objVitalsCache.iGPBarLeft = objVitalsCache.iHPBarLeft + objVitalsCache.iBarWidth + objVitalsCache.iKeyWidth + 3
      objVitalsCache.iBurdenBarLeft = objVitalsCache.iGPBarLeft + objVitalsCache.iBarWidth + objVitalsCache.iKeyWidth + 3
      objVitalsCache.iCentreFontLeft = 0
      objVitalsCache.iCentreFontHeight = 2 + math.floor((objVitalsCache.iBarsHeight - iFontSizes[winBars]["lineheight"]) * 0.5)
    end
    -- Load in the cached data
    iBarsHeight = objVitalsCache.iBarsHeight
    iBarWidth = objVitalsCache.iBarWidth
    iKeyWidth = objVitalsCache.iKeyWidth
    sUseFont = objVitalsCache.sUseFont
    iCentreFontHeight = objVitalsCache.iCentreFontHeight 
    local iHPBarLeft = objVitalsCache.iHPBarLeft
    local iGPBarLeft = objVitalsCache.iGPBarLeft
    local iBurdenBarLeft = objVitalsCache.iBurdenBarLeft
    local iCentreFontLeft = objVitalsCache.iCentreFontLeft

    -- Draw the texts to the left of the bars
    WindowText(winBars, sUseFont, "HP", 2, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    WindowText(winBars, sUseFont, "GP", iGPBarLeft - iKeyWidth, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    WindowText(winBars, sUseFont, "B", iBurdenBarLeft - iKeyWidth, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    if (bShowAlignment == true) then
      WindowText(winBars, sUseFont, iCharVitals["alignment"], iBurdenBarLeft + iBarWidth + 4, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    end
    -- Gradients on or off
    if (bVitalsGradients == true) then
      -- Draw the HP bars
      WindowGradient (winBars, iHPBarLeft, 2, iHPBarLeft+math.floor((iHPPercentage / 100) * iBarWidth), 2 + (iBarsHeight * 0.5), 0x000000, iHPColour, 2) 
      WindowGradient (winBars, iHPBarLeft, 2 + (iBarsHeight * 0.5), iHPBarLeft+math.floor((iHPPercentage / 100) * iBarWidth), 2 + iBarsHeight, iHPColour, 0x000000, 2) 
      WindowRectOp(winBars, miniwin.rect_frame, iHPBarLeft, 2, iHPBarLeft+iBarWidth, 2+iBarsHeight, winThemeData.WINDOW_BORDER)
      -- Draw the GP bars
      WindowGradient (winBars, iGPBarLeft, 2, iGPBarLeft+math.floor((iGPPercentage / 100) * iBarWidth), 2 + (iBarsHeight * 0.5), 0x000000, iGPColour, 2) 
      WindowGradient (winBars, iGPBarLeft, 2 + (iBarsHeight * 0.5), iGPBarLeft+math.floor((iGPPercentage / 100) * iBarWidth), 2 + iBarsHeight, iGPColour, 0x000000, 2) 
      WindowRectOp(winBars, miniwin.rect_frame, iGPBarLeft, 2, iGPBarLeft+iBarWidth, 2+iBarsHeight, winThemeData.WINDOW_BORDER)
      -- Draw the burden bars
      WindowGradient (winBars, iBurdenBarLeft, 2, iBurdenBarLeft+math.floor((iBurdenPercentage / 100) * iBarWidth), 2 + (iBarsHeight * 0.5), 0x000000, iBurdenColour, 2) 
      WindowGradient (winBars, iBurdenBarLeft, 2 + (iBarsHeight * 0.5), iBurdenBarLeft+math.floor((iBurdenPercentage / 100) * iBarWidth), 2 + iBarsHeight, iBurdenColour, 0x000000, 2) 
      WindowRectOp(winBars, miniwin.rect_frame, iBurdenBarLeft, 2, iBurdenBarLeft+iBarWidth, 2+iBarsHeight, winThemeData.WINDOW_BORDER)
    else
      -- Draw the HP bar
      WindowRectOp(winBars, miniwin.rect_fill, iHPBarLeft, 2, iHPBarLeft+math.floor((iHPPercentage / 100) * iBarWidth), 2+iBarsHeight, iHPColour)
      WindowRectOp(winBars, miniwin.rect_frame, iHPBarLeft, 2, iHPBarLeft+iBarWidth, 2+iBarsHeight, winThemeData.WINDOW_BORDER)
      -- Draw the GP bar
      WindowRectOp(winBars, miniwin.rect_fill, iGPBarLeft, 2, iGPBarLeft+math.floor((iGPPercentage / 100) * iBarWidth), 2+iBarsHeight, iGPColour)
      WindowRectOp(winBars, miniwin.rect_frame, iGPBarLeft, 2, iGPBarLeft+iBarWidth, 2+iBarsHeight, winThemeData.WINDOW_BORDER)
      -- Draw the burden bar
      WindowRectOp(winBars, miniwin.rect_fill, iBurdenBarLeft, 2, iBurdenBarLeft+math.floor((iBurdenPercentage / 100) * iBarWidth), 2+iBarsHeight, iBurdenColour)
      WindowRectOp(winBars, miniwin.rect_frame, iBurdenBarLeft, 2, iBurdenBarLeft+iBarWidth, 2+iBarsHeight, winThemeData.WINDOW_BORDER)
    end
    -- Draw the text overlays twice each (once for a faux-shadow)
    if (iCharVitals["maxhp"] == -1) then
      WindowText(winBars, sUseFont, "Not set", iHPBarLeft + 4, iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, "Not set", iHPBarLeft + 5, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, "Not set", iGPBarLeft + 4, iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, "Not set", iGPBarLeft + 5, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, "Not set", iBurdenBarLeft + 4, iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, "Not set", iBurdenBarLeft + 5, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    else
      WindowText(winBars, sUseFont, iCharVitals["hp"] .. " / " .. iCharVitals["maxhp"], iHPBarLeft + 4, iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, iCharVitals["hp"] .. " / " .. iCharVitals["maxhp"], iHPBarLeft + 5, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, iCharVitals["gp"] .. " / " .. iCharVitals["maxgp"], iGPBarLeft + 4, iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, iCharVitals["gp"] .. " / " .. iCharVitals["maxgp"], iGPBarLeft + 5, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, iCharVitals["burden"] .. " %", iBurdenBarLeft + 4, iCentreFontHeight - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, iCharVitals["burden"] .. " %", iBurdenBarLeft + 5, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    end
  -- Sideways bar stacking
  else
    -- Core vitals data caching for speed
    if (bForceVitalsCache == true) then
      bForceVitalsCache = false
      -- Calculate the bar heights, widths, and locations based on the window size
      objVitalsCache.iBarsHeight = WINDATA[winBars]["HEIGHT"] - 4 - iFontSizes[winBars]["lineheight"]
      objVitalsCache.iCentreFontHeight  = 2
      objVitalsCache.iBarTops = 2 + iFontSizes[winBars]["lineheight"]
      -- Take off extra height if we have alignment showing
      if (bShowAlignment == true) then
        objVitalsCache.iBarsHeight = objVitalsCache.iBarsHeight - iFontSizes[winBars]["lineheight"]
        objVitalsCache.iCentreFontHeight = iFontSizes[winBars]["lineheight"] + 2
        objVitalsCache.iBarTops = objVitalsCache.iBarTops + iFontSizes[winBars]["lineheight"]
      end
      -- Get the bar widths (just a 3-way split)
      objVitalsCache.iBarWidth = math.floor(WINDATA[winBars]["WIDTH"] / 3) - 3
      -- Increasing font-size automatically?
      --if (objVitalsCache.iBarWidth < 30 or WINDATA[winBars]["WIDTH"] < 400) then
        objVitalsCache.sUseFont = "bodyfont"
      --[[elseif (objVitalsCache.iBarsHeight < 60) then
        objVitalsCache.sUseFont = "bodyfontm"
      else
        objVitalsCache.sUseFont = "bodyfontl"
      end--]]
      objVitalsCache.iHPBarLeft = 3
      objVitalsCache.iGPBarLeft = objVitalsCache.iHPBarLeft + objVitalsCache.iBarWidth + 3
      objVitalsCache.iBurdenBarLeft = objVitalsCache.iGPBarLeft + objVitalsCache.iBarWidth + 3
    end
    -- Load in the cached data
    iBarsHeight = objVitalsCache.iBarsHeight
    iBarWidth = objVitalsCache.iBarWidth
    sUseFont = objVitalsCache.sUseFont
    iCentreFontHeight = objVitalsCache.iCentreFontHeight 
    local iHPBarLeft = objVitalsCache.iHPBarLeft
    local iGPBarLeft = objVitalsCache.iGPBarLeft
    local iBurdenBarLeft = objVitalsCache.iBurdenBarLeft
    local iBarTops = objVitalsCache.iBarTops

    -- Draw the texts to the left of the bars
    WindowText(winBars, sUseFont, "HP", iHPBarLeft + 2, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    WindowText(winBars, sUseFont, "GP", iGPBarLeft + 2, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    WindowText(winBars, sUseFont, "B", iBurdenBarLeft + 2, iCentreFontHeight, 0, 0, iCOLOUR.silver, false)
    if (bShowAlignment == true) then
      WindowText(winBars, sUseFont, iCharVitals["alignment"], iHPBarLeft + 2, 2, 0, 0, iCOLOUR.silver, false)
    end
    -- Gradients on or off
    if (bVitalsGradients == true) then
      if (iVitalsFormat == 2) then
        -- Downwards Bars
        -- iBarTops
        -- iBarsHeight
        -- iBarWidth
        -- Draw the HP bars
        WindowGradient (winBars, iHPBarLeft, iBarTops, iHPBarLeft + (iBarWidth * 0.5), iBarTops + math.floor((iHPPercentage / 100) * iBarsHeight), 0x000000, iHPColour, 1) 
        WindowGradient (winBars, iHPBarLeft + (iBarWidth * 0.5), iBarTops, iHPBarLeft + iBarWidth, iBarTops + math.floor((iHPPercentage / 100) * iBarsHeight), iHPColour, 0x000000, 1) 
        WindowRectOp(winBars, miniwin.rect_frame, iHPBarLeft, iBarTops, iHPBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
        -- Draw the GP bars
        WindowGradient (winBars, iGPBarLeft, iBarTops, iGPBarLeft + (iBarWidth * 0.5), iBarTops + math.floor((iGPPercentage / 100) * iBarsHeight), 0x000000, iGPColour, 1) 
        WindowGradient (winBars, iGPBarLeft + (iBarWidth * 0.5), iBarTops, iGPBarLeft + iBarWidth, iBarTops + math.floor((iGPPercentage / 100) * iBarsHeight), iGPColour, 0x000000, 1) 
        WindowRectOp(winBars, miniwin.rect_frame, iGPBarLeft, iBarTops, iGPBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
        -- Draw the burden bars
        WindowGradient (winBars, iBurdenBarLeft, iBarTops, iBurdenBarLeft + (iBarWidth * 0.5), iBarTops + math.floor((iBurdenPercentage / 100) * iBarsHeight), 0x000000, iBurdenColour, 1) 
        WindowGradient (winBars, iBurdenBarLeft + (iBarWidth * 0.5), iBarTops, iBurdenBarLeft + iBarWidth, iBarTops + math.floor((iBurdenPercentage / 100) * iBarsHeight), iBurdenColour, 0x000000, 1) 
        WindowRectOp(winBars, miniwin.rect_frame, iBurdenBarLeft, iBarTops, iBurdenBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
      else
        -- Upwards Bars
        -- Draw the HP bars
        WindowGradient (winBars, iHPBarLeft, iBarTops + (iBarsHeight - math.floor((iHPPercentage / 100) * iBarsHeight)), iHPBarLeft + (iBarWidth * 0.5), iBarTops + iBarsHeight, 0x000000, iHPColour, 1) 
        WindowGradient (winBars, iHPBarLeft + (iBarWidth * 0.5), iBarTops + (iBarsHeight - math.floor((iHPPercentage / 100) * iBarsHeight)), iHPBarLeft + iBarWidth, iBarTops + iBarsHeight, iHPColour, 0x000000, 1) 
        WindowRectOp(winBars, miniwin.rect_frame, iHPBarLeft, iBarTops, iHPBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
        -- Draw the GP bars
        WindowGradient (winBars, iGPBarLeft, iBarTops + (iBarsHeight - math.floor((iGPPercentage / 100) * iBarsHeight)), iGPBarLeft + (iBarWidth * 0.5), iBarTops + iBarsHeight, 0x000000, iGPColour, 1) 
        WindowGradient (winBars, iGPBarLeft + (iBarWidth * 0.5), iBarTops + (iBarsHeight - math.floor((iGPPercentage / 100) * iBarsHeight)), iGPBarLeft + iBarWidth, iBarTops + iBarsHeight, iGPColour, 0x000000, 1) 
        WindowRectOp(winBars, miniwin.rect_frame, iGPBarLeft, iBarTops, iGPBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
        -- Draw the burden bars
        WindowGradient (winBars, iBurdenBarLeft, iBarTops + (iBarsHeight - math.floor((iBurdenPercentage / 100) * iBarsHeight)), iBurdenBarLeft + (iBarWidth * 0.5), iBarTops + iBarsHeight, 0x000000, iBurdenColour, 1) 
        WindowGradient (winBars, iBurdenBarLeft + (iBarWidth * 0.5), iBarTops + (iBarsHeight - math.floor((iBurdenPercentage / 100) * iBarsHeight)), iBurdenBarLeft + iBarWidth, iBarTops + iBarsHeight, iBurdenColour, 0x000000, 1) 
        WindowRectOp(winBars, miniwin.rect_frame, iBurdenBarLeft, iBarTops, iBurdenBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
      end
    else
      if (iVitalsFormat == 2) then
        -- Downwards Bars
        -- Draw the HP bar
        WindowRectOp(winBars, miniwin.rect_fill, iHPBarLeft, iBarTops, iHPBarLeft+iBarWidth, iBarTops + math.floor((iHPPercentage / 100) * iBarsHeight), iHPColour)
        WindowRectOp(winBars, miniwin.rect_frame, iHPBarLeft, iBarTops, iHPBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
        -- Draw the GP bar
        WindowRectOp(winBars, miniwin.rect_fill, iGPBarLeft, iBarTops, iGPBarLeft+iBarWidth, iBarTops + math.floor((iGPPercentage / 100) * iBarsHeight), iGPColour)
        WindowRectOp(winBars, miniwin.rect_frame, iGPBarLeft, iBarTops, iGPBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
        -- Draw the burden bar
        WindowRectOp(winBars, miniwin.rect_fill, iBurdenBarLeft, iBarTops, iBurdenBarLeft+iBarWidth, iBarTops + math.floor((iBurdenPercentage / 100) * iBarsHeight), iBurdenColour)
        WindowRectOp(winBars, miniwin.rect_frame, iBurdenBarLeft, iBarTops, iBurdenBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
      else
        -- Upwards Bars
        -- Draw the HP bar
        WindowRectOp(winBars, miniwin.rect_fill, iHPBarLeft, iBarTops + (iBarsHeight - math.floor((iHPPercentage / 100) * iBarsHeight)), iHPBarLeft+iBarWidth, iBarTops + iBarsHeight, iHPColour)
        WindowRectOp(winBars, miniwin.rect_frame, iHPBarLeft, iBarTops, iHPBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
        -- Draw the GP bar
        WindowRectOp(winBars, miniwin.rect_fill, iGPBarLeft, iBarTops + (iBarsHeight - math.floor((iGPPercentage / 100) * iBarsHeight)), iGPBarLeft+iBarWidth, iBarTops + iBarsHeight, iGPColour)
        WindowRectOp(winBars, miniwin.rect_frame, iGPBarLeft, iBarTops, iGPBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
        -- Draw the burden bar
        WindowRectOp(winBars, miniwin.rect_fill, iBurdenBarLeft, iBarTops + (iBarsHeight - math.floor((iBurdenPercentage / 100) * iBarsHeight)), iBurdenBarLeft+iBarWidth, iBarTops + iBarsHeight, iBurdenColour)
        WindowRectOp(winBars, miniwin.rect_frame, iBurdenBarLeft, iBarTops, iBurdenBarLeft+iBarWidth, iBarTops+iBarsHeight, winThemeData.WINDOW_BORDER)
      end
    end
    -- Draw the text overlays twice each (once for a faux-shadow)
    if (iCharVitals["maxhp"] == -1) then
      WindowText(winBars, sUseFont, "Not set", iHPBarLeft + 4, iBarTops - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, "Not set", iHPBarLeft + 5, iBarTops, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, "Not set", iGPBarLeft + 4, iBarTops - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, "Not set", iGPBarLeft + 5, iBarTops, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, "Not set", iBurdenBarLeft + 4, iBarTops - 1, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, "Not set", iBurdenBarLeft + 5, iBarTops, 0, 0, iCOLOUR.silver, false)
    else
      WindowText(winBars, sUseFont, " " .. iCharVitals["hp"], iHPBarLeft + 4, iBarTops, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, " " .. iCharVitals["hp"], iHPBarLeft + 5, iBarTops + 1, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, "[" .. iCharVitals["maxhp"] .. "]", iHPBarLeft + 4, iBarTops + iFontSizes[winBars]["lineheight"], 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, "[" .. iCharVitals["maxhp"] .. "]", iHPBarLeft + 5, iBarTops + 1 + iFontSizes[winBars]["lineheight"], 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, " " .. iCharVitals["gp"], iGPBarLeft + 4, iBarTops, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, " " .. iCharVitals["gp"], iGPBarLeft + 5, iBarTops + 1, 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, "[" .. iCharVitals["maxgp"] .. "]", iGPBarLeft + 4, iBarTops + iFontSizes[winBars]["lineheight"], 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, "[" .. iCharVitals["maxgp"] .. "]", iGPBarLeft + 5, iBarTops + 1 + iFontSizes[winBars]["lineheight"], 0, 0, iCOLOUR.silver, false)
      WindowText(winBars, sUseFont, iCharVitals["burden"] .. " %", iBurdenBarLeft + 4, iBarTops, 0, 0, winThemeData.TEXTSHADOW, false)
      WindowText(winBars, sUseFont, iCharVitals["burden"] .. " %", iBurdenBarLeft + 5, iBarTops + 1, 0, 0, iCOLOUR.silver, false)
    end
  end
  -- Border the whole window
  WindowRectOp(winBars, miniwin.rect_frame, 0, 0, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], winThemeData.WINDOW_BORDER)
end

-- ****************************************
-- ***** Colour Phasing by Percentage *****
-- ****************************************
-- Gradiate a colour through three possibilities
function PercentageToColour(iPerc, iHigh, iMed, iLow)
  -- Convert the 0-100 percentage, to a range of -1 through to +1
  local iRange = (math.min(math.max(0, iPerc), 100) - 50) / 50
  -- Convert the RGB into hex so we can split off the three channels
  local sHighHex = string.format("%06X", iHigh)
  local sMedHex = string.format("%06X", iMed)
  local sLowHex = string.format("%06X", iLow)
  -- Convert hex back to decimal, now cutting into the three RGB channels, for the three provided colours
  local iHighR = tonumber(string.sub(sHighHex, 5, 6), 16)
  local iHighG = tonumber(string.sub(sHighHex, 3, 4), 16)
  local iHighB = tonumber(string.sub(sHighHex, 1, 2), 16)
  local iMedR = tonumber(string.sub(sMedHex, 5, 6), 16)
  local iMedG = tonumber(string.sub(sMedHex, 3, 4), 16)
  local iMedB = tonumber(string.sub(sMedHex, 1, 2), 16)
  local iLowR = tonumber(string.sub(sLowHex, 5, 6), 16)
  local iLowG = tonumber(string.sub(sLowHex, 3, 4), 16)
  local iLowB = tonumber(string.sub(sLowHex, 1, 2), 16)
  -- Now apply the range to each of those three channels for all three colours passed in, weighted from high through to low
  local iColR = math.ceil((iHighR * math.max(0, iRange)) + (iMedR * (1 - math.abs(iRange))) + (iLowR * math.max(0, -iRange)))
  local iColG = math.ceil((iHighG * math.max(0, iRange)) + (iMedG * (1 - math.abs(iRange))) + (iLowG * math.max(0, -iRange)))
  local iColB = math.ceil((iHighB * math.max(0, iRange)) + (iMedB * (1 - math.abs(iRange))) + (iLowB * math.max(0, -iRange)))
  -- Return the final sum in RGB form
  return (iColR + (iColG * 256) + (iColB * 65536))
end
-- Cache of colours optimisation
iPercToColour = {["hp"] = {}, ["gp"] = {}, ["b"] = {}}
for iN = 0, 100 do
  iPercToColour["hp"][iN] = PercentageToColour(iN, sUSER_OPTIONS["vitals_hp_a"], sUSER_OPTIONS["vitals_hp_b"], sUSER_OPTIONS["vitals_hp_c"])
  iPercToColour["gp"][iN] = PercentageToColour(iN, sUSER_OPTIONS["vitals_gp_a"], sUSER_OPTIONS["vitals_gp_b"], sUSER_OPTIONS["vitals_gp_c"])
  iPercToColour["b"][iN] = PercentageToColour(iN, sUSER_OPTIONS["vitals_b_a"], sUSER_OPTIONS["vitals_b_b"], sUSER_OPTIONS["vitals_b_c"])
end

-- ****************************************
-- ***** String And Styles into Table *****
-- ****************************************
-- Just a word breakdown
local function StringToWordTable(sLineText)
  local sWordsTable, iFound = {}, sLineText:find("(%s+)()(%S+)()")
  if iFound then
    sWordsTable[1] = string.sub(sLineText, 1, iFound-1)
  else 
    return {sLineText}
  end
  sLineText:gsub("(%s+)()(%S+)()",
    function(sp, st, sWord, fi)
      sWordsTable[#sWordsTable + 1] = " " .. sWord
    end)
  return sWordsTable
end
-- Converts a large bit of string sent by the mud, including raw MXP codes, into a table of words with style colours
local function StringToStyleTable(sLineText)
  local sWordsTable, iHere, sThisColour, sSplitWord, iFound = {}, 1, sCOLOUR.silver, "", sLineText:find("(%s+)()(%S+)()")
  if iFound then
    sWordsTable[1] = {string.sub(sLineText, 1, iFound-1), sThisColour}
  else 
    return {sLineText, sThisColour}
  end
  sLineText:gsub("(%s+)()(%S+)()",
    function(sp, st, sWord, fi)
      -- Look for the START of a new colour-style MXP code
      if (string.sub(sWord, 1, 13) == "\\u001b[4zMXP<") then
        iHere = string.find(sWord, "MXP>")
        sThisColour = string.sub(sWord, 14, iHere - 1)
        if (string.sub(sThisColour, 1, 2) == "C ") then
          sThisColour = string.sub(sThisColour, 3)
        end
        sWord = string.sub(sWord, iHere + 4)
        -- Could be 2 colour-codes because of PK colour options
        if (string.sub(sWord, 1, 13) == "\\u001b[4zMXP<") then
          iHere = string.find(sWord, "MXP>")
          sThisColour = string.sub(sWord, 14, iHere - 1)
          if (string.sub(sThisColour, 1, 2) == "C ") then
            sThisColour = string.sub(sThisColour, 3)
          end
          sWord = string.sub(sWord, iHere + 4)
        end
      end
      -- Check for the code to STOP colour-styles now
      iHere = string.find(sWord, "\\u001b%[3z")
      if (iHere ~= nil) then
        sSplitWord = string.sub(sWord, 1, iHere - 1)
        sWordsTable[#sWordsTable + 1] = {" " .. sSplitWord, sThisColour}
        sThisColour = sCOLOUR.silver
        sWord = string.sub(sWord, iHere + 9)
        sWordsTable[#sWordsTable + 1] = {sWord, sThisColour}
      else
        sWordsTable[#sWordsTable + 1] = {" " .. sWord, sThisColour}
      end
    end)
  return sWordsTable
end



-- ****************************************************************
-- ***** Integrated MDT Written Map MapDoorText data handling *****
-- ****************************************************************
-- Tables for storing MapDoorText
sLastFullMDT = ""
iEnemiesBySquare = {}
objEntityTable = {}
iLongestMDTDir = 0
iMDTRoomsIgnored = 0
iLongestMDTDir = 0
local objMDTPlayerRex = rex.new ("^[a-zA-Z](\\S*\\s*){0,4}$")
local objMDTDoorRex = rex.new ("^(doors |a door |exits |an exit |a hard to see through exit )")
local objMDTVisionRex = rex.new ("^the limit of your vision:")

-- MDT room-value table-sort functions
function QuowMDTValueCompare(a, b)
  return a[4] < b[4]
end
function QuowMDTReverseValueCompare(a, b)
  return a[4] > b[4]
end
function QuowEntityValueSort(a, b)
  return a[3] > b[3]
end

-- Create a whole new MDT entry, either from the user or automatically
function InsertMDTEntry(objNewMDT, bAutomatic)
  local iHighestMDTID, iUseID, bRecreate = 1, -1, false
  -- Build a list of any used-ID slots
  for iThisID, sThisMDT in pairs(sMDTData) do
    if (iThisID >= iHighestMDTID) then
      iHighestMDTID = (iThisID + 1)
    end
    -- Also check we don't already have this exact same trigger - no point re-adding it!
    if (sThisMDT["match_text"] == objNewMDT["match_text"]) then
      -- Check if everything is identical
      if (sThisMDT["category"] == objNewMDT["category"] and sThisMDT["colour"] == objNewMDT["colour"] and sThisMDT["score"] == objNewMDT["score"] and sThisMDT["matchtype"] == objNewMDT["matchtype"] and sThisMDT["map_region"] == objNewMDT["map_region"]) then
        if (bAutomatic ~= true) then
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar Notice:")
          ColourNote(sCOLOUR.silver, "", "There was already an MDT match for your EXACT settings, literally the same everything, so creation has been skipped.")
        end
        return 3
      end
      bRecreate = true
      iUseID = iThisID
      if (bAutomatic ~= true) then
        ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar Notice:")
        ColourNote(sCOLOUR.silver, "", "There was already an MDT match for your exact pattern string, it will be overwritten with your new settings.")
      end
    end
  end
  -- Did we not find one to replace?
  if (iUseID == -1) then
    -- Look for any gaps in ID slots, use the lowest-first
    for iN = 1, iHighestMDTID do
      if (sMDTData[iN] == nil) then
        iUseID = iN
        break
      end
    end
  end
  -- No space found?
  if (iUseID == -1) then
    Note("There are no free slots for adding new MDT entries to, please delete unused ones, or use advanced wildcards to merge multiple triggers into one!")
    return 0
  end
  -- Create the entry, add it to categories etc.
  sMDTData[iUseID] = {["match_text"] = objNewMDT["match_text"], ["category"] = objNewMDT["category"], ["colour"] = objNewMDT["colour"], ["score"] = objNewMDT["score"], ["matchtype"] = objNewMDT["matchtype"], ["map_region"] = objNewMDT["map_region"]}
  if (sMDTData[iUseID]["matchtype"] == 1) then
    sMDTData[iUseID]["regex"] = rex.new(sMDTData[iUseID]["match_text"])
  end
  -- Insert into the database/Update the database
  if (bRecreate == false) then
    sSQL = "INSERT INTO user_mdt (mdt_id, match_text, category, colour, score, matchtype, map_region) VALUES ('" .. iUseID .. "', '" .. 
           EscapeSQL(sMDTData[iUseID]["match_text"]) .. "', '" .. EscapeSQL(sMDTData[iUseID]["category"]) .. "', '" .. 
           EscapeSQL(sMDTData[iUseID]["colour"]) .. "', " .. sMDTData[iUseID]["score"] .. ", " .. sMDTData[iUseID]["matchtype"] .. ", " .. sMDTData[iUseID]["map_region"] .. ")"
  else
    sSQL = "UPDATE user_mdt SET category='" .. EscapeSQL(sMDTData[iUseID]["category"]) .. "', colour='" .. EscapeSQL(sMDTData[iUseID]["colour"]) .. 
           "', score=" .. sMDTData[iUseID]["score"] .. ", matchtype=" .. sMDTData[iUseID]["matchtype"] .. ", map_region=" ..  
           sMDTData[iUseID]["map_region"] .. " WHERE mdt_id=" .. iUseID
  end
  assert(dbUserData:execute(sSQL))
  -- Did we find a valid ID slot or not - notify the user for non-automatic insertions
  if (bAutomatic ~= true) then
    Tell("A new ")
    if (sMDTData[iUseID]["matchtype"] == 0) then
      Tell("basic ")
    elseif (sMDTData[iUseID]["matchtype"] == 1) then
      Tell("regex ")
    else
      Tell("colour ")
    end
    Tell("MDT entry has been created, and will now match in the MDT miniwindow and when you perform '")
    Hyperlink ("map door text", "map door text", "", sCOLOUR.cyan, "", 0)
    Tell("' commands.  It's ")
    if (sMDTData[iUseID]["matchtype"] < 2) then 
      Tell("match pattern/text is:  ")
      Note(sMDTData[iUseID]["match_text"])
    else
      Tell("match colour is:  ")
      ColourNote(sMDTData[iUseID]["match_text"], "", "  " .. sMDTData[iUseID]["match_text"])
    end
  end
  if (bRecreate == false) then
    return 1
  else
    return 2
  end
end

function RemoveMDTEntry(iRemoveMDTID)
  if (sMDTData[iRemoveMDTID] ~= nil) then
    -- Blank it
    sMDTData[iRemoveMDTID] = nil
    -- Remove from the database
    sSQL = "DELETE FROM user_mdt WHERE mdt_id=" .. iRemoveMDTID
    assert(dbUserData:execute(sSQL))
  end
end

-- Re-create (eg on first upgrade/install) all of the default MDT entries from old plugin
function CreateMDTDefaults(sResultNotes)
  -- Here's the default matches pulled in from the old MDT file for new-installs
  local sDefaultMDT = {
    {"skeleton warrior",             "",     "",         0, 0, 0},
    {"giant fruitbat",               "",     "",         0, 0, 0},
    {"fireflies",                    "",     "",         0, 0, 0},
    {"small blue light",             "",     "",         0, 0, 0},
    {"tortoise",                     "",     "",         0, 0, 0},
    {"cockroach",                    "",     "",         0, 0, 0},
    {".*clouds?$",                   "",     "",         0, 1, 0},
    {".*rats?$",                     "",     "",         0, 1, 0}, 
    {".*cats?$",                     "",     "",         0, 1, 0},
    {".*dogs?$",                     "",     "",         0, 1, 0},
    {".*pigeons?$",                  "",     "",         0, 1, 0},
    {"little old ladies",            "",     "orange",   2, 0, 1},  
    {"^.*banker$",                   "loot", "green",    5, 1, 1},  
    {"^.*accountant$",               "loot", "green",    5, 1, 1}, 
    {"^.*lawyer$",                   "loot", "green",    5, 1, 1},  
    {"imperial guard",               "",     "orange",   8, 0, 17},
    {"^(.+?) (?>fang|hong|mcsweeney|sung|tang) bodyguards?$", "", "orange", 4, 1, 17}, 
    {"^(.+?) (?>fang|hong|mcsweeney|sung|tang) noblem(en|an)$",   "", "#FF3CC4", 10, 1, 17}, 
    {"^(.+?) (?>fang|hong|mcsweeney|sung|tang) thugs?$",          "", "orange", 3, 1, 17},
    {"^(?>fang|hong|mcsweeney|sung|tang) captains?$",             "", "orange", 8, 1, 17}, 
    {"^(?>diligent|excellent|experienced|injured|learned|old|skilled|young) students?$",    "", "orange",  4, 1, 17},
    {"palace guard",                    "",       "orange",      8, 0, 23},
    {"d'reg",                           "",       "",            2, 0, 23}, 
    {"recruit",                         "",       "orange",      2, 0, 23}, 
    {"soldier",                         "",       "orange",      4, 0, 23},
    {"^ceremonial (guard|sentry|sentrie)s?$", "", "orange",      8, 1, 23}, 
    {"^(.+?) pries(t|ts|tess|tesses)$",              "", "",          0, 1, 23},
    {"^(.+?) wealthy (man|men|woman|women)$",    "loot", "green",     5, 1, 23}, 
    {"^rich ambassador(.?)",                     "loot", "green",     5, 1, 23},  
    {"hoplite",                         "",       "orange",      6, 0, 25}, 
    {"^(?>burly |hefty |muscular |wiry |sinewy |tough )m(?>an|en)$",   "",   "orange",      6, 1, 25}, 
    {"citadel guard",                   "",       "orange",     12, 0, 25}, 
    {"vyrt",                            "",       "purple",     10, 0, 25},
    {"philosopher",                     "",       "",            3, 0, 25},
    {"knight",                          "",       "orange",      4, 0, 27}, 
    {"^(?>muscular|immaculate|charming|refined|well-dressed|dapper|elegant) gentle(man|men)$",    "loot", "green",     5, 1, 27},  
    {"^(?>baron |baroness |duchess |duke |countess |count |earl |marquis |lady |sir )(.+)$",    "loot", "green",     5, 1, 27}, 
    {"hunter grflx",                    "",       "",            3, 0, 29},  
    {"grflx mentor",                    "",       "",            4, 0, 29}, 
    {"grflx adolescent",                "",       "",            1, 0, 29},  
    {"grflx worker",                    "",       "",            3, 0, 29},
    {"grflx workleader",                "",       "",            4, 0, 29}, 
    {"royal guard",                     "",       "orange",      5, 0, 39},  
    {"^(.+?) noble(man|men|woman|women)$",      "loot", "green",     5, 1, 39}, 
    {"^rich (m(an|en)|wom(an|en))$",        "loot", "green",     5, 1, 39},  
    {"^(.+?) (courtier)s?$",            "loot", "green",     5, 1, 39},  
    {"^(muscular|hulking|smirking|brooding|grinning|tough|scruffy|shady|suspicious|dashing|knowing|scarred|leering) (highwaym|character|runaway|vagrant|thug|m(an|en)|wom(an|en)).*$", "", "orange", 2, 1, 39}, 
    {"headless horse rider",       "",            "red",      10, 0, 54}, 
    -- Distant land default letters 
    {"^berti boggis$",             "letters",     "orchid",   10, 1, 0},
    {"^ryattenoki$",               "letters",     "orchid",   10, 1, 0},
    {"^very reverend khepresh$",   "letters",     "orchid",   10, 1, 0},
    {"^boy willie$",               "letters",     "orchid",   10, 1, 17},
    {"^glod-san$",                 "letters",     "orchid",   10, 1, 17},
    {"^laggy-san$",                "letters",     "orchid",   10, 1, 17},
    {"^lon fah lo$",               "letters",     "orchid",   10, 1, 17},
    {"^mad hamish$",               "letters",     "orchid",   10, 1, 17},
    {"^no go wan$",                "letters",     "orchid",   10, 1, 17},
    {"^quisoda$",                  "letters",     "orchid",   10, 1, 17},
    {"^ruto of fish$",             "letters",     "orchid",   10, 1, 17},
    {"^shi do gai$",               "letters",     "orchid",   10, 1, 17},
    {"^lap-lip$",                  "letters",     "orchid",   10, 1, 23},
    {"^lip-phon lap-top$",         "letters",     "orchid",   10, 1, 23},
    {"^mihk-gran-bohp$",           "letters",     "orchid",   10, 1, 23},
    {"^phos-phor$",                "letters",     "orchid",   10, 1, 23},
    {"^yclept$",                   "letters",     "orchid",   10, 1, 23},
    {"^casanunda$",                "letters",     "orchid",   10, 1, 27},
    {"^greig schwitz$",            "letters",     "orchid",   10, 1, 27},
    {"^noobie$",                   "letters",     "orchid",   10, 1, 27},
    {"^tfat chick$",               "letters",     "orchid",   10, 1, 27},
    {"^mr cmoho dhblah$",          "letters",     "orchid",   10, 1, 31},
    {"^miss pennie laced$",        "letters",     "orchid",   10, 1, 38},
    {"^tuffy the vampire slayer$", "letters",     "orchid",   10, 1, 46},
  }
  -- Make sure the "loot" and "letters" categories exist
  if (sMDTCategories["letters"] == nil) then
    sMDTCategories["letters"] = {false,}
  end
  if (sMDTCategories["loot"] == nil) then
    sMDTCategories["loot"] = {false,}
  end
  -- Loop through all the defaults, try to auto-insert each one, one-by-one
  local iMDTResult, iFailures, iInsertions, iReplacements, iSkipped = 0, 0, 0, 0, 0
  for _, sNewMDT in ipairs(sDefaultMDT) do
    iMDTResult = InsertMDTEntry({["match_text"] = sNewMDT[1], ["category"] = sNewMDT[2], ["colour"] = sNewMDT[3], ["score"] = sNewMDT[4], ["matchtype"] = sNewMDT[5], ["map_region"] = sNewMDT[6]}, true)
    if (iMDTResult == 0) then
      iFailures = iFailures + 1
    elseif (iMDTResult == 1) then
      iInsertions = iInsertions + 1
    elseif (iMDTResult == 2) then
      iInsertions = iInsertions + 1
    else
      iSkipped = iSkipped + 1
    end
  end
  if (sResultNotes == "y") then
    ColourNote(sCOLOUR.orange, "", "Attempting to restore default MDT matches... Skipped/Not needed: " .. iSkipped .. ".  Created: " .. tostring(iInsertions) .. ".  Replaced: " .. tostring(iReplacements) .. ". Failed: " .. tostring(iFailures))
  end
end

-- No MDT entries?  Create all defaults
if (iTotalMDT == 0) then
  CreateMDTDefaults("n")
end
iTotalMDT = nil

-- ************************
-- * Written text handler *
-- ************************
function ParseMDT( sName, sLine, wildcards, styles )
  local sStoredColour, bFullMDT = {}, false
  -- Rule out false positives, or if they have disabled advanced-parsing in the menu, regurgitate the exact mud-output back to the user
  if (sName == "DoorTextFull") then
    -- Cancel out of parsing
    if (bMDTParsingEnabled == false or string.sub(sLine, 1, 1) == "[" or string.sub(sLine, 1, 1) == "(" or string.find(sLine, ":")) then
      for iStyleKey, sThisStyle in ipairs(styles) do
        ColourTell(RGBColourToName(sThisStyle.textcolour), RGBColourToName(sThisStyle.backcolour), sThisStyle.text)
      end
      Note("")
      return
    end
    bFullMDT = true
    -- Grab some colourings, anything that isn't the default colour
    local iBaseColour = styles[#styles].textcolour
    for iStyleKey, sThisStyle in ipairs(styles) do
      if (iBaseColour ~= sThisStyle.textcolour) then
        sStoredColour[string.lower(sThisStyle.text)] = RGBColourToName(tonumber(sThisStyle.textcolour))
      end
    end
  end
  -- Default values
  local iRegexMatch, iHere, sNextColour, sLastDirection, iLastCount, bLastWasDir, bIgnoringExits, iThisEntityValue = 0, 0, "", "", 0, false, false, 0

  -- Make the input all lowercase and filter certain phrases and things out for easier comma-separation and matching
  local sFullLine = string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.gsub(string.lower(sLine), " are ", " is "), " black and white ", " black white "), " brown and white ", " brown white "), "the net dead statue of ", "netdead "), "the limit of your vision is ", "the limit of your vision:"), " and ", ", "), " is ", ", ")
  -- Now turn it into a table to process bit by bit
  local sCountTable, iRoomID, iRoomValue = QuowExplode(", ", sFullLine), 1, 0
  iEnemiesBySquare, objEntityTable = {}, {}
  objEntityTable[iRoomID] = {}
  iLongestMDTDir, iMDTRoomsIgnored = 0, 0
  -- Loop through every entity
  for iMonKey, sStringCut in pairs (sCountTable) do
    iRegexMatch = objMDTDoorRex:match(sStringCut)
    if (iRegexMatch ~= nil and iRegexMatch == 1) then
      bIgnoringExits = true
    else
      iRegexMatch = objMDTVisionRex:match(sStringCut)
      if (iRegexMatch ~= nil and iRegexMatch == 1) then
        -- End of segment - did we find anything?
        if (iLastCount > 0) then
          -- Is it a valuable room?
          if (iRoomValue >= iMDTMinimumScore) then
            -- For formatting purposes, what's the longest directional text
            if (string.len(sLastDirection) > iLongestMDTDir) then
              iLongestMDTDir = string.len(sLastDirection)
            end
          else
            -- Count of roms with things in that we ignored because of score value too low
            iMDTRoomsIgnored = iMDTRoomsIgnored + 1
          end
          -- Store the data efficiently
          iEnemiesBySquare[#iEnemiesBySquare+1] = { iLastCount, sLastDirection, iRoomID, iRoomValue }
          -- Sort the individual entities of that room
          table.sort(objEntityTable[iRoomID], QuowEntityValueSort)
          -- Reset variables
          sNextColour = ""
          iRoomID = iRoomID + 1
          objEntityTable[iRoomID] = {}
          iRoomValue = 0
        end
        sLastDirection = ""
        iLastCount = 0
        bLastWasDir = false
      else
        -- Find the quantity first
        local iQuantity, sThisDir, sTempMatch = 1, "", string.match(sStringCut, "%w+")
        if (sQuowNums[sTempMatch]) then
          iQuantity = sQuowNums[sTempMatch]
          sStringCut = string.sub(sStringCut, #sTempMatch + 2)
        end
        -- Now check for directions
        sTempMatch = string.match(sStringCut, "%w+")
        if (sMovementFull[sTempMatch]) then
          -- Normal MDT direction
          sThisDir = sMovementFull[sTempMatch]
          if (bIgnoringExits == false) then
            bLastWasDir = true
            if (sLastDirection ~= "") then
              sLastDirection = sLastDirection .. ", "
            end
            sLastDirection = sLastDirection .. iQuantity .. " " .. sThisDir
          end
        elseif (iCurMap == 63 and sUnsinkableMDT[sTempMatch]) then
          -- SS Unsinkable direction handler
          sThisDir = sUnsinkableMDT[sTempMatch]
          if (bIgnoringExits == false) then
            bLastWasDir = true
            if (sLastDirection ~= "") then
              sLastDirection = sLastDirection .. ", "
            end
            sLastDirection = sLastDirection .. iQuantity .. " " .. sThisDir
          end
        else
          bIgnoringExits = false
          if (bLastWasDir == true) then
            -- reset count
            if (iLastCount > 0) then
              if (iRoomValue >= iMDTMinimumScore) then
                if (string.len(sLastDirection) > iLongestMDTDir) then
                  iLongestMDTDir = string.len(sLastDirection)
                end
              else
                iMDTRoomsIgnored = iMDTRoomsIgnored + 1
              end
              iEnemiesBySquare[#iEnemiesBySquare + 1] = { iLastCount, sLastDirection, iRoomID, iRoomValue }
              -- Sort the individual entities of that room
              table.sort(objEntityTable[iRoomID], QuowEntityValueSort)
              -- Reset variables
              sNextColour = ""
              iRoomID = iRoomID + 1
              objEntityTable[iRoomID] = {}
              iRoomValue = 0
            end
            sLastDirection = ""
            iLastCount = 0
            bLastWasDir = false
          end

          sNextColour = ""

          -- Special GMCP MDT colour codes
          if (string.sub(sStringCut, 1, 13) == "\\u001b[4zmxp<") then
            --\u001b[4zmxp<c #ff0000mxp>george\u001b[3z
            --\u001b[4zmxp<magentamxp>frank\u001b[3z
            iHere = string.find(sStringCut, "mxp>")
            sNextColour = string.sub(sStringCut, 14, iHere - 1)
            if (string.sub(sNextColour, 1, 2) == "c ") then
              sNextColour = string.sub(sNextColour, 3)
            end
            sStringCut = string.sub(sStringCut, iHere + 4, -10)
            -- may be a 2nd colour tag for playernames
            if (string.sub(sStringCut, 1, 13) == "\\u001b[4zmxp<") then
              iHere = string.find(sStringCut, "mxp>")
              sNextColour = string.sub(sStringCut, 14, iHere - 1)
              if (string.sub(sNextColour, 1, 2) == "c ") then
                sNextColour = string.sub(sNextColour, 3)
              end
              sStringCut = string.sub(sStringCut, iHere + 4)
            end
          elseif (string.sub(sStringCut, -9) == "\\u001b[3z") then
            sStringCut = string.sub(sStringCut, 1, -10)
          elseif (bFullMDT == true) then
            if (sStoredColour[sStringCut] ~= nil) then
              sNextColour = sStoredColour[sStringCut]
            end
          end

          -- Value of this NPC, start with the default
          local iThisValue, bColourPriority = iMDTDefaultValue, false

          -- Search the table of map-door-text string matches to look for enemies to highlight
          for sKey, sValue in pairs (sMDTData) do
            -- Check it's a matching map or no-care map
            if (sValue["map_region"] == 0 or sValue["map_region"] == iCurMap or (sRegionLinkGroups[sValue["map_region"]] ~= nil and sRegionLinkGroups[sValue["map_region"]][iCurMap] == true)) then
              -- Now check if it's the default category, or our current selected category
              if (sValue["category"] == "" or (sMDTCategories[sValue["category"]] ~= nil and sMDTCategories[sValue["category"]][1] == true)) then
                -- Now check if this is a regular string match, or a regex match
                if (sValue["matchtype"] == 0) then
                  -- Regular string matching
                  if (string.find(sStringCut, sValue["match_text"])) then
                    if (sValue["colour"] ~= "") then
                      sNextColour = sValue["colour"]
                    end
                    iThisValue = sValue["score"]
                    break
                  end
                elseif (sValue["matchtype"] == 1) then
                  -- Regex string matching
                  iRegexMatch = sValue["regex"]:match(sStringCut)
                  if (iRegexMatch ~= nil and iRegexMatch == 1) then
                    if (sValue["colour"] ~= "") then
                      sNextColour = sValue["colour"]
                    end
                    iThisValue = sValue["score"]
                    break
                  end
                else
                  -- Colour match-type
                  if (sNextColour == sValue["match_text"]) then
                    if (sValue["colour"] ~= "") then
                      sNextColour = sValue["colour"]
                    end
                    iThisValue = sValue["score"]
                    bColourPriority = true
                    break
                  end
                end -- Normal, regex or colour
              end  -- Category match
            end -- Map region match
          end -- Loop through the user's MDT filters

          -- Add the value onto the room score, multiplied by quantity
          iThisEntityValue = (iThisValue * iQuantity)
          iRoomValue = iRoomValue + iThisEntityValue
          -- Check for extra quantities

          -- Store the name, values, colours etc.
          if (iQuantity > 1) then
            sStringCut = iQuantity .. " " .. sStringCut
          end
          -- Fake value for player-colours
          if (bColourPriority == true) then
            iThisEntityValue = iThisEntityValue + 1000
          end
          -- Add this entity to the table
          objEntityTable[iRoomID][#objEntityTable[iRoomID]+1] = {sStringCut, sNextColour, iThisEntityValue}
          -- And how many "things" we've gotten through
          iLastCount = iLastCount + iQuantity
        end
      end -- Limit of vision or not
    end
  end -- Loop through comma-seperated

  if (sName == "WrittenMap") then
    -- Shorter/GMCP written map
    -- Table sorting
    table.sort(iEnemiesBySquare, QuowMDTReverseValueCompare)
    return true
  else
    -- Main map door text parser
    if (bMDTParsingEnabled == true) then
      sLastFullMDT = ""
    end
    -- Table sorting
    if (bMDTReverseSortOrder == true) then
      table.sort(iEnemiesBySquare, QuowMDTReverseValueCompare)
    else
      table.sort(iEnemiesBySquare, QuowMDTValueCompare)
    end
    if (#iEnemiesBySquare == 0) then
      Note("Nothing useful seen in adjacent rooms.")
    else
      local bDoneHere = false
      for iKey, sValue in pairs(iEnemiesBySquare) do
        -- Only show if this room has at least "iMDTMinimumScore" value
        if (sValue[4] >= iMDTMinimumScore) then
          bDoneHere = false
          Tell(string.format("%-" .. iLongestMDTDir .. "s ", sValue[2]) .. "[")
          ColourTell("orange", "", sValue[4])
          Tell("] ")
          -- The individual entities
          for iN = 1, #objEntityTable[sValue[3]] do
            if (bDoneHere == true) then
              Tell(", ")
            end
            ColourTell(objEntityTable[sValue[3]][iN][2], "", objEntityTable[sValue[3]][iN][1])
            bDoneHere = true
          end
          Tell(" [" .. sValue[1] .. " thing")
          if (sValue[1] > 1) then
            Tell("s")
          end
          Tell("]")
          Note("")
        end
      end
      if (iMDTRoomsIgnored > 0 and bMDTShowEmptyRoomCount == true) then
        Note("(" .. tostring(iMDTRoomsIgnored) .. " rooms below your value limit of " .. tostring(iMDTMinimumScore) .. ")")
      end
    end
    -- And update the written map window with the large version
    if (bMDTReverseSortOrder == false) then
      table.sort(iEnemiesBySquare, QuowMDTReverseValueCompare)
    end
    RedrawMDTWindow()
  end
end

-- For brief updates eg changing score-limit, to refresh the counts & lengths
function ReSortMDTRooms()
  iLongestMDTDir, iMDTRoomsIgnored = 0, 0
  for iKey, sValue in pairs (iEnemiesBySquare) do
    if (sValue[4] >= iMDTMinimumScore) then
      if (string.len(sValue[2]) > iLongestMDTDir) then
        iLongestMDTDir = string.len(sValue[2])
      end
    else
      iMDTRoomsIgnored = iMDTRoomsIgnored + 1
    end
  end
  RedrawMDTWindow()
end

-- Actually draw the window/refresh it
function RedrawMDTWindow()
  -- Save effort, do nothing if not showing this window
  if (WINDATA[winMDT]["SHOW"] == false) then
    return
  end

  local bDoneHere, sTempText = false, ""
  -- Clear the window afresh and draw a new border
  WindowRectOp(winMDT, miniwin.rect_fill, 0, 0, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], iCOLOUR.black)
  -- Text positioning
  local iMDTTextX = 1
  local iMDTTextY = WINDATA[winMDT]["HEIGHT"] - (iFontSizes[winMDT]["lineheight"] + 1)
  -- Parsed MDT, or vanilla?
  if (sLastFullMDT == "") then
    -- Fully parsed MDT redrawing
    local bAnythingShown = false
    for iKey, sValue in pairs (iEnemiesBySquare) do
      -- Only show if this room has at least "iMDTMinimumScore" value and it's within window limit
      if (sValue[4] >= iMDTMinimumScore) then
        bAnythingShown = true
        bDoneHere = false
        -- Do they have stupid pointless laggy forced-word-wrapping on for MDT lines, or the good normal 1-line-per-room system
        if (bMDTForceWordWrap == false) then
          -- Word wrap is *OFF*
          -- Show the direction and quantity of direction
          iMDTTextX = iMDTTextX + WindowText(winMDT, "bodyfont", string.format("%-" .. iLongestMDTDir .. "s ", sValue[2]) .. "[", iMDTTextX, iMDTTextY, 0, 0, iCOLOUR.silver, false)
          iMDTTextX = iMDTTextX + WindowText(winMDT, "bodyfont", sValue[4], iMDTTextX, iMDTTextY, 0, 0, iCOLOUR.orange, false)
          iMDTTextX = iMDTTextX + WindowText(winMDT, "bodyfont", "] ", iMDTTextX, iMDTTextY, 0, 0, iCOLOUR.silver, false)
          local sTempText = ""
          -- Loop through the entities WITHOUT the stupid pointless laggy word-wrapping
          for iN = 1, #objEntityTable[sValue[3]] do
            sTempText = objEntityTable[sValue[3]][iN][1]
            if (bDoneHere == true) then
              sTempText = ", " .. sTempText
            end
            if (objEntityTable[sValue[3]][iN][2] == "") then
              iMDTTextX = iMDTTextX + WindowText(winMDT, "bodyfont", sTempText, iMDTTextX, iMDTTextY, 0, 0, iCOLOUR.silver, false)
            else
              iMDTTextX = iMDTTextX + WindowText(winMDT, "bodyfont", sTempText, iMDTTextX, iMDTTextY, 0, 0, ColourNameToRGB(objEntityTable[sValue[3]][iN][2]), false)
            end
            bDoneHere = true
          end
        else
          -- Word wrap is *ON*
          local iMarginWidth = WindowTextWidth(winMDT, "bodyfont", string.format("%-" .. iLongestMDTDir .. "s ", sValue[2]))
          local iAddWidth = iMDTTextX + iMarginWidth + WindowTextWidth(winMDT, "bodyfont", "[" .. sValue[4] .. "] ")
          local iThisWidth = 0
          local iLinesNeeded = 0
          local iLinesRendered = 0
          -- Loop through the entities WITH the laggy word-wrapping
          for iN = 1, #objEntityTable[sValue[3]] do
            sTempText = objEntityTable[sValue[3]][iN][1]
            if (bDoneHere == true) then
              sTempText = ", " .. sTempText
            end
            -- Now go through word by word for the weird-word-wrapper-worriers
            for iWordCount, sWordText in pairs(StringToWordTable(sTempText)) do
              iThisWidth = WindowTextWidth(winMDT, "bodyfont", sWordText)
              -- New line needed?
              if ((iThisWidth + iAddWidth) > WINDATA[winMDT]["WIDTH"]) then
                -- This word was take us over the edge, so increase lines-needed count
                iLinesNeeded = iLinesNeeded + 1
                iAddWidth = iMarginWidth
                -- Remove EXTRA spaces that aren't needed
                if (string.sub(sWordText, 1, 1) == " ") then
                  sWordText = string.sub(sWordText, 2)
                end
              end
              -- Add on the width of the next word to the current line
              iAddWidth = iAddWidth + WindowTextWidth(winMDT, "bodyfont", sWordText)
            end
            bDoneHere = true
          end
          bDoneHere = false
          -- We know how many lines we need now, so shift upwards by extra lines before rendering downwards
          iMDTTextY = iMDTTextY - (iLinesNeeded * (iFontSizes[winMDT]["lineheight"] + 1))
          -- Show the direction and quantity of direction
          iMDTTextX = iMDTTextX + WindowText(winMDT, "bodyfont", string.format("%-" .. iLongestMDTDir .. "s ", sValue[2]) .. "[", iMDTTextX, iMDTTextY, 0, 0, iCOLOUR.silver, false)
          iMDTTextX = iMDTTextX + WindowText(winMDT, "bodyfont", sValue[4], iMDTTextX, iMDTTextY, 0, 0, iCOLOUR.orange, false)
          iMDTTextX = iMDTTextX + WindowText(winMDT, "bodyfont", "] ", iMDTTextX, iMDTTextY, 0, 0, iCOLOUR.silver, false)
          -- Now a 2nd loop through with the right line numbers
          for iN = 1, #objEntityTable[sValue[3]] do
            sTempText = objEntityTable[sValue[3]][iN][1]
            if (bDoneHere == true) then
              sTempText = ", " .. sTempText
            end
            -- Now go through word by word for the weird-word-wrapper-worriers
            for iWordCount, sWordText in pairs(StringToWordTable(sTempText)) do
              iThisWidth = WindowTextWidth(winMDT, "bodyfont", sWordText)
              -- New line needed?
              if ((iThisWidth + iMDTTextX) > WINDATA[winMDT]["WIDTH"]) then
                -- New line - force indentation spaces matching the longest directional text
                iMDTTextX = iMarginWidth
                -- Remove EXTRA spaces that aren't needed
                if (string.sub(sWordText, 1, 1) == " ") then
                  sWordText = string.sub(sWordText, 2)
                end
                -- And move the text down as appropriate
                iMDTTextY = iMDTTextY + (iFontSizes[winMDT]["lineheight"] + 1)
                iLinesRendered = iLinesRendered + 1
              end
              -- Draw the text to the window with the relevant colour code
              if (objEntityTable[sValue[3]][iN][2] == "") then
                iMDTTextX = iMDTTextX + WindowText(winMDT, "bodyfont", sWordText, iMDTTextX, iMDTTextY, 0, 0, iCOLOUR.silver, false)
              else
                iMDTTextX = iMDTTextX + WindowText(winMDT, "bodyfont", sWordText, iMDTTextX, iMDTTextY, 0, 0, ColourNameToRGB(objEntityTable[sValue[3]][iN][2]), false)
              end
            end
            bDoneHere = true
          end -- Loop through the entities
          -- Remove final extra lines back again
          iMDTTextY = iMDTTextY - (iLinesRendered * (iFontSizes[winMDT]["lineheight"] + 1))
        end -- Normal system, or weird-word-wrapper system
        -- Move the line up one, back to the start
        iMDTTextX = 1
        iMDTTextY = iMDTTextY - (iFontSizes[winMDT]["lineheight"] + 1)
      end
      -- Getting off the window?
      if (iMDTTextY < -iFontSizes[winMDT]["lineheight"]) then
        break
      end
    end -- Loop through each room in order
    if (iMDTRoomsIgnored > 0 and bMDTShowEmptyRoomCount == true and iMDTTextY > winThemeData.TITLE_HEIGHT) then
      sTempText = "(" .. tostring(iMDTRoomsIgnored) .. " room"
      if (iMDTRoomsIgnored > 1) then
        sTempText = sTempText .. "s"
      end
      sTempText = sTempText .. " below your value limit of " .. tostring(iMDTMinimumScore) .. ")"
      WindowText(winMDT, "bodyfont", sTempText, iMDTTextX, iMDTTextY, 0, 0, iCOLOUR.silver, false)
    end
    if (bAnythingShown == false and iMDTRoomsIgnored == 0) then
      WindowText(winMDT, "bodyfont", "(nothing nearby)", 2, 2, 0, 0, iCOLOUR.silver, false)
    end
  else
    -- "Raw" map door text, MDT parsing disabled, convert the raw text and the MXP colour codes and word-wrap it to the window
    local iTX, iTY, iAddWidth = 1, 1, 0
    local iLettersPerLine = (WINDATA[winMDT]["WIDTH"] / iFontSizes[winMDT]["fontwidth"]) - 2
    sLastFullMDT = string.gsub(sLastFullMDT, "\\u001b%[4zMXP<C ", "\\u001b%[4zMXP<")
    for iWordCount, sWordText in pairs(StringToStyleTable(sLastFullMDT)) do
      -- Loop through the individual words, with newly created style info
      if (sWordText[1] ~= nil) then
        iAddWidth = WindowTextWidth(winMDT, "bodyfont", sWordText[1])
        if ((iTX + iAddWidth) > WINDATA[winMDT]["WIDTH"]) then
          -- This word was take us over the edge, so put it onto the next line
          iTX = 1
          iTY = iTY + iFontSizes[winMDT]["lineheight"]
          -- No point starting a new line with a space, so remove leading spaces from this first line word!
          if (string.sub(sWordText[1], 1, 1) == " ") then
            iAddWidth = iAddWidth - iFontSizes[winMDT]["fontwidth"]
            sWordText[1] = string.sub(sWordText[1], 2)
          end
        end
        -- Draw the text to the window with the relevant colour code
        WindowText(winMDT, "bodyfont", sWordText[1], iTX, iTY, 0, 0, ColourNameToRGB(sWordText[2]), false)
        iTX = iTX + iAddWidth
      end
    end
  end
  -- Border the whole window
  WindowRectOp(winMDT, miniwin.rect_frame, 0, 0, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], winThemeData.WINDOW_BORDER)
end


-- Ask the user for a new colour selection, store it, update triggers, display samples etc.
function FetchShieldColour(sColourOption)
  iNewColour = PickColour(ColourNameToRGB(sUSER_OPTIONS[sColourOption]))
  if (iNewColour ~= -1) then
    sUSER_OPTIONS[sColourOption] = RGBColourToName(iNewColour)
    assert(dbUserData:execute("UPDATE user_options SET option_value='" .. EscapeSQL(sUSER_OPTIONS[sColourOption]) .. "' WHERE option_id='" .. sColourOption .. "'"))
    ColourNote(sUSER_OPTIONS[sColourOption], "", sRMBResult .. " sample A:  Colour is now changed to '" .. sUSER_OPTIONS[sColourOption] .. "'.")
    ColourNote(sUSER_OPTIONS[sColourOption], "", sRMBResult .. " sample B:  Colour is now changed to '" .. sUSER_OPTIONS[sColourOption] .. "'.")
    -- Have to use call plugin for this, as trigger data isn't plugin-specific in right-click menus for some reason!
    CallPlugin ("bfe35205f026786ea1d56e3b", "ShieldsRecolour", "", "")
  else
    ColourNote(sUSER_OPTIONS[sColourOption], "", sRMBResult .. " sample A:  Colour unchanged from '" .. sUSER_OPTIONS[sColourOption] .. "'.")
    ColourNote(sUSER_OPTIONS[sColourOption], "", sRMBResult .. " sample B:  Colour unchanged from '" .. sUSER_OPTIONS[sColourOption] .. "'.")
  end
end
function FetchTriggerColour(sColourOption)
  iNewColour = PickColour(ColourNameToRGB(sUSER_OPTIONS[sColourOption]))
  if (iNewColour ~= -1) then
    sUSER_OPTIONS[sColourOption] = RGBColourToName(iNewColour)
    assert(dbUserData:execute("UPDATE user_options SET option_value='" .. EscapeSQL(sUSER_OPTIONS[sColourOption]) .. "' WHERE option_id='" .. sColourOption .. "'"))
    ColourNote(sUSER_OPTIONS[sColourOption], "", sRMBResult .. " sample A:  Colour is now changed to '" .. sUSER_OPTIONS[sColourOption] .. "'.")
    ColourNote(sUSER_OPTIONS[sColourOption], "", sRMBResult .. " sample B:  Colour is now changed to '" .. sUSER_OPTIONS[sColourOption] .. "'.")
    -- Have to use call plugin for this, as trigger data isn't plugin-specific in right-click menus for some reason!
    CallPlugin ("bfe35205f026786ea1d56e3b", "TriggersRecolour", "", "")
  else
    ColourNote(sUSER_OPTIONS[sColourOption], "", sRMBResult .. " sample A:  Colour unchanged from '" .. sUSER_OPTIONS[sColourOption] .. "'.")
    ColourNote(sUSER_OPTIONS[sColourOption], "", sRMBResult .. " sample B:  Colour unchanged from '" .. sUSER_OPTIONS[sColourOption] .. "'.")
  end
end
function FetchVitalsColour(iCurrentColour, sOptionName)
  iNewColour = PickColour(iCurrentColour)
  if (iNewColour ~= -1) then
    sUSER_OPTIONS[sOptionName] = iNewColour
    assert(dbUserData:execute("UPDATE user_options SET option_value=" .. sUSER_OPTIONS[sOptionName] .. " WHERE option_id='" .. sOptionName .. "'"))
    -- Re-cache the new values
    for iN = 0, 100 do
      iPercToColour["hp"][iN] = PercentageToColour(iN, sUSER_OPTIONS["vitals_hp_a"], sUSER_OPTIONS["vitals_hp_b"], sUSER_OPTIONS["vitals_hp_c"])
      iPercToColour["gp"][iN] = PercentageToColour(iN, sUSER_OPTIONS["vitals_gp_a"], sUSER_OPTIONS["vitals_gp_b"], sUSER_OPTIONS["vitals_gp_c"])
      iPercToColour["b"][iN] = PercentageToColour(iN, sUSER_OPTIONS["vitals_b_a"], sUSER_OPTIONS["vitals_b_b"], sUSER_OPTIONS["vitals_b_c"])
    end
    -- Redraw the vitals properly
    bForceVitalsUpdate = true
    CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawVitalsWindow", "", "")
    Repaint()
  end
end

function FetchMapColour()
  iNewColour = PickColour(iMapDotColour)
  if (iNewColour ~= -1) then
    iMapDotColour = iNewColour
    -- Redraw the map properly
    CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawMap", "", "")
    Repaint()
  end
end
function FetchHotspotColour(iHotspotID)
  if (sHotspotData[iHotspotID] ~= nil) then
    iNewColour = PickColour(sHotspotData[iHotspotID]["colour"])
    if (iNewColour ~= -1 and sHotspotData[iHotspotID] ~= nil) then
      sHotspotData[iHotspotID]["colour"] = iNewColour
      assert(dbUserData:execute("UPDATE user_hotspots SET colour=" .. tonumber(iNewColour) .. " WHERE hotspot_id=" .. iHotspotID))
      RedrawHotspotsWindow()
      ColourTell(sCOLOUR.silver, "", "The colour for hotspot '")
      ColourTell(RGBColourToName(iNewColour), "", sHotspotData[iHotspotID]["hotspot_name"])
      ColourNote(sCOLOUR.silver, "", "' has been updated.")
      -- Redraw the hotspots properly
      CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawHotspotsWindow", "", "")
      Repaint()
    end
  end
end

-- MiniWindow variables
movewindow = {}  -- table to hold functions like movewindow.install
-- make a mouse-down handler with the movement information as an upvalue
local function make_mousedown_handler (mwi)
  return function (flags, hotspot_id)
    local win = mwi.win
    -- Double click comms window
    if (bit.band (flags, 0x40) ~= 0 and win == "bfe35205f026786ea1d56e3bcomms") then
      CallPlugin ("bfe35205f026786ea1d56e3b", "QuowCommsDoubleclick")
    end
    -- No resizing for locked windows
    if (WINDATA[win]["LOCKED"] == true) then
      return
    end
    -- find where mouse is so we can adjust window relative to mouse
    mwi.startx = WindowInfo (win, 14)
    mwi.starty = WindowInfo (win, 15)
    -- find where window is in case we drag it offscreen
    mwi.origx = WindowInfo (win, 10) 
  end
end -- make_mousedown_handler

-- make a mouse drag-move handler with the movement information as an upvalue
local function make_dragmove_handler (mwi)
  return function (flags, hotspot_id)
    local win = mwi.win
    -- No resizing for locked windows, or for right-mouse
    if (WINDATA[win]["LOCKED"] == true or bit.band(flags, miniwin.hotspot_got_rh_mouse) ~= 0) then
      return
    end
    -- find where it is now
    local posx, posy = WindowInfo(win, 17) - mwi.startx, WindowInfo(win, 18) - mwi.starty
    -- change the mouse cursor shape appropriately
    if posx < 0 or 
       posx > GetInfo (281) - mwi.margin or
       posy < 0 or   -- don't drag title out of view
       posy > GetInfo (280) - mwi.margin then
      SetCursor (miniwin.cursor_x)
    else
      SetCursor (miniwin.cursor_hand)
    end -- if
    if posx < 0 then
      posx = 0
    elseif posx > GetInfo (281) - mwi.margin then
      posx = GetInfo(281) - mwi.margin
    end
    if posy < 0 then
      posy = 0
    elseif posy > GetInfo(280) - mwi.margin then
      posy = GetInfo(280) - mwi.margin
    end
    -- move the window to the new location - offset by how far mouse was into window if different
    if (posx ~= mwi.window_left or posy ~= mwi.window_top) then
      WindowPosition(win, posx, posy, 0, miniwin.create_absolute_location);
      mwi.window_left = posx
      mwi.window_top = posy
      mwi.window_mode = 0
      mwi.window_flags = miniwin.create_absolute_location
      iThemeLayoutLocked = 0
    end
  end -- dragmove
end -- make_dragmove_handler

-- make a mouse position-checking function with the movement information as an upvalue
local function make_check_map_position_handler (mwi)
  return function ()
    local win = mwi.win
    if not WindowInfo (win, 1) then
      ColourNote ("white", "red", "Error in make_check_map_position_handler: no window named: " .. win)
      return
    end -- no such window
     -- check miniwindow visible
      if mwi.window_left < 0 or 
         mwi.window_left > GetInfo (281) - mwi.margin or
         mwi.window_top < 0 or -- don't drag title out of view
         mwi.window_top > GetInfo (280) - mwi.margin then
           mwi.window_left, mwi.window_top = 0, 0  -- reset to center right
           mwi.window_mode = miniwin.pos_center_right
           mwi.window_flags = 0
      end -- if not visible
      WindowPosition (win, mwi.window_left, mwi.window_top, mwi.window_mode, mwi.window_flags)
  end -- check_map_position
end -- make_check_map_position_handler

function movewindow.install (win, default_position, default_flags, nocheck, start_position)
  default_position = default_position or miniwin.pos_center_right -- on right, center top/bottom
  default_flags = default_flags or 0
  -- set up handlers and where window should be shown (from saved state, if any)
  local movewindow_info = {
     win = win,   -- save window ID
     -- save current position in table (obtained from state file)
     window_left  = tonumber(GetSQLVariable("mw_" .. win .. "_windowx")) or (start_position and start_position.x) or 0,
     window_top   = tonumber(GetSQLVariable("mw_" .. win .. "_windowy")) or (start_position and start_position.y) or 0,     
     window_mode  = tonumber(GetSQLVariable("mw_" .. win .. "_windowmode")) or default_position,
     window_flags = tonumber(GetSQLVariable("mw_" .. win .. "_windowflags")) or default_flags,
     margin = 20,  -- how close we can put to the edge of the window
    }
    -- handler to reposition window
    movewindow_info.check_map_position = make_check_map_position_handler (movewindow_info)  -- for startup
    -- mouse handlers
    movewindow_info.mousedown       = make_mousedown_handler   (movewindow_info)  
    movewindow_info.mouseup         = ""
    movewindow_info.mouseover       = ""
    movewindow_info.cancelmouseover = ""
    movewindow_info.cancelmousedown = ""
    movewindow_info.dragmove        = make_dragmove_handler    (movewindow_info)
    movewindow_info.dragrelease     = ""
  -- save table in global namespace
  _G ["mw_" .. win .. "_movewindow_info"] = movewindow_info
  -- give main world window time to stabilize its size and position                
  -- eg. this might be:  mw_23c3c91af0a26790c625f5d1_movewindow_info.check_map_position ()
  if not nocheck then  -- if wanted
    DoAfterSpecial (5, "mw_" .. win .. "_movewindow_info.check_map_position ()" , sendto.script)
  end -- if
  return movewindow_info  -- the caller might appreciate access to this table
end -- movewindow.install

-- call movewindow.add_drag_handler after creating the window, and after deleting hotspots where applicable
--   to add a drag hotspot
function movewindow.add_drag_handler (win, left, top, right, bottom, cursor)
  win = win or GetPluginID ()  -- default to current plugin ID
  -- the zz puts it under other hotspots on the drag area
  local hotspot_id = "zz_mw_" .. win .. "_movewindow_hotspot"
  if not WindowInfo (win, 1) then
    ColourNote ("white", "red", "Error in movewindow.add_drag_handler: no window named: " .. win)
    return
  end -- no such window
  -- make a hotspot
  WindowAddHotspot(win, hotspot_id,  
                   left or 0, top or 0, right or 0, bottom or 0,        -- rectangle
                   "mw_" .. win .. "_movewindow_info.mouseover",        -- MouseOver
                   "mw_" .. win .. "_movewindow_info.cancelmouseover",  -- CancelMouseOver
                   "mw_" .. win .. "_movewindow_info.mousedown",        -- MouseDown
                   "mw_" .. win .. "_movewindow_info.cancelmousedown",  -- CancelMouseDown
                   "mw_" .. win .. "_movewindow_info.mouseup",          -- MouseUp
                   "",  -- tooltip text
                   cursor or miniwin.cursor_hand, -- cursor
                   0)  -- flags
  WindowDragHandler (win, hotspot_id, 
                     "mw_" .. win .. "_movewindow_info.dragmove", 
                     "mw_" .. win .. "_movewindow_info.dragrelease", 
                     0)   -- flags
end --  movewindow.add_drag_handler

-- For manual save-stating of a specific window (should be unused)
function movewindow.save_state (win)
  -- Get actual miniwindow handle from global namespace
  local mwi = _G ["mw_" .. win .. "_movewindow_info"]
  if not mwi then
    ColourNote ("white", "red", "Error in movewindow.save_state: no window movement info for: " .. win)
    return
  end -- no such window
  -- Save where the window was 
  local sSaveSQL = "INSERT OR REPLACE INTO core_options (option_id, option_value) VALUES "
  sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. win .. "_windowx") .. "', '" .. EscapeSQL(mwi.window_left) .. "'),"
  sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. win .. "_windowy") .. "', '" .. EscapeSQL(mwi.window_top) .. "'),"
  sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. win .. "_windowmode") .. "', '" .. EscapeSQL(mwi.window_mode) .. "'),"
  sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. win .. "_windowflags") .. "', '" .. EscapeSQL(mwi.window_flags) .. "'),"
  if WindowInfo (win, 10) then
    sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. win .. "_windowx") .. "', '" .. EscapeSQL(WindowInfo(win, 10)) .. "'),"
  end
  if WindowInfo (win, 11) then
    sSaveSQL = sSaveSQL .. "('" .. EscapeSQL("mw_" .. win .. "_windowy") .. "', '" .. EscapeSQL(WindowInfo(win, 11)) .. "'),"
  end
  sSaveSQL = string.sub(sSaveSQL, 0, -2)
  assert(dbUserData:execute(sSaveSQL))
end -- Custom movewindow.save_state  

-- Replacement for WindowRectOp action 5, which allows for a 3D look while maintaining color winThemeData
function DrawThemed3DRect(winThisWindow, left, top, right, bottom)
  right = right + 1
  WindowRectOp(winThisWindow, miniwin.rect_fill, left, top, right, bottom, winThemeData.FACE)
  WindowLine(winThisWindow, left, top, right, top, winThemeData.HIGHLIGHT, miniwin.pen_solid + miniwin.pen_endcap_flat, 1)
  WindowLine(winThisWindow, left, top, left, bottom, winThemeData.HIGHLIGHT, miniwin.pen_solid + miniwin.pen_endcap_flat, 1)
  WindowLine(winThisWindow, left, bottom-2, right, bottom-2, winThemeData.INNERSHADOW, miniwin.pen_solid + miniwin.pen_endcap_flat, 1)
  WindowLine(winThisWindow, right-2, top, right-2, bottom-2, winThemeData.INNERSHADOW, miniwin.pen_solid + miniwin.pen_endcap_flat, 1)
  WindowLine(winThisWindow, left, bottom-1, right, bottom-1, winThemeData.OUTERSHADOW, miniwin.pen_solid + miniwin.pen_endcap_flat, 1)
  WindowLine(winThisWindow, right-1, top, right-1, bottom-1, winThemeData.OUTERSHADOW, miniwin.pen_solid + miniwin.pen_endcap_flat, 1)    
end

-- Intercept for the movewindow mouseup handle, replace with my own function
function MakeMouseupHandler(winAssignedWindow)
  return function (flags, hotspot_id)
    ReorderWindows(winAssignedWindow)
    if (bit.band(flags, miniwin.hotspot_got_rh_mouse) ~= 0) then
      -- Right click bring up menu - build the custom menu here
      -- ! : return numeric result (only in first position of entire string)
      -- - : separator line
      -- ^ : grayed-out item
      -- + : checked (ticked) item
      -- > : start of nested menu (rest of line is nested menu title)
      -- < : end of nested menu (rest of line is ignored)
      local sMenuString = ""

      -- XP window
      if (winAssignedWindow == winXP) then
        sMenuString = "^XP Window Options:|-|"
      elseif (winAssignedWindow == winMinimap) then
        sMenuString = "^Minimap UI Controls:|-|"
      elseif (winAssignedWindow == winBars) then
        sMenuString = "^Character Vitals Options:|-|"
      elseif (winAssignedWindow == winStats) then
        sMenuString = "^Combat Stats Options:|-|"
      elseif (winAssignedWindow == winMDT) then
        sMenuString = "^Written-Map Options:|-|"
      elseif (winAssignedWindow == winShields) then
        sMenuString = "^Group and Shields Options:|-|"
      elseif (winAssignedWindow == winComms) then
        sMenuString = "^Comms Options:|-|"
      elseif (winAssignedWindow == winAscii) then
        sMenuString = "^Ascii-Map Options:|-|"
      elseif (winAssignedWindow == winHotspots) then
        sMenuString = "^Hotspots Options:|-|"
      end
      -- XP window
      if (winAssignedWindow == winXP) then
        if (WINDATA[winXP]["LOCKED"] == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Lock XP Window Position|"
        sMenuString = sMenuString .. "Hide XP Window|"
      elseif (winAssignedWindow == winMinimap) then
        if (WINDATA[winMinimap]["LOCKED"] == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Lock Minimap Window Position|"
        sMenuString = sMenuString .. "Hide Minimap Window|-|"
      -- Character vitals bars window
      elseif (winAssignedWindow == winBars) then
        if (WINDATA[winBars]["LOCKED"] == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Lock Vitals Window Position|"
        sMenuString = sMenuString .. "Hide Vitals Window|"
      -- Combat stats window menu options
      elseif (winAssignedWindow == winStats) then
        if (WINDATA[winStats]["LOCKED"] == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Lock Combat Stats Window Position|"
        sMenuString = sMenuString .. "Hide Combat Stats Window|"
      -- MDT window menu options
      elseif (winAssignedWindow == winMDT) then
        if (WINDATA[winMDT]["LOCKED"] == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Lock Written Map Window Position|"
        sMenuString = sMenuString .. "Hide Written Map Window|"
      -- Shields window menu options
      elseif (winAssignedWindow == winShields) then
        if (WINDATA[winShields]["LOCKED"] == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Lock Shields Window Position|"
        sMenuString = sMenuString .. "Hide Shields Window|"
      -- Comms window menu options
      elseif (winAssignedWindow == winComms) then
        if (WINDATA[winComms]["LOCKED"] == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Lock Comms Window Position|"
        sMenuString = sMenuString .. "Hide Comms Window|"
      elseif (winAssignedWindow == winAscii) then
        if (WINDATA[winAscii]["LOCKED"] == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Lock Ascii-Map Window Position|"
        sMenuString = sMenuString .. "Hide Ascii-Map Window|"
      elseif (winAssignedWindow == winHotspots) then
        if (WINDATA[winHotspots]["LOCKED"] == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Lock Hotspots Window Position|"
        sMenuString = sMenuString .. "Hide Hotspots Window|"
      end
      --[[ Disabling menus for Screen Margins... in non master-window

      sMenuString = sMenuString .. ">Screen Margins...|"
      if (bLockMargins == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Lock Screen Margins|-|"
      if (SCREENMARGINS["left"][1] == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Left Edge Margin|"
      if (SCREENMARGINS["top"][1] == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Top Edge Margin|"
      if (SCREENMARGINS["right"][1] == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Right Edge Margin|"
      if (SCREENMARGINS["bottom"][1] == true) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Bottom Edge Margin|"
      sMenuString = sMenuString .. "<|"
      --]]
      -- Instant layouts
      sMenuString = sMenuString .. ">Instant Layouts...|"
      sMenuString = sMenuString .. "^Auto-Configure Full Layout:|-|"
      if (iThemeLayoutLocked == 11) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Simple Cow|-|"
      if (iThemeLayoutLocked == 2) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Cow-Bar Classic Left|"
      if (iThemeLayoutLocked == 3) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Cow-Bar Classic Right|"
      if (iThemeLayoutLocked == 1) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Cow-Bar Classic Top|"
      if (iThemeLayoutLocked == 4) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Cow-Bar Classic Bottom|"
      sMenuString = sMenuString .. "-|"
      if (iThemeLayoutLocked == 8) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Semi-Skimmed Top|"
      if (iThemeLayoutLocked == 9) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Semi-Skimmed Bottom|"
      sMenuString = sMenuString .. "-|"
      if (iThemeLayoutLocked == 5) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Micro-Cow Miniatures|"
      if (iThemeLayoutLocked == 7) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Marginalised Cows|"
      if (iThemeLayoutLocked == 6) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Big-Cows Big-Windows|"
      sMenuString = sMenuString .. "-|"
      if (iThemeLayoutLocked == 12) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Side of Beef Left|"
      if (iThemeLayoutLocked == 13) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Side of Beef Right|"
      sMenuString = sMenuString .. "-|"
      if (iThemeLayoutLocked == 14) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Minimoolist|"


      sMenuString = sMenuString .. "-|"
      sMenuString = sMenuString .. "^Custom Layout|"
      if (iThemeLayoutLocked == 10) then
        sMenuString = sMenuString .. "+"
      end
      sMenuString = sMenuString .. "Load Custom Cows Layout|"
      sMenuString = sMenuString .. "-|"
      sMenuString = sMenuString .. "Save Custom Cows Layout|"
      sMenuString = sMenuString .. "-|"
      sMenuString = sMenuString .. "^Import/Export Layout|"
      sMenuString = sMenuString .. "Import Scaled Layout|"
      sMenuString = sMenuString .. "Export Scaled Layout|"
      sMenuString = sMenuString .. "<|"

      -- XP window
      if (winAssignedWindow == winXP) then
        sMenuString = sMenuString .. "-|^XP Window:|-|"
        sMenuString = sMenuString .. ">Change Font: " .. objWindowFonts[winXP]["body"] .. " (" .. tostring(objWindowFonts[winXP]["size"]) .. ")...|"
        sMenuString = sMenuString .. "^Change this window's font:|-|"
        sMenuString = sMenuString .. "Font: Pick Font-Type for XP|"
        sMenuString = sMenuString .. "Font: Pick Font-Size for XP|"
        sMenuString = sMenuString .. "Font: Restore Default for XP|<|-|"
        if (bShowXPNotifications == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show XP Gain Notification Texts|"
        sMenuString = sMenuString .. ">XP Notification Cutoff Value...|"
        if (iXPNotificationLimit == 9) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Limit 10+|"
        if (iXPNotificationLimit == 99) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Limit 100+|"
        if (iXPNotificationLimit == 499) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Limit 500+|"
        if (iXPNotificationLimit == 999) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Limit 1000+|"
        if (iXPNotificationLimit == 4999) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Limit 5000+|"
        sMenuString = sMenuString .. "<|-|"

        -- Auto scaling graph or not
        sMenuString = sMenuString .. ">XP Graph Scaling...|"
        if (iXPGraphScaling == 0) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Scaling Auto|"
        if (iXPGraphScaling == 100000) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Scaling Fixed 100k|"
        if (iXPGraphScaling == 200000) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Scaling Fixed 200k|"
        if (iXPGraphScaling == 500000) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Scaling Fixed 500k|"
        if (iXPGraphScaling == 800000) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Scaling Fixed 800k|"
        if (iXPGraphScaling == 1000000) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Scaling Fixed 1m|"
        if (iXPGraphScaling == 2000000) then sMenuString = sMenuString .. "+" end
        sMenuString = sMenuString .. "XP Scaling Fixed 2m|"
        sMenuString = sMenuString .. "<|-|"

        sMenuString = sMenuString .. "Reset XP Rate|-|"
        if (iTotalGroupMembers == 0) then sMenuString = sMenuString .. "^" end
        sMenuString = sMenuString .. "Group Say XP Rate|"
        sMenuString = sMenuString .. "Show XP Report|"

      elseif (winAssignedWindow == winMinimap) then
        sMenuString = sMenuString .. "^Right click the main minimap area for full options|"

      -- Character vitals bars window
      elseif (winAssignedWindow == winBars) then
        sMenuString = sMenuString .. "-|^Vitals Window:|-|"
        sMenuString = sMenuString .. ">Change Font: " .. objWindowFonts[winBars]["body"] .. " (" .. tostring(objWindowFonts[winBars]["size"]) .. ")...|"
        sMenuString = sMenuString .. "^Change this window's font:|-|"
        sMenuString = sMenuString .. "Font: Pick Font-Type for Vitals|"
        sMenuString = sMenuString .. "Font: Pick Font-Size for Vitals|"
        sMenuString = sMenuString .. "Font: Restore Default for Vitals|<|-|"

        sMenuString = sMenuString .. ">Colour Vitals Bars...|"
        sMenuString = sMenuString .. "Colour: Reset Vitals Bars|-|"
        sMenuString = sMenuString .. "Colour: HP Full Colour|"
        sMenuString = sMenuString .. "Colour: HP Half Colour|"
        sMenuString = sMenuString .. "Colour: HP Low Colour|"
        sMenuString = sMenuString .. "-|"
        sMenuString = sMenuString .. "Colour: GP Full Colour|"
        sMenuString = sMenuString .. "Colour: GP Half Colour|"
        sMenuString = sMenuString .. "Colour: GP Low Colour|"
        sMenuString = sMenuString .. "-|"
        sMenuString = sMenuString .. "Colour: Burden Empty Colour|"
        sMenuString = sMenuString .. "Colour: Burden Half Colour|"
        sMenuString = sMenuString .. "Colour: Burden Heavy Colour|"
        sMenuString = sMenuString .. "<|-|"


        sMenuString = sMenuString .. "Switch Stat Set|-|"
        sMenuString = sMenuString .. "Create New Stat Set|"
        sMenuString = sMenuString .. "Delete Current Stat Set|"
        sMenuString = sMenuString .. "Reset Current Set Stats|"
        sMenuString = sMenuString .. "Rename Current Set|"
        sMenuString = sMenuString .. ">GP Regeneration For This Set...|"
        for iN = 0, 4 do
          if (iQuowCombatStats[iCurrentCombatStatSet]["gp_regen"] == iN) then
            sMenuString = sMenuString .. "+"
          end
          sMenuString = sMenuString .. "GP Regen " .. iN .. "|"
        end
        sMenuString = sMenuString .. "<|-|>HP Low Notification...|"
        if (bPlayHPNotification == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Play Sound On Low HP|-|"
        sMenuString = sMenuString .. "Choose HP Low Wav File Sound|"
        sMenuString = sMenuString .. "<|-|>GP Full Notification...|"
        if (bPlayGPNotification == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Play Sound On Full GP|-|"
        sMenuString = sMenuString .. "Choose GP Full Wav File Sound|"
        sMenuString = sMenuString .. "<|-|"
        if (bShowAlignment == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show Alignment|"
        if (bShowHPNotifications == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show HP Loss Notification Texts|"
        if (bShowGPNotifications == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show GP Loss Notification Texts|"
        if (bVitalsGradients == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Vitals Bar Gradients|" 

        sMenuString = sMenuString .. "-|>Bar Layout:|"
        if (iVitalsFormat == 0) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Standard Vertical Bars|" 
        if (iVitalsFormat == 1) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Standard Horizontal Bars|" 
        if (iVitalsFormat == 2) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Downwards Bars|" 
        if (iVitalsFormat == 3) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Upwards Bars|<|" 



      -- Written-Map MDT Map Door Text window menu MDT menu
      elseif (winAssignedWindow == winMDT) then
        sMenuString = sMenuString .. "-|"
        sMenuString = sMenuString .. ">Change Font: " .. objWindowFonts[winMDT]["body"] .. " (" .. tostring(objWindowFonts[winMDT]["size"]) .. ")...|"
        sMenuString = sMenuString .. "^Change this window's font:|-|"
        sMenuString = sMenuString .. "Font: Pick Font-Type for Written-Map|"
        sMenuString = sMenuString .. "Font: Pick Font-Size for Written-Map|"
        sMenuString = sMenuString .. "Font: Restore Default for Written-Map|<|-|"
        if (bMDTParsingEnabled == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Enable Written-Map Parsing|"

        if (bMDTShowEmptyRoomCount == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show Zero-Score Room Counts|"
        if (bMDTReverseSortOrder == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Reverse 'map door text' Ordering|"
        if (bMDTForceWordWrap == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Force Window Word-Wrapping|-|"
        sMenuString = sMenuString .. "Change Minimum Score Visibility (" .. tostring(iMDTMinimumScore) .. ")|"
        sMenuString = sMenuString .. "Change Default Entity Score (" .. tostring(iMDTDefaultValue) .. ")|-|"
        sMenuString = sMenuString .. "Restore Default Filters|-|"
        sMenuString = sMenuString .. "Add New MDT Filter|"
        sMenuString = sMenuString .. ">Modify MDT Filter...|"
        sMenuString = sMenuString .. "Change MDT Trigger|"
        sMenuString = sMenuString .. "Change MDT Score|"
        sMenuString = sMenuString .. "Change MDT Colour|"
        sMenuString = sMenuString .. "Change MDT Category|"
        sMenuString = sMenuString .. "Change MDT Map Region|"
        sMenuString = sMenuString .. "<|"
        sMenuString = sMenuString .. "Delete MDT Filter|-|"
        sMenuString = sMenuString .. ">MDT Categories...|"

        sMenuString = sMenuString .. "^Enable/Disable MDT Categories:|-|"
        for sCatKey, sCatData in pairs(sMDTCategories) do
          if (sCatData[1] == true) then
            sMenuString = sMenuString .. "+"
          end
          sMenuString = sMenuString .. "Show MDT Category: " .. sCatKey .. "|"
        end
        sMenuString = sMenuString .. "-|^Manage MDT Categories:|-|"
        sMenuString = sMenuString .. "Add New MDT Category|"
        sMenuString = sMenuString .. "Rename MDT Category|"
        sMenuString = sMenuString .. "Delete MDT Category|"
        sMenuString = sMenuString .. "<|"

      -- Hotspots window
      elseif (winAssignedWindow == winHotspots) then
        sMenuString = sMenuString .. "-|>Change Font: " .. objWindowFonts[winHotspots]["body"] .. " (" .. tostring(objWindowFonts[winHotspots]["size"]) .. ")...|"
        sMenuString = sMenuString .. "^Change this window's font:|-|"
        sMenuString = sMenuString .. "Font: Pick Font-Type for Hotspots|"
        sMenuString = sMenuString .. "Font: Pick Font-Size for Hotspots|"
        sMenuString = sMenuString .. "Font: Restore Default for Hotspots|<|-|"
        if (bHotspotsPrioritiseRedraw == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Prioritise Timer Screen Updates|"
        if (bHotspotsChatWindow == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show Notifications in Comms Window|-|"
        sMenuString = sMenuString .. "Export Hotspots to Clipboard|"
        sMenuString = sMenuString .. "Import Hotspots|-|"
        sMenuString = sMenuString .. "Add New Hotspot|"
        sMenuString = sMenuString .. "Modify Hotspot|"
        sMenuString = sMenuString .. "Delete Hotspot|"
        sMenuString = sMenuString .. "Change Hotspot Colour|"
        sMenuString = sMenuString .. "Reset Hotspot Timer|-|"
        sMenuString = sMenuString .. "Output Hotspots To Screen|-|"
        sMenuString = sMenuString .. "Group Sync Timer Share|"

      -- Ascii-Map window
      elseif (winAssignedWindow == winAscii) then
        sMenuString = sMenuString .. "-|>Change Font: " .. objWindowFonts[winAscii]["body"] .. " (" .. tostring(objWindowFonts[winAscii]["size"]) .. ")...|"
        sMenuString = sMenuString .. "^Change this window's font:|-|"
        sMenuString = sMenuString .. "Font: Pick Font-Type for Ascii-Map|"
        sMenuString = sMenuString .. "Font: Pick Font-Size for Ascii-Map|"
        sMenuString = sMenuString .. "Font: Restore Default for Ascii-Map|<|-|"
        if (bAutoShowHideAscii == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Auto-Hide-Show Ascii map with terrains|"
        if (bAsciiMapOmitted == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Omit Ascii map from MUD output|"

      -- Comms window
      elseif (winAssignedWindow == winComms) then
        sMenuString = sMenuString .. "-|"
        sMenuString = sMenuString .. ">Change Font: " .. objWindowFonts[winComms]["body"] .. " (" .. tostring(objWindowFonts[winComms]["size"]) .. ")...|"
        sMenuString = sMenuString .. "^Change this window's font:|-|"
        sMenuString = sMenuString .. "Font: Pick Font-Type for Comms|"
        sMenuString = sMenuString .. "Font: Pick Font-Size for Comms|"
        sMenuString = sMenuString .. "Font: Restore Default for Comms|<|-|"

        sMenuString = sMenuString .. "Record New Talker/Club Channel|"
        sMenuString = sMenuString .. "Stop Recording Talker/Club Channel|-|"
        if (bShowCommsTabs == true) then
          sMenuString = sMenuString .. "+"
        end


        sMenuString = sMenuString .. "Show Chat Tabs|"
        sMenuString = sMenuString .. "Add New Custom Tab|"
        -- Move chat tab left or right
        if (bShowCommsTabs == true) then
          if (WindowInfo(winComms, 15) < 30) then
            local iChatTabWidths = math.floor((WINDATA[winComms]["WIDTH"] - 8) / #objChatTabs)
            if (iChatTabWidths < 30) then
              iChatTabWidths = 30
            end
            local iClickedChatTab = math.ceil(WindowInfo(winComms, 14) / iChatTabWidths)
            if (objChatTabs[iClickedChatTab] and objChatTabs[iClickedChatTab][2]) then
              sMenuString = sMenuString .. "-|"
              if (iClickedChatTab > 1) then
                sMenuString = sMenuString .."Move Clicked Tab " .. iClickedChatTab .. " Left|"
              end
              if (iClickedChatTab < #objChatTabs) then
                sMenuString = sMenuString .."Move Clicked Tab " .. iClickedChatTab .. " Right|"
              end
              sMenuString = sMenuString .. "-|"
            end
          end
        end
        -- Modify chat tab
        sMenuString = sMenuString .. ">Modify Chat Tab...|"
        for iN = 1, #objChatTabs do
          sMenuString = sMenuString .. "Modify Chat Tab " .. iN .. ": " .. objChatTabs[iN][1] .. "|"
        end
        sMenuString = sMenuString .. "<|>Delete Chat Tab...|"
        if (#objChatTabs > 1) then
          for iN = 1, #objChatTabs do
            sMenuString = sMenuString .. "Delete Chat Tab " .. iN .. ": " .. objChatTabs[iN][1] .. "|"
          end
        else
          sMenuString = sMenuString .. "^Cannot delete final chat tab|^Create a new tab first|"
        end
        sMenuString = sMenuString .. "<|-|>Echo Channels to Main Output...|"
        sMenuString = sMenuString .. "^Ticked options are ECHOED/SHOWN in MUD output|-|"
        if (objChatFilters["Group_Say"][3] == false) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Echo Main Output: Group Say|"
        for sKey, sData in pairs(objChatFilters) do
          if (sKey ~= "Tells_In" and sKey ~= "Tells_Out" and sKey ~= "Group_Say") then
            if (sData[3] == false) then
              sMenuString = sMenuString .. "+"
            end
            sMenuString = sMenuString .. "Echo Main Output: " .. sKey .. "|"
          end
        end
        sMenuString = sMenuString .. "<|-|Copy All Messages To Clipboard|"
        sMenuString = sMenuString .. "Copy Selected Line To Clipboard|"

      -- Shields window
      elseif (winAssignedWindow == winShields) then
        sMenuString = sMenuString .. "-|>Change Font: " .. objWindowFonts[winShields]["body"] .. " (" .. tostring(objWindowFonts[winShields]["size"]) .. ")...|"
        sMenuString = sMenuString .. "^Change this window's font:|-|"
        sMenuString = sMenuString .. "Font: Pick Font-Type for Shields|"
        sMenuString = sMenuString .. "Font: Pick Font-Size for Shields|"
        sMenuString = sMenuString .. "Font: Restore Default for Shields|<|-|"

        sMenuString = sMenuString .. ">Shield Event Alerts...|"
        for _, sCatType in ipairs(sShieldCatTypes) do
          sMenuString = sMenuString .. ">" .. string.gsub(sCatType, "%f[%a].", string.upper) .. " shield breaks...|"
          sMenuString = sMenuString .. "^TICKED options are ENABLED|-|"
          for __ , sSubType in ipairs(sShieldSubTypes) do
            local sThisShield = string.gsub(sCatType, "%f[%a].", string.upper) .. " " .. string.upper(sSubType)
            if (bSoundPlayShields[sCatType .. "_" .. sSubType] == true) then
              sMenuString = sMenuString .. "+"
            end
            sMenuString = sMenuString .. "ENABLE Sound - " .. sThisShield .. "|"
            sMenuString = sMenuString .. "CHOOSE Sound - " .. sThisShield .. "|"
            if (sUSER_OPTIONS["nocol_" .. sCatType .. "_" .. sSubType] == "17") then
              sMenuString = sMenuString .. "+"
            end
            sMenuString = sMenuString .. "ENABLE Colour - " .. sThisShield .. "|"
            sMenuString = sMenuString .. "CHOOSE Colour - " .. sThisShield .. "|-|"
          end
          sMenuString = sMenuString .. "<|"
        end
        sMenuString = sMenuString .. "-|"
        if (bSelfShieldChats == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Self Shield Chat Alerts|"
        if (bGroupShieldChats == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Group Shield Chat Alerts|"
        sMenuString = sMenuString .. "<|-|"

        if (bSoloShieldsWindow == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Self-Solo Shields Only|-|"

        if (iTotalGroupMembers == 0) then sMenuString = sMenuString .. "^" end
        sMenuString = sMenuString .. "Group Say Group Kills Report|"
        if (iTotalGroupMembers == 0) then sMenuString = sMenuString .. "^" end
        sMenuString = sMenuString .. "Show Private Group Kills Report|"
        sMenuString = sMenuString .. "-|"
        sMenuString = sMenuString .. "Refresh Solo Character Shields|"
        sMenuString = sMenuString .. "-|"
        sMenuString = sMenuString .. "Refresh Group Status and Shields|"

      -- Combat stats window menu options
      elseif (winAssignedWindow == winStats) then
        sMenuString = sMenuString .. "-|>Change Font: " .. objWindowFonts[winStats]["body"] .. " (" .. tostring(objWindowFonts[winStats]["size"]) .. ")...|"
        sMenuString = sMenuString .. "^Change this window's font:|-|"
        sMenuString = sMenuString .. "Font: Pick Font-Type for Combat-Stats|"
        sMenuString = sMenuString .. "Font: Pick Font-Size for Combat-Stats|"
        sMenuString = sMenuString .. "Font: Restore Default for Combat-Stats|<|-|"

        sMenuString = sMenuString .. ">Re-Colour MUD Combat Texts...|"
        sMenuString = sMenuString .. "^TICKED Messages Are Re-Coloured By Plugin:|-|"
        sMenuString = sMenuString .. "Re-Colour DISABLE all|Re-Colour ENABLE all|-|"
        if (sUSER_OPTIONS["nocol_special_prep"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: You prepare a special|"
        if (sUSER_OPTIONS["nocol_special_fail"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: You fail to prepare a special|"
        sMenuString = sMenuString .. "-|"
        if (sUSER_OPTIONS["nocol_special_out_fail"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: You special enemy but they defend|"
        if (sUSER_OPTIONS["nocol_special_out_success"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: You special and hurt enemy|"
        if (sUSER_OPTIONS["nocol_melee_out_fail"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: You hit enemy but they defend|"
        if (sUSER_OPTIONS["nocol_melee_out_success"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: You hit and hurt enemy|"
        if (sUSER_OPTIONS["nocol_melee_out_kill"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: You kill enemy|"
        sMenuString = sMenuString .. "-|"
        if (sUSER_OPTIONS["nocol_special_inc_fail"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: Enemy specials you but you defend|"
        if (sUSER_OPTIONS["nocol_special_inc_success"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: Enemy specials and hurts you|"
        if (sUSER_OPTIONS["nocol_melee_inc_fail"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: Enemy hits you but you defend|"
        if (sUSER_OPTIONS["nocol_melee_inc_success"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: Enemy hits and hurts you|"
        if (sUSER_OPTIONS["nocol_melee_inc_kill"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: Enemy kills you|"
        sMenuString = sMenuString .. "-|"
        if (sUSER_OPTIONS["nocol_special_third_fail"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: Others special others who defend|"
        if (sUSER_OPTIONS["nocol_special_third_success"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: Others special and hurt others|"
        if (sUSER_OPTIONS["nocol_melee_third_fail"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: Others hit others who defend|"
        if (sUSER_OPTIONS["nocol_melee_third_success"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: Others hit and hurt others|"
        if (sUSER_OPTIONS["nocol_melee_third_kill"] == "17") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Re-Colour: Others kill others|"
        sMenuString = sMenuString .. "<|"

        sMenuString = sMenuString .. ">Change MUD Combat Text Colours...|"
        sMenuString = sMenuString .. "Show message samples in output|"
        sMenuString = sMenuString .. "-|"
        sMenuString = sMenuString .. "Pick Colour: You prepare a special|"
        sMenuString = sMenuString .. "Pick Colour: You fail to prepare a special|"
        sMenuString = sMenuString .. "-|"
        sMenuString = sMenuString .. "Pick Colour: You special enemy but they defend|"
        sMenuString = sMenuString .. "Pick Colour: You special and hurt enemy|"
        sMenuString = sMenuString .. "Pick Colour: You hit enemy but they defend|"
        sMenuString = sMenuString .. "Pick Colour: You hit and hurt enemy|"
        sMenuString = sMenuString .. "Pick Colour: You kill enemy|"
        sMenuString = sMenuString .. "-|"
        sMenuString = sMenuString .. "Pick Colour: Enemy specials you but you defend|"
        sMenuString = sMenuString .. "Pick Colour: Enemy specials and hurts you|"
        sMenuString = sMenuString .. "Pick Colour: Enemy hits you but you defend|"
        sMenuString = sMenuString .. "Pick Colour: Enemy hits and hurts you|"
        sMenuString = sMenuString .. "Pick Colour: Enemy kills you|"
        sMenuString = sMenuString .. "-|"
        sMenuString = sMenuString .. "Pick Colour: Others special others who defend|"
        sMenuString = sMenuString .. "Pick Colour: Others special and hurt others|"
        sMenuString = sMenuString .. "Pick Colour: Others hit others who defend|"
        sMenuString = sMenuString .. "Pick Colour: Others hit and hurt others|"
        sMenuString = sMenuString .. "Pick Colour: Others kill others|"
        sMenuString = sMenuString .. "<|"
        sMenuString = sMenuString .. ">Hide MUD Combat Texts...|"
        sMenuString = sMenuString .. "^UNTICK to HIDE message type|"
        sMenuString = sMenuString .. "SHOW all combat messages|HIDE all combat messages|-|"
        sMenuString = sMenuString .. "-|"

        if (sUSER_OPTIONS["omit_special_prep"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: You prepare a special|"
        if (sUSER_OPTIONS["omit_special_fail"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: You fail to prepare a special|"
        sMenuString = sMenuString .. "-|"
        if (sUSER_OPTIONS["omit_special_out_fail"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: You special enemy but they defend|"
        if (sUSER_OPTIONS["omit_special_out_success"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: You special and hurt enemy|"
        if (sUSER_OPTIONS["omit_melee_out_fail"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: You hit enemy but they defend|"
        if (sUSER_OPTIONS["omit_melee_out_success"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: You hit and hurt enemy|"
        if (sUSER_OPTIONS["omit_melee_out_kill"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: You kill enemy|"
        sMenuString = sMenuString .. "-|"
        if (sUSER_OPTIONS["omit_special_inc_fail"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: Enemy specials you but you defend|"
        if (sUSER_OPTIONS["omit_special_inc_success"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: Enemy specials and hurts you|"
        if (sUSER_OPTIONS["omit_melee_inc_fail"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: Enemy hits you but you defend|"
        if (sUSER_OPTIONS["omit_melee_inc_success"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: Enemy hits and hurts you|"
        if (sUSER_OPTIONS["omit_melee_inc_kill"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: Enemy kills you|"
        sMenuString = sMenuString .. "-|"
        if (sUSER_OPTIONS["omit_special_third_fail"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: Others special others who defend|"
        if (sUSER_OPTIONS["omit_special_third_success"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: Others special and hurt others|"
        if (sUSER_OPTIONS["omit_melee_third_fail"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: Others hit others who defend|"
        if (sUSER_OPTIONS["omit_melee_third_success"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: Others hit and hurt others|"
        if (sUSER_OPTIONS["omit_melee_third_kill"] == "n") then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Show: Others kill others|"
        sMenuString = sMenuString .. "<|-|"

        if (bOptimisedCombatTriggers == true) then
          sMenuString = sMenuString .. "+"
        end
        sMenuString = sMenuString .. "Optimize Plugin Combat Triggers|-|"
        sMenuString = sMenuString .. "Switch Stat Set|-|"
        sMenuString = sMenuString .. "Create New Stat Set|"
        sMenuString = sMenuString .. "Delete Current Stat Set|"
        sMenuString = sMenuString .. "Reset Current Set Stats|"
        sMenuString = sMenuString .. "Rename Current Set|"
        sMenuString = sMenuString .. ">GP Regeneration For This Set...|" 
        for iN = 0, 4 do
          if (iQuowCombatStats[iCurrentCombatStatSet]["gp_regen"] == iN) then
            sMenuString = sMenuString .. "+"
          end
          sMenuString = sMenuString .. "GP Regen " .. iN .. "|"
        end
        sMenuString = sMenuString .. "<|-|"
        sMenuString = sMenuString .. "Generate Full Stat Report|"
      end

      iCommLineClicked = WindowInfo(winAssignedWindow, 15)
      sRMBResult = WindowMenu (winAssignedWindow, WindowInfo(winAssignedWindow, 14), iCommLineClicked, sMenuString)
      if (sRMBResult ~= "") then

        local iNewColour
        local sColourOption

        if (sRMBResult == "Add New Custom Tab") then
          local sNewChatTabName = utils.inputbox("You can modify a tab's name on this screen, and in the next screen, pick what kind of messages are filtered to this tab.\n\nEnter a name for your new chat tab first.\n\nKeep it simple, and short, eg 'All', 'Tells', 'Priests', 'Clubs'.", "New Chat Tab Name", "", "", 12)
          if (sNewChatTabName ~= nil and sNewChatTabName ~= "") then
            local bUniqueChannel = true
            for iN = 1, #objChatTabs do
              if (objChatTabs[iN][1] == sNewChatTabName) then
                bUniqueChannel = false
                break
              end
            end
            if (bUniqueChannel == true) then
              local sTabChoices = {"*All*", "*All Talkers/Clubs*", "*Tells*", "*Group*"}
              for sKey, sData in pairs(objChatFilters) do
                if (sKey ~= "Tells_In" and sKey ~= "Tells_Out" and sKey ~= "Group_Say") then
                  table.insert(sTabChoices, sKey)
                end
              end
              local sTabSelected = utils.multilistbox ("Select comms channels to display for a new '" .. sNewChatTabName .. "' tab.\nCtrl-click and shift-click for multiple selections.\n\nMissing a talker/club channel?\n'Record New Talker/Club Channel' in the menu.\n", "Comms Channels:", sTabChoices, nil)
              if (sTabSelected ~= nil) then
                local sMyChatChoices = {}
                local bAllTalkers = false
                for sKey, sData in pairs(sTabSelected) do
                  if (sTabChoices[sKey] == "*All*") then
                    sMyChatChoices = {"*All*"}
                    break
                  elseif (sTabChoices[sKey] == "*All Talkers/Clubs*") then
                    table.insert(sMyChatChoices, "*Talkers*")
                    bAllTalkers = true
                  elseif (sTabChoices[sKey] == "*Tells*") then
                    table.insert(sMyChatChoices, "Tells_In")
                    table.insert(sMyChatChoices, "Tells_Out")
                  elseif (sTabChoices[sKey] == "*Group*") then
                    table.insert(sMyChatChoices, "Group_Say")
                  elseif (bAllTalkers == false) then
                    table.insert(sMyChatChoices, sTabChoices[sKey])
                  end
                end
                table.insert(objChatTabs, {sNewChatTabName, sMyChatChoices})
                RedrawCommsWindow()
                ColourNote(sCOLOUR.orange, "", "Added new custom comms window chat-tab named '" .. sNewChatTabName .. "'")
              else
                ColourNote(sCOLOUR.orange, "", "You did not select any comms channels to display, cancelling creation of new chat-tab.")
              end
            else
              ColourNote(sCOLOUR.orange, "", "A chat-tab already exists with the name '" .. sNewChatTabName .. "', you must delete the old one first before re-creating it.")
            end
          else
            ColourNote(sCOLOUR.orange, "", "You did not enter a chat-tab name, cancelling creation of new chat-tab.")
          end

        elseif (string.sub(sRMBResult, 1, 16) == "Modify Chat Tab ") then
          sRMBResult = string.sub(sRMBResult, 17)
          local iWhere = string.find(sRMBResult, ":")
          local iThisTab = tonumber(string.sub(sRMBResult, 1, iWhere - 1))
          sRMBResult = string.sub(sRMBResult, iWhere + 2)
          local sNewChatTabName = utils.inputbox("Enter a new name for the chat tab '" .. sRMBResult .. "'.\n\nKeep it simple, and short, eg 'All', 'Tells', 'Priests', 'Clubs'.", "Rename Chat Tab", sRMBResult, "", 12)
          if (sNewChatTabName ~= nil and sNewChatTabName ~= "") then
            local sTabChoices = {"*All*", "*All Talkers/Clubs*", "*Tells*", "*Group*"}
            local iMyChoices = {}
            for sKey, sData in pairs(objChatFilters) do
              if (sKey ~= "Tells_In" and sKey ~= "Tells_Out" and sKey ~= "Group_Say") then
                table.insert(sTabChoices, sKey)
              end
            end
            for sKey, sData in pairs(objChatTabs[iThisTab][2]) do
              if (sData == "*All*") then
                iMyChoices[1] = true
              elseif (sData == "*Talkers*") then
                iMyChoices[2] = true
              elseif (sData == "Tells_In" or sData == "Tells_Out") then
                iMyChoices[3] = true
              elseif (sData == "Group_Say") then
                iMyChoices[4] = true
              else
                for iTabKey, sTabData in ipairs(sTabChoices) do
                  if (sTabData == sData) then
                    iMyChoices[iTabKey] = true
                  end
                end
              end
            end
            local sTabSelected = utils.multilistbox ("Select comms channels to display for '" .. sRMBResult .. "' tab.\nCtrl-click and shift-click for multiple selections.\n\nMissing a talker/club channel?\n'Record New Talker/Club Channel' in the menu.\n", "Comms Channels:", sTabChoices, iMyChoices)
            if (sTabSelected ~= nil) then
              local sMyChatChoices = {}
              objChatTabs[iThisTab][2] = nil
              local bAllTalkers = false
              for sKey, sData in pairs(sTabSelected) do
                if (sTabChoices[sKey] == "*All*") then
                  sMyChatChoices = {"*All*"}
                  break
                elseif (sTabChoices[sKey] == "*All Talkers/Clubs*") then
                  table.insert(sMyChatChoices, "*Talkers*")
                  bAllTalkers = true
                elseif (sTabChoices[sKey] == "*Tells*") then
                  table.insert(sMyChatChoices, "Tells_In")
                  table.insert(sMyChatChoices, "Tells_Out")
                elseif (sTabChoices[sKey] == "*Group*") then
                  table.insert(sMyChatChoices, "Group_Say")
                elseif (bAllTalkers == false) then
                  table.insert(sMyChatChoices, sTabChoices[sKey])
                end
              end
              objChatTabs[iThisTab][1] = sNewChatTabName
              objChatTabs[iThisTab][2] = sMyChatChoices
              if (iThisTab == iCurrentChannelChoice) then
                ChangeChatChannel(iCurrentChannelChoice)
              end
              RedrawCommsWindow()
              ColourNote(sCOLOUR.orange, "", "Chat-tab '" .. sRMBResult .. "' has been updated and renamed to '" .. sNewChatTabName .. "'")
            else
              ColourNote(sCOLOUR.orange, "", "Cancelling modification of chat-tab '" .. sRMBResult .. "'")
            end
          else
            ColourNote(sCOLOUR.orange, "", "Cancelling modification of chat-tab '" .. sRMBResult .. "'")
          end

        -- Move a specific tab 
        elseif (string.sub(sRMBResult, 1, 17) == "Move Clicked Tab ") then
          sRMBResult = string.sub(sRMBResult, 18)
          local iWhere = string.find(sRMBResult, " ")
          local iMoveTab = tonumber(string.sub(sRMBResult, 1, iWhere - 1))
          local sMoveDirection = string.sub(sRMBResult, iWhere + 1)
          if (sMoveDirection == "Left") then
            if (iMoveTab > 1) then
              -- Record the current left tab
              local objTempTab = {}
              objTempTab[1] = objChatTabs[iMoveTab - 1][1]
              objTempTab[2] = {}
              for iTabKey, sTabData in pairs(objChatTabs[iMoveTab - 1][2]) do
                table.insert(objTempTab[2], sTabData)
              end
              -- Move the current tab into the left tab
              objChatTabs[iMoveTab - 1][1] = objChatTabs[iMoveTab][1]
              objChatTabs[iMoveTab - 1][2] = {}
              for iTabKey, sTabData in pairs(objChatTabs[iMoveTab][2]) do
                table.insert(objChatTabs[iMoveTab - 1][2], sTabData)
              end
              -- Move the recorded tab into the current tab
              objChatTabs[iMoveTab][1] = objTempTab[1]
              objChatTabs[iMoveTab][2] = {}
              for iTabKey, sTabData in pairs(objTempTab[2]) do
                table.insert(objChatTabs[iMoveTab][2], sTabData)
              end
            end
            if (iCurrentChannelChoice == iMoveTab) then
              ChangeChatChannel(iMoveTab - 1)
            elseif (iCurrentChannelChoice == (iMoveTab - 1)) then
              ChangeChatChannel(iMoveTab)
            end
          elseif (sMoveDirection == "Right") then
            if (iMoveTab < #objChatTabs) then
              -- Record the current right tab
              local objTempTab = {}
              objTempTab[1] = objChatTabs[iMoveTab + 1][1]
              objTempTab[2] = {}
              for iTabKey, sTabData in pairs(objChatTabs[iMoveTab + 1][2]) do
                table.insert(objTempTab[2], sTabData)
              end
              -- Move the current tab into the right tab
              objChatTabs[iMoveTab + 1][1] = objChatTabs[iMoveTab][1]
              objChatTabs[iMoveTab + 1][2] = {}
              for iTabKey, sTabData in pairs(objChatTabs[iMoveTab][2]) do
                table.insert(objChatTabs[iMoveTab + 1][2], sTabData)
              end
              -- Move the recorded tab into the current tab
              objChatTabs[iMoveTab][1] = objTempTab[1]
              objChatTabs[iMoveTab][2] = {}
              for iTabKey, sTabData in pairs(objTempTab[2]) do
                table.insert(objChatTabs[iMoveTab][2], sTabData)
              end
            end
            if (iCurrentChannelChoice == iMoveTab) then
              ChangeChatChannel(iMoveTab + 1)
            elseif (iCurrentChannelChoice == (iMoveTab + 1)) then
              ChangeChatChannel(iMoveTab)
            end
          end
          RedrawCommsWindow()

        -- Delete a tab altogether
        elseif (string.sub(sRMBResult, 1, 16) == "Delete Chat Tab ") then
          sRMBResult = string.sub(sRMBResult, 17)
          local iWhere = string.find(sRMBResult, ":")
          local iDeleteTab = tonumber(string.sub(sRMBResult, 1, iWhere - 1))
          sRMBResult = string.sub(sRMBResult, iWhere + 2)
          if (iDeleteTab ~= 0) then
            table.remove(objChatTabs, iDeleteTab)
            iCurrentChannelChoice = 1
            iCommsMessagesCurrentlyShown = 0
            for sKey, sData in pairs(objChatFilters) do
              objChatFilters[sKey][2] = true
              iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown + iCommsCountByType[sKey]
            end
            iCommLineBottomRender = iCommsMessagesCurrentlyShown
            RedrawCommsWindow()
            ColourNote(sCOLOUR.orange, "", "You have deleted the chat-tab named '" .. sRMBResult .. "'")
          end

        -- Pre-configured layout themes
        elseif (sRMBResult == "Simple Cow") then
          QuowLayoutTheme(11)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Cow-Bar Classic Top") then
          QuowLayoutTheme(1)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Cow-Bar Classic Left") then
          QuowLayoutTheme(2)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Cow-Bar Classic Right") then
          QuowLayoutTheme(3)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Cow-Bar Classic Bottom") then
          QuowLayoutTheme(4)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Micro-Cow Miniatures") then
          QuowLayoutTheme(5)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Big-Cows Big-Windows") then
          QuowLayoutTheme(6)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Side of Beef Left") then
          QuowLayoutTheme(12)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Side of Beef Right") then
          QuowLayoutTheme(13)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Minimoolist") then
          QuowLayoutTheme(14)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Marginalised Cows") then
          QuowLayoutTheme(7)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Semi-Skimmed Top") then
          QuowLayoutTheme(8)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Semi-Skimmed Bottom") then
          QuowLayoutTheme(9)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: " .. sRMBResult)
        elseif (sRMBResult == "Load Custom Cows Layout") then
          QuowLayoutTheme(10)
          ColourNote(sCOLOUR.orange, "", "Reset and repositioned all of your windows to the layout: Custom Cows")
        elseif (sRMBResult == "Save Custom Cows Layout") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "QuowSaveCustomCows", "", "")
          ColourNote(sCOLOUR.orange, "", "Your current exact window positions and sizes have been saved to the Custom Cows layout.")

        -- Import scaled output
        elseif (sRMBResult == "Import Scaled Layout") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "QuowLayoutImport")
        -- Export scaled output
        elseif (sRMBResult == "Export Scaled Layout") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "QuowLayoutExport")

        -- Lock XP Window Position
        elseif (sRMBResult == "Lock XP Window Position") then
          if (WINDATA[winXP]["LOCKED"] == true) then
            WINDATA[winXP]["LOCKED"] = false
          else
            WINDATA[winXP]["LOCKED"] = true
          end
        -- Lock Vitals Window Position
        elseif (sRMBResult == "Lock Vitals Window Position") then
          if (WINDATA[winBars]["LOCKED"] == true) then
            WINDATA[winBars]["LOCKED"] = false
          else
            WINDATA[winBars]["LOCKED"] = true
          end
        -- Lock Stats Window Position
        elseif (sRMBResult == "Lock Combat Stats Window Position") then
          if (WINDATA[winStats]["LOCKED"] == true) then
            WINDATA[winStats]["LOCKED"] = false
          else
            WINDATA[winStats]["LOCKED"] = true
          end
        -- Lock MDT Window Position
        elseif (sRMBResult == "Lock Written Map Window Position") then
          if (WINDATA[winMDT]["LOCKED"] == true) then
            WINDATA[winMDT]["LOCKED"] = false
          else
            WINDATA[winMDT]["LOCKED"] = true
          end
        -- Lock Minimap Window Position
        elseif (sRMBResult == "Lock Minimap Window Position") then
          if (WINDATA[winMinimap]["LOCKED"] == true) then
            WINDATA[winMinimap]["LOCKED"] = false
          else
            WINDATA[winMinimap]["LOCKED"] = true
          end
        elseif (sRMBResult == "Hide Minimap Window") then
          ColourNote(sCOLOUR.orange, "", "Hiding the minimap window.  Use '", sCOLOUR.cyan, "", "minimap show", sCOLOUR.orange, "", "' to display again.")
          ColourNote(sCOLOUR.silver, "", "Note:  MANY options and features of Cow Bar are controlled through the minimap window menu!")
          WindowShow(winMinimap, false)
          WINDATA[winMinimap]["SHOW"] = false
          iThemeLayoutLocked = 0
          bMinimapHidden = true
          bMinimapTempHidden = false

        -- Lock Shields Window Position
        elseif (sRMBResult == "Lock Shields Window Position") then
          if (WINDATA[winShields]["LOCKED"] == true) then
            WINDATA[winShields]["LOCKED"] = false
          else
            WINDATA[winShields]["LOCKED"] = true
          end
        -- Lock Comms Window Position
        elseif (sRMBResult == "Lock Comms Window Position") then
          if (WINDATA[winComms]["LOCKED"] == true) then
            WINDATA[winComms]["LOCKED"] = false
          else
            WINDATA[winComms]["LOCKED"] = true
          end
        -- Lock Ascii-Map Window Position
        elseif (sRMBResult == "Lock Ascii-Map Window Position") then
          if (WINDATA[winAscii]["LOCKED"] == true) then
            WINDATA[winAscii]["LOCKED"] = false
          else
            WINDATA[winAscii]["LOCKED"] = true
          end
        -- Lock Hotspots Window Position
        elseif (sRMBResult == "Lock Hotspots Window Position") then
          if (WINDATA[winHotspots]["LOCKED"] == true) then
            WINDATA[winHotspots]["LOCKED"] = false
          else
            WINDATA[winHotspots]["LOCKED"] = true
          end

        -- HIDE XP Window
        elseif (sRMBResult == "Hide XP Window") then
          WINDATA[winXP]["SHOW"] = false
          iThemeLayoutLocked = 0
          WindowShow(winXP, false)
          ColourNote(sCOLOUR.orange, "", "You have hidden the XP window.")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowWindow(" .. winXP .. ")", "Click here to show it again", "", sCOLOUR.cyan, "", 0)
          ColourNote(sCOLOUR.orange, "", " (or from the minimap right-click, extra windows sub-menu)")
        -- HIDE Vitals Window
        elseif (sRMBResult == "Hide Vitals Window") then
          WINDATA[winBars]["SHOW"] = false
          iThemeLayoutLocked = 0
          WindowShow(winBars, false)
          ColourNote(sCOLOUR.orange, "", "You have hidden the Vitals window.")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowWindow(" .. winBars .. ")", "Click here to show it again", "", sCOLOUR.cyan, "", 0)
          ColourNote(sCOLOUR.orange, "", " (or from the minimap right-click, extra windows sub-menu)")
        -- HIDE Stats Window
        elseif (sRMBResult == "Hide Combat Stats Window") then
          WINDATA[winStats]["SHOW"] = false
          iThemeLayoutLocked = 0
          WindowShow(winStats, false)
          ColourNote(sCOLOUR.orange, "", "You have hidden the Combat Stats window.")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowWindow(" .. winStats .. ")", "Click here to show it again", "", sCOLOUR.cyan, "", 0)
          ColourNote(sCOLOUR.orange, "", " (or from the minimap right-click, extra windows sub-menu)")
        -- HIDE MDT Window
        elseif (sRMBResult == "Hide Written Map Window") then
          WINDATA[winMDT]["SHOW"] = false
          iThemeLayoutLocked = 0
          WindowShow(winMDT, false)
          ColourNote(sCOLOUR.orange, "", "You have hidden the Written Map window.")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowWindow(" .. winMDT .. ")", "Click here to show it again", "", sCOLOUR.cyan, "", 0)
          ColourNote(sCOLOUR.orange, "", " (or from the minimap right-click, extra windows sub-menu)")
        -- HIDE Shields Window
        elseif (sRMBResult == "Hide Shields Window") then
          WINDATA[winShields]["SHOW"] = false
          iThemeLayoutLocked = 0
          WindowShow(winShields, false)
          ColourNote(sCOLOUR.orange, "", "You have hidden the Shields window.")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowWindow(" .. winShields .. ")", "Click here to show it again", "", sCOLOUR.cyan, "", 0)
          ColourNote(sCOLOUR.orange, "", " (or from the minimap right-click, extra windows sub-menu)")
        -- HIDE Comms Window
        elseif (sRMBResult == "Hide Comms Window") then
          WINDATA[winComms]["SHOW"] = false
          iThemeLayoutLocked = 0
          WindowShow(winComms, false)
          ColourNote(sCOLOUR.orange, "", "You have hidden the Comms window.")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowWindow(" .. winComms .. ")", "Click here to show it again", "", sCOLOUR.cyan, "", 0)
          ColourNote(sCOLOUR.orange, "", " (or from the minimap right-click, extra windows sub-menu)")
        -- HIDE Ascii-map Window
        elseif (sRMBResult == "Hide Ascii-Map Window") then
          WINDATA[winAscii]["SHOW"] = false
          iThemeLayoutLocked = 0
          WindowShow(winAscii, false)
          ColourNote(sCOLOUR.orange, "", "You have hidden the Ascii-Map window.")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowWindow(" .. winAscii .. ")", "Click here to show it again", "", sCOLOUR.cyan, "", 0)
          ColourNote(sCOLOUR.orange, "", " (or from the minimap right-click, extra windows sub-menu)")
        -- HIDE Hotspots Window
        elseif (sRMBResult == "Hide Hotspots Window") then
          WINDATA[winHotspots]["SHOW"] = false
          iThemeLayoutLocked = 0
          WindowShow(winHotspots, false)
          ColourNote(sCOLOUR.orange, "", "You have hidden the Hotspots window.")
          Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowShowWindow(" .. winHotspots .. ")", "Click here to show it again", "", sCOLOUR.cyan, "", 0)
          ColourNote(sCOLOUR.orange, "", " (or from the minimap right-click, extra windows sub-menu)")


        -- **************************
        -- * Ascii Map menu options *
        -- **************************
        elseif (sRMBResult == "Auto-Hide-Show Ascii map with terrains") then
          if (bAutoShowHideAscii == true) then
            bAutoShowHideAscii = false
          else
            bAutoShowHideAscii = true
          end
        elseif (sRMBResult == "Omit Ascii map from MUD output") then
          if (bAsciiMapOmitted == true) then
            bAsciiMapOmitted = false
          else
            bAsciiMapOmitted = true
          end

        -- *********************************
        -- * Communications Window options *
        -- *********************************
        elseif (sRMBResult == "Stop Recording Talker/Club Channel") then
          local objChatChoices = {}
          for sKey, sData in pairs(objChatFilters) do
            if (sKey ~= "Tells_In" and sKey ~= "Tells_Out" and sKey ~= "Group_Say") then
              objChatChoices[#objChatChoices + 1] = sKey
            end
          end
          if (#objChatChoices > 0) then
            local iStopChatChoice = utils.listbox("Select a talker or club channel name you wish to STOP recording.\n\nThis will cause the comms window to totally ignore messages from this channel, and will disable any features such as omitting it from the main output, or sending it to the tabbed chat window.\n", "Stop Recording Channel", objChatChoices)
            if (iStopChatChoice ~= nil) then
              iStopChatChoice = tonumber(iStopChatChoice)
              if (objChatChoices[iStopChatChoice]) then
                sRMBResult = objChatChoices[iStopChatChoice]
                CallPlugin ("bfe35205f026786ea1d56e3b", "QuowDeleteTalkerTrigger", sRMBResult)
                objChatFilters[sRMBResult] = nil
                for iN = 1, #objChatTabs do
                  for sKey, sData in pairs(objChatTabs[iN][2]) do
                    if (sData == sRMBResult) then
                      ColourNote(sCOLOUR.silver, "", "Custom chat-tab '" .. objChatTabs[iN][1] .. "' has been updated to remove '" .. sRMBResult .. "' from it.")
                      table.remove(objChatTabs[iN][2], sKey)
                    end
                  end
                end
                local iAnyToRemove = 1
                local iChannelCount = 0
                while (iAnyToRemove ~= 0) do
                  iAnyToRemove = 0
                  for iN = 1, #objChatTabs do
                    iChannelCount = 0
                    for sKey, sData in pairs(objChatTabs[iN][2]) do
                      iChannelCount = iChannelCount + 1
                    end
                    if (objChatTabs[iN][2] == nil or iChannelCount == 0) then
                      iAnyToRemove = iN
                      break
                    end
                  end
                  if (iAnyToRemove ~= 0) then
                    ColourNote(sCOLOUR.silver, "", "Custom chat-tab '" .. objChatTabs[iAnyToRemove][1] .. "' has no associated recorded channels, deleting it.")
                    table.remove(objChatTabs, iAnyToRemove)
                  end
                end
                iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown - iCommsCountByType[sRMBResult]
                iCommsCountByType[sRMBResult] = nil
                iChatExtraChannels = iChatExtraChannels - 1
                iCurrentChannelChoice = 1
                iCommsMessagesCurrentlyShown = 0
                for sKey, sData in pairs(objChatFilters) do
                  objChatFilters[sKey][2] = true
                  iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown + iCommsCountByType[sKey]
                end
                iCommLineBottomRender = iCommsMessagesCurrentlyShown
                ColourNote(sCOLOUR.orange, "", "No longer recording or controlling talker/club channel (" .. sRMBResult .. ")")
                RedrawCommsWindow()
              else
                Note("Error trying to stop recording your chosen talker/club channel, please try again.")
              end
            else
              Note("Cancelled.  No talker or club channels have been changed.")
            end
          else
            Note("You are not currently recording any talker or club channels.")
          end


        elseif (sRMBResult == "Record New Talker/Club Channel") then
          local sPopupResult = utils.inputbox("Enter the EXACT talker/club name to record.\n\nThis must be capitalised correctly.\n\nFor example 'Wizards' (without quotes).\n", "Comms Channel Record", "", "", 12)
          if (sPopupResult ~= nil and objChatFilters[sPopupResult] == nil) then
            sPopupResult = string.gsub(sPopupResult, " ", "_")
            objChatFilters[sPopupResult] = {true, true, false}
            table.insert(objChatTabs, {string.gsub(sPopupResult, "_", " "), {sPopupResult}})
            iCommsCountByType[sPopupResult] = 0
            CallPlugin ("bfe35205f026786ea1d56e3b", "QuowAddTalkerTrigger", sPopupResult)
            iChatExtraChannels = iChatExtraChannels + 1
            iCurrentChannelChoice = 1
            iCommsMessagesCurrentlyShown = 0
            for sKey, sData in pairs(objChatFilters) do
              objChatFilters[sKey][2] = true
              iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown + iCommsCountByType[sKey]
            end
            iCommLineBottomRender = iCommsMessagesCurrentlyShown
            ColourNote(sCOLOUR.orange, "", "Now recording any talker messages from channel (" .. sPopupResult .. ")")
            RedrawCommsWindow()
          end

        elseif (string.sub(sRMBResult, 1, 15) == "Show Messages: ") then
          sRMBResult = string.sub(sRMBResult, 16)
          if (objChatFilters[sRMBResult][2] == true) then
            objChatFilters[sRMBResult][2] = false
            iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown - iCommsCountByType[sRMBResult]
          else
            objChatFilters[sRMBResult][2] = true
            iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown + iCommsCountByType[sRMBResult]
          end
          iCommLineBottomRender = iCommsMessagesCurrentlyShown
          RedrawCommsWindow()

        elseif (sRMBResult == "Show Chat Tabs") then
          if (bShowCommsTabs == true) then
            bShowCommsTabs = false
            iTopCommsWindow = 0           
            WindowMoveHotspot(winComms, "hsCommsUp", WINDATA[winComms]["WIDTH"]-(SCROLL_BAR_WIDTH + 1), iTopCommsWindow, WINDATA[winComms]["WIDTH"]-1, SCROLL_BAR_WIDTH + iTopCommsWindow)
            WindowMoveHotspot(winComms, "zz_mw_" .. winComms .. "_movewindow_hotspot", 0, iTopCommsWindow, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"])
            WindowDeleteHotspot (winComms, "hsChatTabs")
            bCommsNeedsButtons = true
            RedrawCommsWindow()
          else
            bShowCommsTabs = true
            iTopCommsWindow = iFontSizes[winComms]["lineheight"] + 3
            WindowMoveHotspot(winComms, "hsCommsUp", WINDATA[winComms]["WIDTH"]-(SCROLL_BAR_WIDTH + 1), iTopCommsWindow, WINDATA[winComms]["WIDTH"]-1, SCROLL_BAR_WIDTH + iTopCommsWindow)
            WindowMoveHotspot(winComms, "zz_mw_" .. winComms .. "_movewindow_hotspot", 0, iTopCommsWindow, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"])
            WindowAddHotspot(winComms, "hsChatTabs", 0, 0, WINDATA[winComms]["WIDTH"], iTopCommsWindow, "", "", "", "", "ChatTabMouseUp", "",  miniwin.cursor_hand, 0)
            bCommsNeedsButtons = true
            RedrawCommsWindow()
          end

        elseif (string.sub(sRMBResult, 1, 11) == "Show Only: ") then
          sRMBResult = string.sub(sRMBResult, 12)
          if (sRMBResult == "Tells") then
            iCommsMessagesCurrentlyShown = iCommsCountByType["Tells_In"] + iCommsCountByType["Tells_Out"]
            for sKey, sData in pairs(objChatFilters) do
              objChatFilters[sKey][2] = false
            end
            objChatFilters["Tells_In"][2] = true
            objChatFilters["Tells_Out"][2] = true
          else
            if (sRMBResult == "Tells In") then
              sRMBResult = "Tells_In"
            elseif (sRMBResult == "Tells Out") then
              sRMBResult = "Tells_Out"
            elseif (sRMBResult == "Group Say") then
              sRMBResult = "Group_Say"
            end
            objChatFilters[sRMBResult][2] = true
            for sKey, sData in pairs(objChatFilters) do
              if (sKey ~= sRMBResult) then
                objChatFilters[sKey][2] = false
              end
            end
            iCommsMessagesCurrentlyShown = iCommsCountByType[sRMBResult]
          end
          iCommLineBottomRender = iCommsMessagesCurrentlyShown
          RedrawCommsWindow()

        elseif (sRMBResult == "Show All Messages") then
          iCommsMessagesCurrentlyShown = 0
          for sKey, sData in pairs(objChatFilters) do
            objChatFilters[sKey][2] = true
            iCommsMessagesCurrentlyShown = iCommsMessagesCurrentlyShown + iCommsCountByType[sKey]
          end
          iCommLineBottomRender = iCommsMessagesCurrentlyShown
          RedrawCommsWindow()

        elseif (sRMBResult == "Copy All Messages To Clipboard") then
          local sMessageBuffer = ""
          local iShownMessages = 0
          local iStartMessages = 1
          if (#sCommsBuffer > 1001) then
            iStartMessages = #sCommsBuffer - 1000
          end
          for iC = iStartMessages, #sCommsBuffer do
            -- Is this a type of message we CURRENTLY want to display?
            if (objChatFilters[sCommsBuffer[iC][1]][2] == true) then
              -- Loop through the styles
              for iStyleKey, sThisStyle in ipairs (sCommsBuffer[iC][3]) do
                sMessageBuffer = sMessageBuffer .. sThisStyle.text
              end
              iShownMessages = iShownMessages + 1
              sMessageBuffer = sMessageBuffer .. "\n"
            end
          end
          SetClipboard(sMessageBuffer)
          sMessageBuffer = nil
          ColourNote(sCOLOUR.orange, "", "Filtered messages copied to clipboard [" .. iShownMessages .. " messages]")
          if (iStartMessages > 1) then
            ColourNote(sCOLOUR.orange, "", " ( [Messages " .. iStartMessages .. " to " .. iShownMessages .. " copied]")
          end
          iShownMessages = nil

        elseif (sRMBResult == "Copy Selected Line To Clipboard") then
          RedrawCommsWindow(iCommLineClicked)

        elseif (string.sub(sRMBResult, 1, 18) == "Echo Main Output: ") then
          sRMBResult = string.sub(sRMBResult, 19)
          if (sRMBResult == "Group Say") then
            sRMBResult = "Group_Say"
          end
          if (objChatFilters[sRMBResult][3] == true) then
            objChatFilters[sRMBResult][3] = false
            ColourNote(sCOLOUR.orange, "", "Now showing/echoing '" .. sRMBResult .. "' in main MUD output.")
            if (sRMBResult ~= "Group_Say") then
              sRMBResult = "CommLog_" .. string.gsub(sRMBResult, "-", "_ZXA_")
              sRMBResult = string.gsub(sRMBResult, "'", "_APP_")
              sRMBResult = string.gsub(sRMBResult, "&", "_AMP_")
            else
              sRMBResult = "CommLog_Group_Say"
            end
            CallPlugin ("bfe35205f026786ea1d56e3b", "QuowSetTriggerOption", sRMBResult, "omit_from_output", "n")
          else
            objChatFilters[sRMBResult][3] = true
            ColourNote(sCOLOUR.orange, "", "Now hiding/not echoing '" .. sRMBResult .. "' from main MUD output.")
            if (sRMBResult ~= "Group_Say") then
              sRMBResult = "CommLog_" .. string.gsub(sRMBResult, "-", "_ZXA_")
              sRMBResult = string.gsub(sRMBResult, "'", "_APP_")
              sRMBResult = string.gsub(sRMBResult, "&", "_AMP_")
            else
              sRMBResult = "CommLog_Group_Say"
            end
            CallPlugin ("bfe35205f026786ea1d56e3b", "QuowSetTriggerOption", sRMBResult, "omit_from_output", "y")
          end

        -- ******************************
        -- * Group Shields menu options *
        -- ******************************

        elseif (sRMBResult == "Self-Solo Shields Only") then
          if (bSoloShieldsWindow == true) then
            bSoloShieldsWindow = false
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar WILL try to show all group members in shields window.")
            RedrawShieldsWindow()
            Redraw()
          else
            bSoloShieldsWindow = true
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar WON'T show group members in shields window.")
            RedrawShieldsWindow()
            Redraw()
          end

        -- Self shield chat alerts
        elseif (sRMBResult == "Self Shield Chat Alerts") then
          if (bSelfShieldChats == false) then
            bSelfShieldChats = true
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar WILL show chat-logs of your own shield-break events.")
          else
            bSelfShieldChats = false
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar WON'T show chat-logs of your own shield-break events.")
          end
        -- Group shield chat alerts
        elseif (sRMBResult == "Group Shield Chat Alerts") then
          if (bGroupShieldChats == false) then
            bGroupShieldChats = true
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar WILL show chat-logs of group member shield-break events.")
          else
            bGroupShieldChats = false
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar WON'T show chat-logs of group member shield-break events.")
          end

        -- Shield colouring handlers
        elseif (string.sub(sRMBResult, 1, 16) == "ENABLE Colour - ") then
          -- Enable/Disable re-colouring for this shield event type
          sRMBResult = string.sub(sRMBResult, 17)
          local sSubType = string.lower(string.sub(sRMBResult, -3))
          local sCatType = string.lower(string.sub(sRMBResult, 1, -5))
          if (sSubType == " ms") then
            sSubType = "ms"
            sCatType = string.lower(string.sub(sRMBResult, 1, -4))
          end
          local sColourOption = "nocol_" .. sCatType .. "_" .. sSubType
          sUSER_OPTIONS[sColourOption] = ((sUSER_OPTIONS[sColourOption] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS[sColourOption]) .. "' WHERE option_id='" .. sColourOption .. "'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "ShieldsNoColour", "", "")
          if (sUSER_OPTIONS[sColourOption] == "0") then
            ColourNote(sUSER_OPTIONS["col_" .. sCatType .. "_" .. sSubType], "", "Quow's Cow Bar will NOT re-colour '" .. sRMBResult .. "' events for you.")
          else
            ColourNote(sUSER_OPTIONS["col_" .. sCatType .. "_" .. sSubType], "", "Quow's Cow Bar WILL re-colour '" .. sRMBResult .. "' events for you.")
          end

        elseif (string.sub(sRMBResult, 1, 16) == "CHOOSE Colour - ") then
          -- Choose a re-colouring for this shield event type
          sRMBResult = string.sub(sRMBResult, 17)
          local sSubType = string.lower(string.sub(sRMBResult, -3))
          local sCatType = string.lower(string.sub(sRMBResult, 1, -5))
          if (sSubType == " ms") then
            sSubType = "ms"
            sCatType = string.lower(string.sub(sRMBResult, 1, -4))
          end
          local sColourOption = "col_" .. sCatType .. "_" .. sSubType
          FetchShieldColour(sColourOption)

        elseif (string.sub(sRMBResult, 1, 15) == "CHOOSE Sound - ") then
          -- Selecting a file-location of a sound for this shield-break type
          sRMBResult = string.sub(sRMBResult, 16)
          local sSubType = string.lower(string.sub(sRMBResult, -3))
          local sCatType = string.lower(string.sub(sRMBResult, 1, -5))
          if (sSubType == " ms") then
            sSubType = "ms"
            sCatType = string.lower(string.sub(sRMBResult, 1, -4))
          end
          local sThisType = sCatType .. "_" .. sSubType
          local sFilename = utils.filepicker("Select Valid *.Wav Nofication Sound", sSoundPlayShields[sThisType], "*.wav", { ["wav"] = "Wav Files" }, false)
          if (sFilename ~= nil) then
            if (sFileName ~= sSoundPlayShields[sThisType]) then
              sSoundPlayShields[sThisType] = sFilename
              if (bSoundPlayShields[sThisType] == true and sSoundPlayShields[sThisType] ~= "") then
                local fSound = io.open(sSoundPlayShields[sThisType], "rb")
                if (fSound ~= nil) then
                  objSoundPlayShields[sThisType] = fSound:read("*a")
                  fSound:close()
                  fSound = nil
                end
              end
              Note("(disclaimer - Quow is not responsible for missed shield-breaks!)")
              ColourNote(sCOLOUR.orange, "", "Your " .. sRMBResult .. " break notification soundfile is now set to: ", sCOLOUR.cyan, "", sSoundPlayShields[sThisType])
              if (bSoundPlayShields[sThisType] == false) then
                ColourNote(sCOLOUR.silver, "", "(note that you must still tick the appropriate 'ENABLE sound' option in the same menu)")
              elseif (objSoundPlayShields[sThisType] ~= nil) then
                local iSoundError = PlaySoundMemory(0, objSoundPlayShields[sThisType], false, -6, 0)
                if (iSoundError ~= 0) then
                  ColourNote(sCOLOUR.red, "", "(Cow Bar detected a MUSH error code " .. iSoundError .. " when trying to play that sound, try a different WAV encoded file)")
                else
                  ColourNote(sCOLOUR.orange, "", "(Cow Bar just tried to play the sound... if you didn't hear it, check your system/application/speaker volumes or try a different WAV encoded file)")
                end
              end
            else
              Note("(disclaimer - Quow is not responsible for missed shield-breaks!)")
              ColourNote(sCOLOUR.orange, "", "Your " .. sRMBResult .. " break notification sound has not been changed.")
              if (bSoundPlayShields[sThisType] == false) then
                ColourNote(sCOLOUR.silver, "", "(note that you must still tick the appropriate 'ENABLE sound' option in the same menu)")
              elseif (objSoundPlayShields[sThisType] ~= nil) then
                local iSoundError = PlaySoundMemory(0, objSoundPlayShields[sThisType], false, -6, 0)
                if (iSoundError ~= 0) then
                  ColourNote(sCOLOUR.red, "", "(Cow Bar detected a MUSH error code " .. iSoundError .. " when trying to play that sound, try a different WAV encoded file)")
                else
                  ColourNote(sCOLOUR.orange, "", "(Cow Bar just tried to play the sound... if you didn't hear it, check your system/application/speaker volumes or try a different WAV encoded file)")
                end
              end
            end
          else
            ColourNote(sCOLOUR.orange, "", "Your " .. sRMBResult .. " break notification soundfile is unchanged.")
          end

        elseif (string.sub(sRMBResult, 1, 15) == "ENABLE Sound - ") then
          -- Tickbox enable or disable playing of the sound for this shield-break type
          sRMBResult = string.sub(sRMBResult, 16)
          local sSubType = string.lower(string.sub(sRMBResult, -3))-- Major shield string is shorter
          local sCatType = string.lower(string.sub(sRMBResult, 1, -5))
          if (sSubType == " ms") then
            sSubType = "ms"
            sCatType = string.lower(string.sub(sRMBResult, 1, -4))
          end
          local sThisType = sCatType .. "_" .. sSubType
          if (bSoundPlayShields[sThisType] == true) then
            bSoundPlayShields[sThisType] = false
            objSoundPlayShields[sThisType] = nil
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will no longer play any notification sound for " .. sRMBResult .. " breaks.")
          else
            SetOption ("play_sounds_in_background", 1)
            bSoundPlayShields[sThisType] = true
            if (bSoundPlayShields[sThisType] == true and sSoundPlayShields[sThisType] ~= "") then
              local fSound = io.open(sSoundPlayShields[sThisType], "rb")
              if (fSound ~= nil) then
                objSoundPlayShields[sThisType] = fSound:read("*a")
                fSound:close()
                fSound = nil
              end
            end
            Note("(disclaimer - Quow is not responsible for missed shield-breaks!)")
            if (objSoundPlayShields[sThisType] ~= nil) then
              ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will attempt to play the following soundfile for " .. sRMBResult .. " breaks;")
              ColourNote(sCOLOUR.cyan, "", sSoundPlayShields[sThisType])
              local iSoundError = PlaySoundMemory(0, objSoundPlayShields[sThisType], false, -6, 0)
              if (iSoundError ~= 0) then
                ColourNote(sCOLOUR.red, "", "(Cow Bar detected a MUSH error code " .. iSoundError .. " when trying to play that sound, try a different WAV encoded file)")
              else
                ColourNote(sCOLOUR.orange, "", "(Cow Bar just tried to play the sound... if you didn't hear it, check your system/application/speaker volumes or try a different WAV encoded file)")
              end
            else
              ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar is now set to attempt to play sounds for " .. sRMBResult .. " breaks.")
              ColourNote(sCOLOUR.red, "", "But you must still CHOOSE a valid soundfile for this shield type first!")
            end
          end

        elseif (sRMBResult == "Group Say Group Kills Report") then
          QuowGroupReportKills()

        elseif (sRMBResult == "Show Private Group Kills Report") then
          local bAnyReports = false
          for sCharacterName, sGroupData in pairs(sGroupMembers) do
            if (sCharacterName ~= "You") then
              ColourNote(sCOLOUR.orange, "", sCharacterName, sCOLOUR.silver, "", ": " .. sGroupData["Kills"] .. " kills.  ~" .. string.format("%.0f", (sGroupData["Kills"] / ((OST() - sGroupData["MemberSince"]) / 3600) )) .. " k/h.  Member for " .. MinutesToTimeString(math.floor((OST() - sGroupData["MemberSince"]) / 60)) .. ".")
              bAnyReports = true
            end
          end
          if (bAnyReports == false) then
            ColourNote(sCOLOUR.orange, "", "Unable to generate a group kills report.  Try 'Refresh Group Status and Shields' first to make sure the plugin is logging your group stats.")
          end
        elseif (sRMBResult == "Refresh Solo Character Shields") then
          for sCharacterName, sGroupData in pairs(sGroupMembers) do
            if (sCharacterName ~= "You") then
              sGroupMembers[sCharacterName] = nil
            end
          end
          RedrawShieldsWindow()
          Redraw()
          SendNoEcho("shields")
        elseif (sRMBResult == "Refresh Group Status and Shields") then
          QuowGroupResetRefresh()

        -- ******************************
        -- * Vitals window menu options *
        -- ******************************
        elseif (sRMBResult == "Colour: Reset Vitals Bars") then
          sUSER_OPTIONS["vitals_hp_a"] = 36864
          sUSER_OPTIONS["vitals_hp_b"] = 56797
          sUSER_OPTIONS["vitals_hp_c"] = 255
          sUSER_OPTIONS["vitals_gp_a"] = 15597568
          sUSER_OPTIONS["vitals_gp_b"] = 10027076
          sUSER_OPTIONS["vitals_gp_c"] = 6684774
          sUSER_OPTIONS["vitals_b_a"] = 36864
          sUSER_OPTIONS["vitals_b_b"] = 56797
          sUSER_OPTIONS["vitals_b_c"] = 255
          local sOptionSQL = "INSERT OR REPLACE INTO user_options (option_id, option_value) VALUES ('vitals_hp_a', 36864)," ..
            "('vitals_hp_b', 56797),('vitals_hp_c', 255),('vitals_gp_a', 15597568),('vitals_gp_b', 10027076),('vitals_gp_c', 6684774)," ..
            "('vitals_b_a', 36864),('vitals_b_b', 56797),('vitals_b_c', 255)"
          assert(dbUserData:execute(sOptionSQL))
          sOptionSQL = nil
          -- Re-cache the new values
          for iN = 0, 100 do
            iPercToColour["hp"][iN] = PercentageToColour(iN, sUSER_OPTIONS["vitals_hp_a"], sUSER_OPTIONS["vitals_hp_b"], sUSER_OPTIONS["vitals_hp_c"])
            iPercToColour["gp"][iN] = PercentageToColour(iN, sUSER_OPTIONS["vitals_gp_a"], sUSER_OPTIONS["vitals_gp_b"], sUSER_OPTIONS["vitals_gp_c"])
            iPercToColour["b"][iN] = PercentageToColour(iN, sUSER_OPTIONS["vitals_b_a"], sUSER_OPTIONS["vitals_b_b"], sUSER_OPTIONS["vitals_b_c"])
          end
          -- Redraw the vitals properly
          bForceVitalsUpdate = true
          CallPlugin ("bfe35205f026786ea1d56e3b", "RedrawVitalsWindow", "", "")
          Repaint()

        elseif (sRMBResult == "Colour: HP Full Colour") then
          FetchVitalsColour(sUSER_OPTIONS["vitals_hp_a"], "vitals_hp_a")
        elseif (sRMBResult == "Colour: HP Half Colour") then
          FetchVitalsColour(sUSER_OPTIONS["vitals_hp_b"], "vitals_hp_b")
        elseif (sRMBResult == "Colour: HP Low Colour") then
          FetchVitalsColour(sUSER_OPTIONS["vitals_hp_c"], "vitals_hp_c")
        elseif (sRMBResult == "Colour: GP Full Colour") then
          FetchVitalsColour(sUSER_OPTIONS["vitals_gp_a"], "vitals_gp_a")
        elseif (sRMBResult == "Colour: GP Half Colour") then
          FetchVitalsColour(sUSER_OPTIONS["vitals_gp_b"], "vitals_gp_b")
        elseif (sRMBResult == "Colour: GP Low Colour") then
          FetchVitalsColour(sUSER_OPTIONS["vitals_gp_c"], "vitals_gp_c")
        elseif (sRMBResult == "Colour: Burden Empty Colour") then
          FetchVitalsColour(sUSER_OPTIONS["vitals_b_a"], "vitals_b_a")
        elseif (sRMBResult == "Colour: Burden Half Colour") then
          FetchVitalsColour(sUSER_OPTIONS["vitals_b_b"], "vitals_b_b")
        elseif (sRMBResult == "Colour: Burden Heavy Colour") then
          FetchVitalsColour(sUSER_OPTIONS["vitals_b_c"], "vitals_b_c")
        elseif (sRMBResult == "Show Alignment") then
          if (bShowAlignment == true) then
            bShowAlignment = false
          else
            bShowAlignment = true
          end
          bForceVitalsCache = true
          bForceVitalsUpdate = true
          RedrawVitalsWindow()
          Repaint()
        elseif (sRMBResult == "Show HP Loss Notification Texts") then
          if (bShowHPNotifications == true) then
            bShowHPNotifications = false
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will not show any HP drop notices.")
          else
            bShowHPNotifications = true
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will output a notice to your output window for all HP drops.")
          end

        elseif (sRMBResult == "Show GP Loss Notification Texts") then
          if (bShowGPNotifications == true) then
            bShowGPNotifications = false
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will not show any GP drop notices.")
          else
            bShowGPNotifications = true
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will output a notice to your output window for all GP drops greater than 5.")
          end

        -- Vitals normal 
        elseif (sRMBResult == "Standard Vertical Bars") then
          if (iVitalsFormat ~= 0) then
            iVitalsFormat = 0
            bForceVitalsUpdate = true
            bForceVitalsCache = true
            RedrawVitalsWindow()
            Repaint()
          end
        -- Vitals side-by-side
        elseif (sRMBResult == "Standard Horizontal Bars") then
          if (iVitalsFormat ~= 1) then
            iVitalsFormat = 1
            bForceVitalsUpdate = true
            bForceVitalsCache = true
            RedrawVitalsWindow()
            Repaint()
          end
        -- Vitals sideways, emptying
        elseif (sRMBResult == "Downwards Bars") then
          if (iVitalsFormat ~= 2) then
            iVitalsFormat = 2
            bForceVitalsUpdate = true
            bForceVitalsCache = true
            RedrawVitalsWindow()
            Repaint()
          end
        -- Vitals sideways, filling
        elseif (sRMBResult == "Upwards Bars") then
          if (iVitalsFormat ~= 3) then
            iVitalsFormat = 3
            bForceVitalsUpdate = true
            bForceVitalsCache = true
            RedrawVitalsWindow()
            Repaint()
          end

        elseif (sRMBResult == "Vitals Bar Gradients") then
          if (bVitalsGradients == true) then
            bVitalsGradients = false
          else
            bVitalsGradients = true
          end
          bForceVitalsUpdate = true
          RedrawVitalsWindow()
          Repaint()


        -- * HP Low Notification Sound Handling *
        elseif (sRMBResult == "Choose HP Low Wav File Sound") then
          local sFilename = utils.filepicker("Select Valid *.Wav Nofication Sound", sHPNotificationFile, "*.wav", { ["wav"] = "Wav Files" }, false)
          if (sFilename ~= nil) then
            if (sFileName ~= sHPNotificationFile) then
              sHPNotificationFile = sFilename
              if (bPlayHPNotification == true and sHPNotificationFile ~= "") then
                local fSound = io.open(sHPNotificationFile, "rb")
                if (fSound ~= nil) then
                  objSoundHPNotification = fSound:read("*a")
                  fSound:close()
                  fSound = nil
                end
              end
              ColourNote(sCOLOUR.orange, "", "Your HP low notification soundfile is now set to: ", sCOLOUR.cyan, "", sHPNotificationFile)
              if (bPlayHPNotification == false) then
                ColourNote(sCOLOUR.silver, "", "(note that you must still tick the 'Play Sound On Low HP' option to enable sound playing)")
              elseif (objSoundHPNotification ~= nil) then
                local iSoundError = PlaySoundMemory(0, objSoundHPNotification, false, -6, 0)
                if (iSoundError ~= 0) then
                  ColourNote(sCOLOUR.red, "", "(Cow Bar detected a MUSH error code " .. iSoundError .. " when trying to play that sound, try a different WAV encoded file)")
                else
                  ColourNote(sCOLOUR.orange, "", "(Cow Bar just tried to play the sound... if you didn't hear it, check your system/application/speaker volumes or try a different WAV encoded file)")
                end
              end
            else
              ColourNote(sCOLOUR.orange, "", "Your HP low notification sound has not been changed.")
              if (bPlayHPNotification == false) then
                ColourNote(sCOLOUR.silver, "", "(note that you must still tick the 'Play Sound On Low HP' option to enable sound playing)")
              elseif (objSoundHPNotification ~= nil) then
                local iSoundError = PlaySoundMemory(0, objSoundHPNotification, false, -6, 0)
                if (iSoundError ~= 0) then
                  ColourNote(sCOLOUR.red, "", "(Cow Bar detected a MUSH error code " .. iSoundError .. " when trying to play that sound, try a different WAV encoded file)")
                else
                  ColourNote(sCOLOUR.orange, "", "(Cow Bar just tried to play the sound... if you didn't hear it, check your system/application/speaker volumes or try a different WAV encoded file)")
                end
              end
            end
          else
            ColourNote(sCOLOUR.orange, "", "Your HP low notification soundfile is unchanged.")
          end

        elseif (sRMBResult == "Play Sound On Low HP") then
          if (bPlayHPNotification == true) then
            bPlayHPNotification = false
            objSoundHPNotification = nil
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will no longer play any notification sound for HP getting low.")
          else
            SetOption ("play_sounds_in_background", 1)
            bPlayHPNotification = true
            if (bPlayHPNotification == true and sHPNotificationFile ~= "") then
              local fSound = io.open(sHPNotificationFile, "rb")
              if (fSound ~= nil) then
                objSoundHPNotification = fSound:read("*a")
                fSound:close()
                fSound = nil
              end
            end
            if (objSoundHPNotification ~= nil) then
              ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will attempt to play the following soundfile when your HP gets below 30%:")
              ColourNote(sCOLOUR.cyan, "", sHPNotificationFile)
              ColourNote(sCOLOUR.orange, "", "(Notes:  It will not play this sound if you get instantly killed below this amount, and HP must fill back to 90+% since last playing before it can play again)")
              local iSoundError = PlaySoundMemory(0, objSoundHPNotification, false, -6, 0)
              if (iSoundError ~= 0) then
                ColourNote(sCOLOUR.red, "", "(Cow Bar detected a MUSH error code " .. iSoundError .. " when trying to play that sound, try a different WAV encoded file)")
              else
                ColourNote(sCOLOUR.orange, "", "(Cow Bar just tried to play the sound... if you didn't hear it, check your system/application/speaker volumes or try a different WAV encoded file)")
              end
            else
              ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar is now set to attempt to play sounds for HP getting below 30%.")
              ColourNote(sCOLOUR.orange, "", "(Notes:  It will not play sounds if you get instantly killed below this amount, and HP must fill back to 90+% since last playing before it can play again)")
              ColourNote(sCOLOUR.red, "", "But you must still CHOOSE a valid soundfile for HP low notifications first!")
            end
          end

        -- * GP Full Notification Sound Handling *
        elseif (sRMBResult == "Choose GP Full Wav File Sound") then
          local sFilename = utils.filepicker("Select Valid *.Wav Nofication Sound", sGPNotificationFile, "*.wav", { ["wav"] = "Wav Files" }, false)
          if (sFilename ~= nil) then
            if (sFileName ~= sGPNotificationFile) then
              sGPNotificationFile = sFilename
              if (bPlayGPNotification == true and sGPNotificationFile ~= "") then
                local fSound = io.open(sGPNotificationFile, "rb")
                if (fSound ~= nil) then
                  objSoundGPNotification = fSound:read("*a")
                  fSound:close()
                  fSound = nil
                end
              end
              ColourNote(sCOLOUR.orange, "", "Your GP full notification soundfile is now set to: ", sCOLOUR.cyan, "", sGPNotificationFile)
              if (bPlayGPNotification == false) then
                ColourNote(sCOLOUR.silver, "", "(note that you must still tick the 'Play Sound On Full GP' option to enable sound playing)")
              elseif (objSoundGPNotification ~= nil) then
                local iSoundError = PlaySoundMemory(0, objSoundGPNotification, false, -6, 0)
                if (iSoundError ~= 0) then
                  ColourNote(sCOLOUR.red, "", "(Cow Bar detected a MUSH error code " .. iSoundError .. " when trying to play that sound, try a different WAV encoded file)")
                else
                  ColourNote(sCOLOUR.orange, "", "(Cow Bar just tried to play the sound... if you didn't hear it, check your system/application/speaker volumes or try a different WAV encoded file)")
                end
              end
            else
              ColourNote(sCOLOUR.orange, "", "Your GP full notification sound has not been changed.")
              if (bPlayGPNotification == false) then
                ColourNote(sCOLOUR.silver, "", "(note that you must still tick the 'Play Sound On Full GP' option to enable sound playing)")
              elseif (objSoundGPNotification ~= nil) then
                local iSoundError = PlaySoundMemory(0, objSoundGPNotification, false, -6, 0)
                if (iSoundError ~= 0) then
                  ColourNote(sCOLOUR.red, "", "(Cow Bar detected a MUSH error code " .. iSoundError .. " when trying to play that sound, try a different WAV encoded file)")
                else
                  ColourNote(sCOLOUR.orange, "", "(Cow Bar just tried to play the sound... if you didn't hear it, check your system/application/speaker volumes or try a different WAV encoded file)")
                end
              end
            end
          else
            ColourNote(sCOLOUR.orange, "", "Your GP full notification soundfile is unchanged.")
          end

        elseif (sRMBResult == "Play Sound On Full GP") then
          if (bPlayGPNotification == true) then
            bPlayGPNotification = false
            objSoundGPNotification = nil
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will no longer play any notification sound for GP re-filling.")
          else
            SetOption ("play_sounds_in_background", 1)
            bPlayGPNotification = true
            if (bPlayGPNotification == true and sGPNotificationFile ~= "") then
              local fSound = io.open(sGPNotificationFile, "rb")
              if (fSound ~= nil) then
                objSoundGPNotification = fSound:read("*a")
                fSound:close()
                fSound = nil
              end
            end
            if (objSoundGPNotification ~= nil) then
              ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will attempt to play the following soundfile when your GP is full again, IF it has dropped to 75% full or less before refilling again.")
              ColourNote(sCOLOUR.cyan, "", sGPNotificationFile)
              local iSoundError = PlaySoundMemory(0, objSoundGPNotification, false, -6, 0)
              if (iSoundError ~= 0) then
                ColourNote(sCOLOUR.red, "", "(Cow Bar detected a MUSH error code " .. iSoundError .. " when trying to play that sound, try a different WAV encoded file)")
              else
                ColourNote(sCOLOUR.orange, "", "(Cow Bar just tried to play the sound... if you didn't hear it, check your system/application/speaker volumes or try a different WAV encoded file)")
              end
            else
              ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar is now set to attempt to play sounds for GP refilling after dropping below 75%.")
              ColourNote(sCOLOUR.red, "", "But you must still CHOOSE a valid soundfile for GP full notifications first!")
            end
          end

        -- **************************
        -- * XP window menu options *
        -- **************************
        elseif (sRMBResult == "Show XP Gain Notification Texts") then
          if (bShowXPNotifications == true) then
            bShowXPNotifications = false
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will not show any XP gain notices.")
          else
            bShowXPNotifications = true
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will output a notice to your output window for all XP gains of at least " .. (iXPNotificationLimit + 1) .. ".")
          end

        elseif (sRMBResult == "XP Limit 10+") then
          iXPNotificationLimit = 9
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP gain notification limit is now set to at least " .. (iXPNotificationLimit + 1) .. ".")
        elseif (sRMBResult == "XP Limit 100+") then
          iXPNotificationLimit = 99
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP gain notification limit is now set to at least " .. (iXPNotificationLimit + 1) .. ".")
        elseif (sRMBResult == "XP Limit 500+") then
          iXPNotificationLimit = 499
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP gain notification limit is now set to at least " .. (iXPNotificationLimit + 1) .. ".")
        elseif (sRMBResult == "XP Limit 1000+") then
          iXPNotificationLimit = 999
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP gain notification limit is now set to at least " .. (iXPNotificationLimit + 1) .. ".")
        elseif (sRMBResult == "XP Limit 5000+") then
          iXPNotificationLimit = 4999
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP gain notification limit is now set to at least " .. (iXPNotificationLimit + 1) .. ".")

        elseif (sRMBResult == "XP Scaling Auto") then
          iXPGraphScaling = 0
          RedrawXPWindow(true)
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP graph will auto-scale up to 1m max based on your xp rate (recommended).")
        elseif (sRMBResult == "XP Scaling Fixed 100k") then
          iXPGraphScaling = 100000
          RedrawXPWindow(true)
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP graph will lock the scale to a MAX rate of 100,000 xp/hour.")
        elseif (sRMBResult == "XP Scaling Fixed 200k") then
          iXPGraphScaling = 200000
          RedrawXPWindow(true)
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP graph will lock the scale to a MAX rate of 200,000 xp/hour.")
        elseif (sRMBResult == "XP Scaling Fixed 500k") then
          iXPGraphScaling = 500000
          RedrawXPWindow(true)
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP graph will lock the scale to a MAX rate of 500,000 xp/hour.")
        elseif (sRMBResult == "XP Scaling Fixed 800k") then
          iXPGraphScaling = 800000
          RedrawXPWindow(true)
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP graph will lock the scale to a MAX rate of 800,000 xp/hour.")
        elseif (sRMBResult == "XP Scaling Fixed 1m") then
          iXPGraphScaling = 1000000
          RedrawXPWindow(true)
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP graph will lock the scale to a MAX rate of 1,000,000 xp/hour.")
        elseif (sRMBResult == "XP Scaling Fixed 2m") then
          iXPGraphScaling = 2000000
          RedrawXPWindow(true)
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar XP graph will lock the scale to a MAX rate of 2,000,000 xp/hour.")

        elseif (sRMBResult == "Reset XP Rate") then
          QuowResetXPRates()

        elseif (sRMBResult == "Group Say XP Rate") then
          QuowGroupReportXP()

        elseif (sRMBResult == "Show XP Report") then
          ColourNote(sCOLOUR.silver, "", "          Character current XP:  ", sCOLOUR.orange, "", NumberCommaString(iCharVitals["xp"]) .. " xp")
          ColourNote(sCOLOUR.silver, "", "          Total Time Recording:  ", sCOLOUR.orange, "", MinutesToTimeString(iXPMinutesRecordedTotal))
          ColourNote(sCOLOUR.silver, "", "      Total earned since reset:  ", sCOLOUR.orange, "", NumberCommaString(iXPTotalRecordedIncoming) .. " xp")
          ColourNote(sCOLOUR.silver, "", "   Total xp/h rate since reset:  ", sCOLOUR.orange, "", ((iXPMinutesRecordedTotal > 0) and NumberCommaString(math.floor((iXPTotalRecordedIncoming / iXPMinutesRecordedTotal) * 60)) or 0) .. " xp/h")
          ColourNote(sCOLOUR.silver, "", string.format("%31s ", "Total earned past " .. ((iXPMinutesRecordedTotal >= 60) and MinutesToTimeString(60) or MinutesToTimeString(iXPMinutesRecordedTotal)) .. ":") .. " ", sCOLOUR.orange, "", NumberCommaString(iXPPastHour) .. " xp")
          ColourNote(sCOLOUR.silver, "", string.format("%31s ", "Current xp/h over past " .. ((iXPMinutesRecordedTotal >= 60) and MinutesToTimeString(60) or MinutesToTimeString(iXPMinutesRecordedTotal)) .. ":") .. " ", sCOLOUR.orange, "", NumberCommaString(iXPPerHour) .. " xp/h")



        -- ***************************************
        -- * Written-Map MDT window menu options *
        -- ***************************************
        -- Written map parsing disable/enable
        elseif (sRMBResult == "Enable Written-Map Parsing") then
          -- Now enable/disable the priority tag
          if (bMDTParsingEnabled == true) then
            bMDTParsingEnabled = false
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will NOT give any advanced parsing or output for the written-maps or 'map door text' commands [not recommended].")
          else
            bMDTParsingEnabled = true
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar WILL re-parse and highlight/score the written-maps and 'map door text' outputs for you [recommended].")
          end

        -- Show the hidden-room counts
        elseif (sRMBResult == "Show Zero-Score Room Counts") then
          -- Now enable/disable the priority tag
          if (bMDTShowEmptyRoomCount == true) then
            bMDTShowEmptyRoomCount = false
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will NOT show how many zero-score rooms were hidden from the written map lists.")
          else
            bMDTShowEmptyRoomCount = true
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar WILL show how many zero-score rooms were hidden from the written map lists.")
          end

        -- Reverse MDT ordering
        elseif (sRMBResult == "Reverse 'map door text' Ordering") then
          -- Now enable/disable the priority tag
          if (bMDTReverseSortOrder == true) then
            bMDTReverseSortOrder = false
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will show the 'map door text' parsed output in the DEFAULT order.")
          else
            bMDTReverseSortOrder = true
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will show the 'map door text' parsed output in REVERSE order.")
          end

        -- Force MDT window word-wrapping for weirdos
        elseif (sRMBResult == "Force Window Word-Wrapping") then
          -- Now enable/disable the priority tag
          if (bMDTForceWordWrap == true) then
            bMDTForceWordWrap = false
            RedrawMDTWindow()
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will no longer try to force-wrap room-lines in the written-map window. [recommended]")
          else
            bMDTForceWordWrap = true
            RedrawMDTWindow()
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will now try to force-wrap room-lines (upwards) in the written-map window. [not recommended]")
          end

        -- Re-create default filters
        elseif (sRMBResult == "Restore Default Filters") then
          ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will now attempt to restore the default written-map MDT filters and highlights.  Note this WILL overwrite anything found with the same pattern-strings, but will NOT delete any others you may have created, you can delete those individually yourself if you need.")
          CallPlugin ("bfe35205f026786ea1d56e3b", "CreateMDTDefaults", "y")

        -- Change minimum score room visibility score
        elseif (string.sub(sRMBResult, 1, 32) == "Change Minimum Score Visibility ") then
          local sInputMDT = utils.inputbox("Enter a minimum total-room-score value a room must contain to not be hidden in the written map list.\n\nA default of 1 is recommended.\n", "Minimum Room Scores", tostring(iMDTMinimumScore), "", 12)
          if (sInputMDT ~= nil) then
            iMDTMinimumScore = tonumber(sInputMDT)
            if (iMDTMinimumScore == nil) then
              iMDTMinimumScore = 1
            end
            if (iMDTMinimumScore < -500) then
              iMDTMinimumScore = -500
            end
            if (iMDTMinimumScore > 500) then
              iMDTMinimumScore = 500
            end
            ReSortMDTRooms()
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will now hide written-map MDT rooms that have a total-room-score below " .. tostring(iMDTMinimumScore) .. ".")
          end

        -- Change default entity score
        elseif (string.sub(sRMBResult, 1, 28) == "Change Default Entity Score ") then
          local sInputMDT = utils.inputbox("Enter a default score for all entities in a room that DON'T match a specific MDT filter to be worth.\n\nA default of 1 is recommended.\n", "Default MDT Score", tostring(iMDTDefaultValue), "", 12)
          if (sInputMDT ~= nil) then
            iMDTDefaultValue = tonumber(sInputMDT)
            if (iMDTDefaultValue == nil) then
              iMDTDefaultValue = 1
            end
            if (iMDTDefaultValue < -500) then
              iMDTDefaultValue = -500
            end
            if (iMDTDefaultValue > 500) then
              iMDTDefaultValue = 500
            end
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar will give a written-map score default of " .. tostring(iMDTDefaultValue) .. " to every entity that does not match a specific MDT filter.")
          end

        -- Create a whole new filter
        elseif (sRMBResult == "Add New MDT Filter") then
          local objNewMDT = {["match_text"] = "", ["category"] = "", ["colour"] = "", ["score"] = 0, ["matchtype"] = 0, ["map_region"] = 0}
          local bContinueMaking = true
          local sNewMDTFilterChoices = {
            [1] = "1: Simple word or string match eg 'Imperial Guard' or 'Royal'",
            [2] = "2: Advanced regex match eg '^(fang|hong) noblem(an|en)$'",
            [3] = "3: Colour match against Discworld name colours"
          }
          local iNewMDTMatchType = utils.listbox("Select the match type for a new MDT filter.\n\nOption 1 is for basic generic matches for simple names.\nOption 2 is for advanced matching and filtering.\nOption 3 can be used to match things based on your 'options colour playername/playerkiller/groupmember' settings.\n", "MDT Match Type", sNewMDTFilterChoices)
          if (iNewMDTMatchType ~= nil) then
            iNewMDTMatchType = tonumber(iNewMDTMatchType)
            if (iNewMDTMatchType == 1) then
              -- Basic pattern match
              sMDTTriggerText = utils.inputbox("Enter your basic match-text for a new MDT filter.\n\nNote that names get forced to lowercase, and 'quantities' at the start ('an ', 'a ', 'the ', 'four ') removed, but pluralisation at the end is not removed, example enemy strings could be one of:\nroyal guard\nlarge hong bodyguards\nceremonial sentries\n\nExample basic match-texts could be:\nimperial guard\ngrflx\n", "MDT Match Text", "", "", 12)
              if (sMDTTriggerText ~= nil) then
                sMDTTriggerText = string.lower(sMDTTriggerText)
                objNewMDT["match_text"] = sMDTTriggerText
                objNewMDT["matchtype"] = 0
                objNewMDT["regex"] = ""
              else
                bContinueMaking = false
              end
            elseif (iNewMDTMatchType == 2) then
              -- Advanced regex match
              sMDTTriggerText = utils.inputbox("Enter your advanced RegEx match-text for a new MDT filter.  This must be a valid RegEx pattern.\n\nNote that names get forced to lowercase, and 'quantities' at the start ('an ', 'a ', 'the ', 'four ') removed, but pluralisation at the end is not removed, example enemy strings could be one of:\nroyal guard\nlarge hong bodyguards\nceremonial sentries\n\nAn example RegEx match-text could be:\n^(fang|hong|tang) captains?$\n", "RegEx Trigger Modify", sReplacementText, "", 12)
              if (sMDTTriggerText ~= nil) then
                local sTestRex = rex.new(sMDTTriggerText)
                if (sTestRex) then
                  -- Is Valid
                  objNewMDT["match_text"] = sMDTTriggerText
                  objNewMDT["matchtype"] = 1
                  objNewMDT["regex"] = ""
                else
                  -- Not valid
                  bContinueMaking = false
                end
              else
                bContinueMaking = false
              end
            elseif (iNewMDTMatchType == 3) then
              -- Exact colour match
              local iNewColour = PickColour(255)
              if (iNewColour ~= -1) then
                objNewMDT["match_text"] = RGBColourToName(iNewColour)
                objNewMDT["matchtype"] = 2
                objNewMDT["regex"] = ""
              else
                bContinueMaking = false
              end
            end
          else
            bContinueMaking = false
          end
          -- Type & match-text/data picked, now score
          if (bContinueMaking == true) then
            local sInputMDT = utils.inputbox("Enter a score for each entity matching your new filter to be worth.\n\nScores add up to a total 'room-score', and the written-map window and 'map door text' output is ordered based on these final room scores.\n", "MDT Score Value", "1", "", 12)
            if (sInputMDT ~= nil) then
              local iThisMDTValue = tonumber(sInputMDT)
              if (iThisMDTValue == nil) then
                iThisMDTValue = 1
              end
              if (iThisMDTValue < -500) then
                iThisMDTValue = -500
              end
              if (iThisMDTValue > 500) then
                iThisMDTValue = 500
              end
              objNewMDT["score"] = iThisMDTValue
            else
              bContinueMaking = false
            end
          end
          -- Score picked, now colour
          if (bContinueMaking == true) then
            local sColourChoices = {[1] = "No re-colouring", [2] = "Pick a colour"}
            local sColourChoice = utils.listbox("Pick whether you want this MDT filter to have a colour change, or not.\n\nNOTE: This re-colouring is only in the written-map window, and the modified output of 'map door text', it is NOT a highlighter/trigger for all MUD output.\n", "MDT Colouring Change:", sColourChoices, 1)
            if (sColourChoice ~= nil) then
              sColourChoice = tonumber(sColourChoice)
              if (sColourChoice == 1) then
                objNewMDT["colour"] = ""
              else
                local iNewColour = PickColour(0)
                if (iNewColour ~= -1) then
                  objNewMDT["colour"] = RGBColourToName(iNewColour)
                else
                  bContinueMaking = false
                end
              end
            else
              bContinueMaking = false
            end
          end
          -- Colour picked, now category
          if (bContinueMaking == true) then
            local iCatCount, iCurCat, sCatChoices = 0, 0, {[0] = "Always On - No Category"}
            for sCatName, _ in pairs(sMDTCategories) do
              iCatCount = iCatCount + 1
              sCatChoices[iCatCount] = sCatName
              if (objNewMDT["category"] ~= "" and objNewMDT["category"] == sCatName) then
                iCurCat = iCatCount
              end
            end
            local sCatSwitchChoice = utils.listbox("Select Always On or a specific category for this new MDT filter to be limited to.\n", "MDT Category Choice:", sCatChoices, 0)
            if (sCatSwitchChoice ~= nil) then
              sCatSwitchChoice = tonumber(sCatSwitchChoice)
              if (sCatSwitchChoice == 0 or sCatChoices[sCatSwitchChoice] ~= nil) then
                if (sCatSwitchChoice == 0) then
                  sCatSwitchChoice = ""
                else
                  sCatSwitchChoice = sCatChoices[sCatSwitchChoice]
                end
                objNewMDT["category"] = sCatSwitchChoice
              else
                bContinueMaking = false
              end
            else
              bContinueMaking = false
            end
          end
          -- Category picked, now map-region
          if (bContinueMaking == true) then
            local sMapChoices = {[0] = "- Global / No Area Match"}
            for iCheckMap, objThisMapFile in pairs(sQuowMapfiles) do
              if (iCheckMap < 99) then
                sMapChoices[iCheckMap] = objThisMapFile[2]
              end
            end
            local sMapSwitchChoice = utils.listbox("Select Global or a specific map or region for this new MDT filter to be limited to.\n\nNote that for 'main areas' such as the core Ankh-Morpork map it will also match on any 'sub-maps' in those areas (eg AM Buildings map will match for Ankh-Morpork region)\n", "MDT Map-Region Limit:", sMapChoices, 0)
            if (sMapSwitchChoice ~= nil) then
              sMapSwitchChoice = tonumber(sMapSwitchChoice)
              if (sMapSwitchChoice == 0 or sQuowMapfiles[sMapSwitchChoice] ~= nil) then
                objNewMDT["map_region"] = sMapSwitchChoice
              else
                bContinueMaking = false
              end
            else
              bContinueMaking = false
            end
          end
          -- So, we should have everything, or have cancelled at some stage
          if (bContinueMaking == true) then
            -- Finalise build
            iMDTResult = InsertMDTEntry(objNewMDT, false)
          else
            Note("Your new MDT filter was cancelled or had problems, and was not created.")
          end

        -- Delete a filter
        elseif (sRMBResult == "Delete MDT Filter") then
          local sMDTDeleteChoices = {}
          for iMDTID, objMDT in pairs(sMDTData) do
            sMDTDeleteChoices[iMDTID] = objMDT["match_text"]
            if (objMDT["matchtype"] == 2) then
              sMDTDeleteChoices[iMDTID] = " (Colour Match: " .. sMDTDeleteChoices[iMDTID] .. ")"
            else
              if (objMDT["map_region"] > 0) then
                sMDTDeleteChoices[iMDTID] = "[" .. sQuowMapfiles[objMDT["map_region"]][7] .. "] " .. sMDTDeleteChoices[iMDTID]
              else
                sMDTDeleteChoices[iMDTID] = "[ global ] " .. sMDTDeleteChoices[iMDTID]
              end
            end
          end
          local sMDTDeleteOption = utils.listbox("Select an MDT filter to delete.\n", "MDT Deletion:", sMDTDeleteChoices, 0)
          if (sMDTDeleteOption ~= nil) then
            local iDeleteMDT = tonumber(sMDTDeleteOption)
            if (sMDTData[iDeleteMDT] ~= nil) then
              local sDeleteThisMDT = sMDTData[iDeleteMDT]["match_text"]
              CallPlugin ("bfe35205f026786ea1d56e3b", "RemoveMDTEntry", iDeleteMDT)
              ColourNote(sCOLOUR.orange, "", "An MDT filter has been deleted.  The match/filter string was: " .. sDeleteThisMDT)
            end
          else
            Note("MDT filter deletion cancelled.")
          end

        -- Change a colour
        elseif (sRMBResult == "Change MDT Colour") then
          local sMDTChoices = {}
          for iMDTID, objMDT in pairs(sMDTData) do
            sMDTChoices[iMDTID] = objMDT["match_text"]
            if (objMDT["matchtype"] == 2) then
              sMDTChoices[iMDTID] = " (Colour Match: " .. sMDTChoices[iMDTID] .. ")"
            else
              if (objMDT["map_region"] > 0) then
                sMDTChoices[iMDTID] = "[" .. sQuowMapfiles[objMDT["map_region"]][7] .. "] " .. sMDTChoices[iMDTID]
              else
                sMDTChoices[iMDTID] = "[ global ] " .. sMDTChoices[iMDTID]
              end
            end
          end
          local sMDTChangeOption = utils.listbox("Select an MDT filter to change the colouring of.\n", "MDT Colouring Change:", sMDTChoices, 0)
          if (sMDTChangeOption ~= nil) then
            local iThisMDT = tonumber(sMDTChangeOption)
            if (sMDTData[iThisMDT] ~= nil) then
              -- Do the thing here
              local iCurColourChoice = 2
              if (sMDTData[iThisMDT]["colour"] == "") then
                iCurColourChoice = 1
              end
              local sColourChoices = {[1] = "No re-colouring", [2] = "Pick a colour"}
              local sColourChoice = utils.listbox("Pick whether you want this MDT filter to have a colour change, or not.\n\nNOTE: This re-colouring is only in the written-map window, and the modified output of 'map door text', it is NOT a highlighter/trigger for all MUD output.\n", "MDT Colouring Change:", sColourChoices, iCurColourChoice)
              if (sColourChoice ~= nil) then
                sColourChoice = tonumber(sColourChoice)
                if (sColourChoice == 1) then
                  assert(dbUserData:execute("UPDATE user_mdt SET colour='' WHERE mdt_id=" .. iThisMDT))
                  sMDTData[iThisMDT]["colour"] = ""
                  ColourNote(sCOLOUR.orange, "", "Your MDT filter will NOT be re-coloured, for the match: " .. sMDTData[iThisMDT]["match_text"])
                else
                  local iNewColour = PickColour(ColourNameToRGB(sMDTData[iThisMDT]["colour"]))
                  if (iNewColour ~= -1) then
                    sMDTData[iThisMDT]["colour"] = RGBColourToName(iNewColour)
                    assert(dbUserData:execute("UPDATE user_mdt SET colour='" .. EscapeSQL(sMDTData[iThisMDT]["colour"]) .. "' WHERE mdt_id=" .. iThisMDT))
                    ColourTell(sCOLOUR.silver, "", "The colour for MDT match '")
                    ColourTell(sMDTData[iThisMDT]["colour"], "", sMDTData[iThisMDT]["match_text"])
                    ColourNote(sCOLOUR.silver, "", "' has been updated.")
                  else
                    Note("MDT colour selection change cancelled.")
                  end
                end
              else
                Note("MDT colour selection change cancelled.")
              end
            end
          else
            Note("MDT colour selection change cancelled.")
          end

        -- Change a score
        elseif (sRMBResult == "Change MDT Score") then
          local sMDTChoices = {}
          for iMDTID, objMDT in pairs(sMDTData) do
            sMDTChoices[iMDTID] = objMDT["match_text"]
            if (objMDT["matchtype"] == 2) then
              sMDTChoices[iMDTID] = " (Colour Match: " .. sMDTChoices[iMDTID] .. ")"
            else
              if (objMDT["map_region"] > 0) then
                sMDTChoices[iMDTID] = "[" .. sQuowMapfiles[objMDT["map_region"]][7] .. "] " .. sMDTChoices[iMDTID]
              else
                sMDTChoices[iMDTID] = "[ global ] " .. sMDTChoices[iMDTID]
              end
            end
          end
          local sMDTChangeOption = utils.listbox("Select an MDT filter to change the score of.\n", "MDT Score Change:", sMDTChoices, 0)
          if (sMDTChangeOption ~= nil) then
            local iThisMDT = tonumber(sMDTChangeOption)
            if (sMDTData[iThisMDT] ~= nil) then
              -- Do the thing here
              local sInputMDT = utils.inputbox("Enter a score for each entity matching that filter to be worth.\n\nScores add up to a total 'room-score', and the written-map window and 'map door text' output is ordered based on these final room scores.\n", "MDT Score Value", tostring(sMDTData[iThisMDT]["score"]), "", 12)
              if (sInputMDT ~= nil) then
                local iThisMDTValue = tonumber(sInputMDT)
                if (iThisMDTValue == nil) then
                  iThisMDTValue = 1
                end
                if (iThisMDTValue < -500) then
                  iThisMDTValue = -500
                end
                if (iThisMDTValue > 500) then
                  iThisMDTValue = 500
                end
                assert(dbUserData:execute("UPDATE user_mdt SET score='" .. iThisMDTValue .. "' WHERE mdt_id=" .. iThisMDT))
                sMDTData[iThisMDT]["score"] = iThisMDTValue
                ColourNote(sCOLOUR.orange, "", "Entities will be worth " .. iThisMDTValue .. " score each, for the match: " .. sMDTData[iThisMDT]["match_text"])  
              else
                Note("MDT score change cancelled.")
              end
            end
          else
            Note("MDT score change cancelled.")
          end

        -- Change a trigger text
        elseif (sRMBResult == "Change MDT Trigger") then
          local sMDTChoices = {}
          for iMDTID, objMDT in pairs(sMDTData) do
            sMDTChoices[iMDTID] = objMDT["match_text"]
            if (objMDT["matchtype"] == 2) then
              sMDTChoices[iMDTID] = " (Colour Match: " .. sMDTChoices[iMDTID] .. ")"
            else
              if (objMDT["map_region"] > 0) then
                sMDTChoices[iMDTID] = "[" .. sQuowMapfiles[objMDT["map_region"]][7] .. "] " .. sMDTChoices[iMDTID]
              else
                sMDTChoices[iMDTID] = "[ global ] " .. sMDTChoices[iMDTID]
              end
            end
          end
          local sMDTChangeOption = utils.listbox("Select an MDT filter to change the match-pattern of.\n", "MDT Match Change:", sMDTChoices)
          if (sMDTChangeOption ~= nil) then
            local iThisMDT = tonumber(sMDTChangeOption)
            local sOldPattern, iOldType = sMDTData[iThisMDT]["match_text"], sMDTData[iThisMDT]["matchtype"]
            local sReplacementText = ""
            if (iOldType == 0 or iOldType == 1) then
              sReplacementText = sMDTData[iThisMDT]["match_text"]
            else
              sReplacementText = ""
            end
            if (sMDTData[iThisMDT] ~= nil) then
              -- Do the thing here
              local sNewMDTFilterChoices = {
                [1] = "1: Simple word or string match eg 'Imperial Guard' or 'Royal'",
                [2] = "2: Advanced regex match eg '^(fang|hong) noblem(an|en)$'",
                [3] = "3: Colour match against Discworld name colours"
              }
              local iNewMDTMatchType = utils.listbox("Select the match type for this MDT filter.\n\nOption 1 is for basic generic matches for simple names.\nOption 2 is for advanced matching and filtering.\nOption 3 can be used to match things based on your 'options colour playername/playerkiller/groupmember' settings.\n", "MDT Match Type", sNewMDTFilterChoices, (iOldType + 1))
              if (iNewMDTMatchType ~= nil) then
                iNewMDTMatchType = tonumber(iNewMDTMatchType)
                if (iNewMDTMatchType == 1) then
                  -- Basic pattern match
                  sMDTTriggerText = utils.inputbox("Modify your basic match-text for this MDT filter.\n\nNote that names get forced to lowercase, and 'quantities' at the start ('an ', 'a ', 'the ', 'four ') removed, but pluralisation at the end is not removed, for example enemy strings could be one of:\nroyal guard\nlarge hong bodyguards\nceremonial sentries\n\nExample basic match-texts could be:\nimperial guard\ngrflx\n", "MDT Match Text", sReplacementText, "", 12)
                  if (sMDTTriggerText ~= nil) then
                    sMDTTriggerText = string.lower(sMDTTriggerText)
                    sMDTData[iThisMDT]["match_text"] = sMDTTriggerText
                    sMDTData[iThisMDT]["matchtype"] = 0
                    sMDTData[iThisMDT]["regex"] = ""
                    assert(dbUserData:execute("UPDATE user_mdt SET match_text='" .. EscapeSQL(sMDTTriggerText) .. "', matchtype=0 WHERE mdt_id=" .. iThisMDT))
                    ColourNote(sCOLOUR.orange, "", "Your MDT match-text filter has now been changed, to this filter: " .. sMDTTriggerText)
                    if (sReplacementText ~= "") then
                      ColourNote(sCOLOUR.silver, "", "  (previously the match-text was: " .. sReplacementText .. ")")
                    end
                  else
                    Note("MDT match pattern/filter change cancelled.")
                  end
                elseif (iNewMDTMatchType == 2) then
                  -- Advanced regex match
                  sMDTTriggerText = utils.inputbox("Modify your advanced RegEx match-text for this MDT filter.  This must be a valid RegEx pattern.\n\nNote that names get forced to lowercase, and 'quantities' at the start ('an ', 'a ', 'the ', 'four ') removed, but pluralisation at the end is not removed, for example enemy strings could be one of:\nroyal guard\nlarge hong bodyguards\nceremonial sentries\n\nAn example RegEx match-text could be:\n^(fang|hong|tang) captains?$\n", "RegEx Trigger Modify", sReplacementText, "", 12)
                  if (sMDTTriggerText ~= nil) then
                    local sTestRex = rex.new(sMDTTriggerText)
                    if (sTestRex) then
                      -- Is Valid
                      sMDTData[iThisMDT]["match_text"] = sMDTTriggerText
                      sMDTData[iThisMDT]["matchtype"] = 1
                      sMDTData[iThisMDT]["regex"] = rex.new(sMDTData[iThisMDT]["match_text"])
                      assert(dbUserData:execute("UPDATE user_mdt SET match_text='" .. EscapeSQL(sMDTTriggerText) .. "', matchtype=1 WHERE mdt_id=" .. iThisMDT))
                      ColourNote(sCOLOUR.orange, "", "Your MDT match-text filter has now been changed, to this RegEx filter: " .. sMDTTriggerText)
                      if (sReplacementText ~= "") then
                        ColourNote(sCOLOUR.silver, "", "  (previously the match-text was: " .. sReplacementText .. ")")
                      end
                    else
                      -- Not valid
                      ColourNote(sCOLOUR.orange, "", "Your advanced RegEx MDT filter text was not modified, there was an error code meaning it was not a valid RegEx pattern.")
                      Note("Your attempted match text was: " .. sMDTTriggerText)
                    end
                  else
                    Note("MDT match pattern/filter change cancelled.")
                  end
                elseif (iNewMDTMatchType == 3) then
                  -- Exact colour match
                  local iTempColour = 0
                  if (iOldType == 2) then
                    iTempColour = ColourNameToRGB(sOldPattern)
                  end
                  local iNewColour = PickColour(iTempColour)
                  if (iNewColour ~= -1) then
                    sMDTData[iThisMDT]["match_text"] = RGBColourToName(iNewColour)
                    sMDTData[iThisMDT]["matchtype"] = 2
                    sMDTData[iThisMDT]["regex"] = ""
                    assert(dbUserData:execute("UPDATE user_mdt SET match_text='" .. EscapeSQL(sMDTData[iThisMDT]["match_text"]) .. "', matchtype=2 WHERE mdt_id=" .. iThisMDT))
                    ColourNote(sCOLOUR.orange, "", "Your MDT match-text filter has now been changed, to match ", sMDTData[iThisMDT]["match_text"], "", "names in this colour (" .. sMDTData[iThisMDT]["match_text"] .. ")")
                    if (sReplacementText ~= "") then
                      ColourNote(sCOLOUR.silver, "", "  (previously the match-text was: " .. sReplacementText .. ")")
                    end
                  else
                    Note("MDT match pattern/filter change cancelled.")
                  end
                end
              else
                Note("MDT match pattern/filter change cancelled.")
              end
            end
          else
            Note("MDT match pattern/filter change cancelled.")
          end

        -- Change a category
        elseif (sRMBResult == "Change MDT Category") then
          local sMDTChoices = {}
          for iMDTID, objMDT in pairs(sMDTData) do
            sMDTChoices[iMDTID] = objMDT["match_text"]
            if (objMDT["matchtype"] == 2) then
              sMDTChoices[iMDTID] = " (Colour Match: " .. sMDTChoices[iMDTID] .. ")"
            else
              if (objMDT["map_region"] > 0) then
                sMDTChoices[iMDTID] = "[" .. sQuowMapfiles[objMDT["map_region"]][7] .. "] " .. sMDTChoices[iMDTID]
              else
                sMDTChoices[iMDTID] = "[ global ] " .. sMDTChoices[iMDTID]
              end
            end
          end
          local sMDTChangeOption = utils.listbox("Select an MDT filter to change the category of.\n", "MDT Category Change:", sMDTChoices, 0)
          if (sMDTChangeOption ~= nil) then
            local iThisMDT = tonumber(sMDTChangeOption)
            if (sMDTData[iThisMDT] ~= nil) then
              -- Do the thing here
              local iCatCount, iCurCat, sCatChoices = 0, 0, {[0] = "Always On - No Category"}
              for sCatName, _ in pairs(sMDTCategories) do
                iCatCount = iCatCount + 1
                sCatChoices[iCatCount] = sCatName
                if (sMDTData[iThisMDT]["category"] ~= "" and sMDTData[iThisMDT]["category"] == sCatName) then
                  iCurCat = iCatCount
                end
              end
              local sCatSwitchChoice = utils.listbox("Select Always On or a specific category for this MDT filter to be limited to.\n", "MDT Category Choice:", sCatChoices, iCurCat)
              if (sCatSwitchChoice ~= nil) then
                sCatSwitchChoice = tonumber(sCatSwitchChoice)
                if (sCatSwitchChoice == 0 or sCatChoices[sCatSwitchChoice] ~= nil) then
                  if (sCatSwitchChoice == 0) then
                    sCatSwitchChoice = ""
                  else
                    sCatSwitchChoice = sCatChoices[sCatSwitchChoice]
                  end
                  assert(dbUserData:execute("UPDATE user_mdt SET category='" .. EscapeSQL(sCatSwitchChoice) .. "' WHERE mdt_id=" .. iThisMDT))
                  sMDTData[iThisMDT]["category"] = sCatSwitchChoice
                  if (sCatSwitchChoice == "") then
                    ColourNote(sCOLOUR.orange, "", "The MDT category has been set to always on/no category for the match: " .. sMDTData[iThisMDT]["match_text"])  
                  else
                    ColourNote(sCOLOUR.orange, "", "The MDT category has been set to '" .. sCatSwitchChoice .. "' for the match: " .. sMDTData[iThisMDT]["match_text"])  
                  end
                else
                  Note("MDT category change cancelled.")
                end
              else
                Note("MDT category change cancelled.")
              end
            end
          else
            Note("MDT category change cancelled.")
          end

        -- Change a map region
        elseif (sRMBResult == "Change MDT Map Region") then
          local sMDTChoices = {}
          for iMDTID, objMDT in pairs(sMDTData) do
            sMDTChoices[iMDTID] = objMDT["match_text"]
            if (objMDT["matchtype"] == 2) then
              sMDTChoices[iMDTID] = " (Colour Match: " .. sMDTChoices[iMDTID] .. ")"
            else
              if (objMDT["map_region"] > 0) then
                sMDTChoices[iMDTID] = "[" .. sQuowMapfiles[objMDT["map_region"]][7] .. "] " .. sMDTChoices[iMDTID]
              else
                sMDTChoices[iMDTID] = "[ global ] " .. sMDTChoices[iMDTID]
              end
            end
          end
          local sMDTChangeOption = utils.listbox("Select an MDT filter to change the map-region of.\n", "MDT Map-Region Change:", sMDTChoices, 0)
          if (sMDTChangeOption ~= nil) then
            local iThisMDT = tonumber(sMDTChangeOption)
            if (sMDTData[iThisMDT] ~= nil) then
              -- Do the thing here
              local sMapChoices = {[0] = "- Global / No Area Match"}
              for iCheckMap, objThisMapFile in pairs(sQuowMapfiles) do
                if (iCheckMap < 99) then
                  sMapChoices[iCheckMap] = objThisMapFile[2]
                end
              end
              local sMapSwitchChoice = utils.listbox("Select Global or a specific map or region for this MDT filter to be limited to.\n\nNote that for 'main areas' such as the core Ankh-Morpork map it will also match on any 'sub-maps' in those areas (eg AM Buildings map will match for Ankh-Morpork region)\n", "MDT Map-Region Limit:", sMapChoices, sMDTData[iThisMDT]["map_region"])
              if (sMapSwitchChoice ~= nil) then
                sMapSwitchChoice = tonumber(sMapSwitchChoice)
                if (sMapSwitchChoice == 0 or sQuowMapfiles[sMapSwitchChoice] ~= nil) then
                  assert(dbUserData:execute("UPDATE user_mdt SET map_region='" .. sMapSwitchChoice .. "' WHERE mdt_id=" .. iThisMDT))
                  sMDTData[iThisMDT]["map_region"] = sMapSwitchChoice
                  if (sMapSwitchChoice == 0) then
                    ColourNote(sCOLOUR.orange, "", "The MDT filter location will match anywhere/globally for the match: " .. sMDTData[iThisMDT]["match_text"])  
                  else
                    ColourNote(sCOLOUR.orange, "", "The MDT filter location will only match in map region '" .. sQuowMapfiles[sMapSwitchChoice][2] .. "' for the match: " .. sMDTData[iThisMDT]["match_text"])  
                  end
                else
                  Note("MDT map-region change cancelled.")
                end
              else
                Note("MDT map-region change cancelled.")
              end
            end
          else
            Note("MDT map-region change cancelled.")
          end

        -- Add a new category for MDT filters
        elseif (sRMBResult == "Add New MDT Category") then
          local sNewCategory = utils.inputbox("Enter a name for a new MDT filter category, using short simple text.\n\nYou will need to edit/create MDT filters afterwards to be linked to this category.\n", "MDT Category Create", "", "", 12)
          -- Remove junk characters
          if (sNewCategory ~= nil) then
            sNewCategory = sNewCategory:gsub('%W','')
          end
          if (sNewCategory ~= nil and sNewCategory ~= "") then
            -- Check it doesn't exist already
            local bAlreadyExists = false
            for sCatName, _ in pairs(sMDTCategories) do
              if (string.lower(sCatName) == string.lower(sNewCategory)) then
                bAlreadyExists = true
              end
            end
            if (bAlreadyExists == true) then
              Note("An MDT category with the name '" .. sNewCategory .. "' already exists.")
            else
              -- Make new category
              sMDTCategories[sNewCategory] = {false,}
              ColourNote(sCOLOUR.orange, "", "A new MDT category named '" .. sNewCategory .. "' has been created, you can now assign it to individual MDT filters.")  
            end
          else
            Note("MDT category creation cancelled.")
          end

        -- Rename an MDT category
        elseif (sRMBResult == "Rename MDT Category") then
          local iCatCount, sCatChoices = 0, {}
          for sCatName, _ in pairs(sMDTCategories) do
            iCatCount = iCatCount + 1
            sCatChoices[iCatCount] = sCatName
          end
          local sCatRenameChoice = utils.listbox("Select a category to rename - note that any MDT filters currently set to this category, will be changed to stay in the renamed category.\n\n", "MDT Category Rename:", sCatChoices, 0)
          if (sCatRenameChoice ~= nil) then
            sCatRenameChoice = sCatChoices[tonumber(sCatRenameChoice)]
            local sNewCategory = utils.inputbox("Enter a new name for the selected MDT filter category, using short simple text.\n\n", "MDT Category Rename", sCatRenameChoice, "", 12)
            -- Remove junk characters
            if (sNewCategory ~= nil) then
              sNewCategory = sNewCategory:gsub('%W','')
            end
            if (sNewCategory ~= nil and sNewCategory ~= "") then
              -- Check it doesn't exist already
              local bAlreadyExists = false
              for sCatName, _ in pairs(sMDTCategories) do
                if (string.lower(sCatName) == string.lower(sNewCategory)) then
                  bAlreadyExists = true
                end
              end
              if (bAlreadyExists == true) then
                Note("An MDT category with the name '" .. sNewCategory .. "' already exists, cancelling renaming of old MDT category named '" .. sCatRenameChoice .. "'")
              else
                -- Rename the old category
                if (sMDTCategories[sCatRenameChoice][1] == true) then
                  sMDTCategories[sNewCategory] = {true,}
                else
                  sMDTCategories[sNewCategory] = {false,}
                end
                sMDTCategories[sCatRenameChoice] = nil
                assert(dbUserData:execute("UPDATE user_mdt SET category='" .. EscapeSQL(sNewCategory) .. "' WHERE category='" .. EscapeSQL(sCatRenameChoice) .. "'"))
                local iRenamedMDT = 0
                for iMDTID, objMDT in pairs(sMDTData) do
                  if (objMDT["category"] == sCatRenameChoice) then
                    sMDTData[iMDTID]["category"] = sNewCategory
                    iRenamedMDT = iRenamedMDT + 1
                  end
                end
                ColourNote(sCOLOUR.orange, "", "The MDT category previously named '" .. sCatRenameChoice .. "' has been renamed to '" .. sNewCategory .. "', and " .. iRenamedMDT .. " MDT filters have been moved to the new name.")  
              end
            else
              Note("MDT category creation cancelled.")
            end
          else
            Note("MDT category renaming cancelled.")
          end

        -- Delete an MDT category
        elseif (sRMBResult == "Delete MDT Category") then
          local iCatCount, sCatChoices = 0, {}
          for sCatName, _ in pairs(sMDTCategories) do
            iCatCount = iCatCount + 1
            sCatChoices[iCatCount] = sCatName
          end
          local sCatDeletionChoice = utils.listbox("Select a category to delete - note that any MDT filters currently set to this category, will be changed to always-on, or no category.\n\nThis does NOT delete any actual MDT filters.\n", "MDT Category Deletion:", sCatChoices, 0)
          if (sCatDeletionChoice ~= nil) then
            sCatDeletionChoice = sCatChoices[tonumber(sCatDeletionChoice)]
            sMDTCategories[sCatDeletionChoice] = nil
            assert(dbUserData:execute("UPDATE user_mdt SET category='' WHERE category='" .. EscapeSQL(sCatDeletionChoice) .. "'"))
            local iClearedMDT = 0
            for iMDTID, objMDT in pairs(sMDTData) do
              if (objMDT["category"] == sCatDeletionChoice) then
                sMDTData[iMDTID]["category"] = ""
                iClearedMDT = iClearedMDT + 1
              end
            end
            ColourNote(sCOLOUR.orange, "", "The MDT category '" .. sCatDeletionChoice .. "' has been removed, and " .. tostring(iClearedMDT) .. " MDT entries have had their category cleared.")  
          else
            Note("MDT category deletion cancelled.")
          end

        -- Enable/Disable showing/matching a specific MDT category
        elseif (string.sub(sRMBResult, 1, 19) == "Show MDT Category: ") then
          sRMBResult = string.sub(sRMBResult, 20)
          if (sMDTCategories[sRMBResult] ~= nil) then
            if (sMDTCategories[sRMBResult][1] == false) then
              sMDTCategories[sRMBResult][1] = true
              Note("MDT matches in the category '" .. sRMBResult .. "' are now ENABLED")
            else
              sMDTCategories[sRMBResult][1] = false
              Note("MDT matches in the category '" .. sRMBResult .. "' are now DISABLED")
            end
          end


        -- *******************************
        -- * Hotspot window menu options *
        -- *******************************
        elseif (sRMBResult == "Delete Hotspot") then
          local sHotDeleteChoices = {}
          for iHotspotID, objHotspot in pairs(sHotspotData) do
            sHotDeleteChoices[iHotspotID] = objHotspot["hotspot_name"]
          end
          local sHotDeleteOption = utils.listbox("Select a hotspot to delete.\n", "Hotspot Deletion:", sHotDeleteChoices, 0)
          if (sHotDeleteOption ~= nil) then
            local iDeleteHotspot = tonumber(sHotDeleteOption)
            if (sHotspotData[iDeleteHotspot] ~= nil) then
              local sDeleteThisHotspot = sHotspotData[iDeleteHotspot]["hotspot_name"]
              CallPlugin ("bfe35205f026786ea1d56e3b", "QuowDeleteHotspotHandler", iDeleteHotspot)
              sHotspotData[iDeleteHotspot] = nil
              assert(dbUserData:execute("DELETE FROM user_hotspots WHERE hotspot_id=" .. iDeleteHotspot))
              ReSortHotspots()
              RedrawHotspotsWindow()
              ColourNote(sCOLOUR.orange, "", "The hotspot '" .. sDeleteThisHotspot .. "' has been deleted.")
            end
          else
            Note("Hotspot deletion cancelled.")
          end


        elseif (sRMBResult == "Group Sync Timer Share") then
          -- Group say sync data
          HotspotGroupSyncSend()

        elseif (sRMBResult == "Change Hotspot Colour") then
          -- Manually reset a specific timer to 0
          local sHotResetChoices = {}
          for iHotspotID, objHotspot in pairs(sHotspotData) do
            sHotResetChoices[iHotspotID] = objHotspot["hotspot_name"]
          end
          local sHotResetOption = utils.listbox("Select a hotspot to re-colour.\n", "Hotspot Colour:", sHotResetChoices, 0)
          if (sHotResetOption ~= nil) then
            local iRecolourHotspot = tonumber(sHotResetOption)
            FetchHotspotColour(iRecolourHotspot)
          end


        elseif (sRMBResult == "Reset Hotspot Timer") then
          -- Manually reset a specific timer to 0
          local sHotResetChoices = {}
          for iHotspotID, objHotspot in pairs(sHotspotData) do
            sHotResetChoices[iHotspotID] = objHotspot["hotspot_name"]
          end
          local sHotResetOption = utils.listbox("Select a hotspot to reset to 0 time.\n", "Hotspot Reset:", sHotResetChoices, 0)
          if (sHotResetOption ~= nil) then
            local iResetHotspot = tonumber(sHotResetOption)
            if (sHotspotData[iResetHotspot] ~= nil) then
              local iNowTime = os.time()
              sHotspotData[iResetHotspot]["time_seen"] = iNowTime
              if (sHotspotData[iResetHotspot]["timeafter_notify"] > 0) then
                sHotspotData[iResetHotspot]["notified"] = 0
              else
                sHotspotData[iResetHotspot]["notified"] = 1
              end
              ReSortHotspots()
              RedrawHotspotsWindow()
              Redraw()
            end
          end

        elseif (sRMBResult == "Prioritise Timer Screen Updates") then
          -- First re-check the timer situation
          CallPlugin ("bfe35205f026786ea1d56e3b", "QuowRefreshHotspotTimers")
          -- Now enable/disable the priority tag
          if (bHotspotsPrioritiseRedraw == true) then
            bHotspotsPrioritiseRedraw = false
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar has now DISABLED the prioritised timer updates.")
            ColourNote(sCOLOUR.silver, "", "The priority option tries to force-update the screen every second to help the timers tick 'smoother', visually.")
          else
            bHotspotsPrioritiseRedraw = true
            ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar has now ENABLED the prioritised timer updates.")
            ColourNote(sCOLOUR.silver, "", "The priority option tries to force-update the screen every second to help the timers tick 'smoother', visually.")
          end


        elseif (sRMBResult == "Show Notifications in Comms Window") then
          -- Now enable/disable the priority tag
          if (bHotspotsChatWindow == true) then
            bHotspotsChatWindow = false
            ColourNote(sCOLOUR.orange, "", "Hotspot timer notifications will NOT be sent to the comms window.")
          else
            bHotspotsChatWindow = true
            ColourNote(sCOLOUR.orange, "", "Hotspot timer notifications WILL be sent to the comms window.")
          end

        elseif (sRMBResult == "Export Hotspots to Clipboard") then
          -- Exporting hotspots to a jsonified shortlist
          local Hots = {}
          for iHotspotID, objHotspot in pairs(sHotspotData) do
            Hots[iHotspotID] = {
              objHotspot["hotspot_name"], 
              objHotspot["colour"],
              objHotspot["trigger_type"], 
              objHotspot["roomid_reset"],
              objHotspot["trigger_reset"],
              objHotspot["timeafter_notify"],
            }
          end
          SetClipboard("COWBARHOTEXPORT:" .. json.encode(Hots))
          ColourNote(sCOLOUR.orange, "", "Your hotspots have been copied to your clipboard for you to 'paste' to others, for example through tells or group chat or online.")

        elseif (sRMBResult == "Import Hotspots") then
          -- Importing hotspots
          local sHotspotImport = utils.inputbox("Please paste the FULL hotspot data starting with and including COWBARHOTEXPORT:\n", "Import Hotspots", "", "", 12)
          if (sHotspotImport ~= nil) then
            if (string.sub(sHotspotImport, 1, 16) == "COWBARHOTEXPORT:") then
              sHotspotImport = string.sub(sHotspotImport, 17)
              local objImportedHotspots = json.decode(sHotspotImport)
              local iOverwriteHots, iNewHots, iNotificationAfter, iAlreadyNotified, bNewHotspot = 0, 0, 0, 0, false
              if (objImportedHotspots ~= nil) then
                local iTempTime = os.time()
                
                local sHotspotUniqueNames = {}
                for iHotspotID, objHotspot in pairs(sHotspotData) do
                  sHotspotUniqueNames[string.lower(objHotspot["hotspot_name"])] = iHotspotID
                end

                for iHotspotID, objHotspot in pairs(objImportedHotspots) do
                  if (objHotspot[1] ~= nil and objHotspot[2] ~= nil and objHotspot[3] ~= nil and objHotspot[4] ~= nil and objHotspot[5] ~= nil and objHotspot[6] ~= nil) then
                    -- Find if we already have one by this name, re-import it, else pick a new blank hotspot ID  
                    local iUseHotspotID, bNewHotspot = 0, false

                    if (sHotspotUniqueNames[string.lower(objHotspot[1])] ~= nil) then
                      iUseHotspotID = sHotspotUniqueNames[string.lower(objHotspot[1])]
                    else
                      -- No name match, find a blank spot to import to
                      for iN = 1, 100 do
                        if (sHotspotData[iN] == nil) then
                          iUseHotspotID = iN
                          break
                        end
                      end
                    end

                    if (iUseHotspotID > 0) then
                      if (sHotspotData[iUseHotspotID] ~= nil) then
                        iOverwriteHots = iOverwriteHots + 1
                        CallPlugin ("bfe35205f026786ea1d56e3b", "QuowDeleteHotspotHandler", iUseHotspotID)
                      else
                        iNewHots = iNewHots + 1
                        bNewHotspot = true
                      end
                      iNotificationAfter = tonumber(objHotspot[6])
                      iAlreadyNotified = 0
                      if (iNotificationAfter == 0) then
                        iAlreadyNotified = 1
                      end
                      sHotspotData[iUseHotspotID] = {
                        ["hotspot_name"] = objHotspot[1], 
                        ["colour"] = tonumber(objHotspot[2]), 
                        ["trigger_type"] = tonumber(objHotspot[3]), 
                        ["roomid_reset"] = objHotspot[4],
                        ["trigger_reset"] = objHotspot[5],
                        ["time_seen"] = iTempTime,
                        ["timeafter_notify"] = iNotificationAfter,
                        ["notified"] = iAlreadyNotified,
                      }
                      CallPlugin ("bfe35205f026786ea1d56e3b", "QuowAddHotspotHandler", iUseHotspotID)
                      if (bNewHotspot == true) then
                        assert(dbUserData:execute("INSERT INTO user_hotspots (hotspot_id, hotspot_name, colour, trigger_type, roomid_reset, trigger_reset, time_seen, timeafter_notify, notified) VALUES (" .. iUseHotspotID .. ", '" .. EscapeSQL(objHotspot[1]) .. "', " .. tonumber(objHotspot[2]) .. ", " .. tonumber(objHotspot[3]) .. ", '" .. EscapeSQL(objHotspot[4]) .. "', '" .. EscapeSQL(objHotspot[5]) .. "', " .. iTempTime .. ", " .. iNotificationAfter .. ", " .. iAlreadyNotified .. ")"))
                      else
                        assert(dbUserData:execute("UPDATE user_hotspots SET hotspot_name='" .. EscapeSQL(objHotspot[1]) .. "', colour=" .. tonumber(objHotspot[2]) .. ", trigger_type=" .. tonumber(objHotspot[3]) .. ", roomid_reset='" .. EscapeSQL(objHotspot[4]) .. "', trigger_reset='" .. EscapeSQL(objHotspot[5]) .. "', time_seen=" .. iTempTime .. ", timeafter_notify=" .. iNotificationAfter .. ", notified=" .. iAlreadyNotified .. " WHERE hotspot_id=" .. iUseHotspotID))
                      end
                    end
                  end
                end
                ReSortHotspots()
                RedrawHotspotsWindow()
                ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar imported a total of " .. (iOverwriteHots + iNewHots) .. " hotspots (" .. iNewHots .. " new, " .. iOverwriteHots .. " overwritten)")
              else
                Note("Cow Bar Hotspot import cancelled - invalid text to import.")
              end
            else
              Note("Cow Bar Hotspot import cancelled - invalid text to import.")
            end
          else
            Note("Cow Bar Hotspot import cancelled.")
          end


        elseif (sRMBResult == "Output Hotspots To Screen") then
          CallPlugin ("bfe35205f026786ea1d56e3b", "HotspotOutputList")

        elseif (sRMBResult == "Modify Hotspot") then
          -- Modify a timer's name/timer/trigger-text
          local sHotspotUniqueNames = {}
          for iHotspotID, objHotspot in pairs(sHotspotData) do
            sHotspotUniqueNames[string.lower(objHotspot["hotspot_name"])] = iHotspotID
          end
          local sHotModifyChoices = {}
          for iHotspotID, objHotspot in pairs(sHotspotData) do
            sHotModifyChoices[iHotspotID] = objHotspot["hotspot_name"]
          end
          local sHotResetOption = utils.listbox("Select a hotspot to modify.\n", "Hotspot Modify:", sHotModifyChoices, 0)
          if (sHotResetOption ~= nil) then
            local iModifyHotspot = tonumber(sHotResetOption)
            if (sHotspotData[iModifyHotspot] ~= nil) then
              local sHotspotModifyName, iHotspotModifyNotification, sHotspotModifyTrigger = sHotspotData[iModifyHotspot]["hotspot_name"], sHotspotData[iModifyHotspot]["timeafter_notify"], sHotspotData[iModifyHotspot]["trigger_reset"]
              local sHotspotTriggerText = ""
              -- Name
              local sNewHotspotName = utils.inputbox("Modify the hotspot name or hit enter to keep the name as it is.\nNames should be short and must be unique.\n\nYou can modify timer notification times on the next screen.\n", "Modify Hotspot Name", sHotspotModifyName, "", 12)
              if (sNewHotspotName ~= nil and sNewHotspotName ~= sHotspotModifyName) then
                sNewHotspotName = string.gsub(sNewHotspotName, ",", " ")
                if (sHotspotUniqueNames[string.lower(sNewHotspotName)] == nil) then
                  sHotspotModifyName = sNewHotspotName
                else
                  ColourNote(sCOLOUR.orange, "", "Could not rename '", RGBColourToName(sHotspotData[iModifyHotspot]["colour"]), "", sHotspotData[iModifyHotspot]["hotspot_name"], sCOLOUR.orange, "", "' to '" .. sNewHotspotName .. "' as that name is already in use for another hotspot.")
                end
              end
              -- Trigger text
              if (sHotspotData[iModifyHotspot]["trigger_type"] == 3) then
                sHotspotTriggerText = utils.inputbox("Modify your basic MUSH-compatible trigger text for this hotspot.\n\nFor example:\n* kill*the GRFLX Queen\n", "Basic Trigger Modify", sHotspotModifyTrigger, "", 12)
                if (sHotspotTriggerText ~= nil) then
                  local iTrigError = AddTriggerEx("HotspotTestTrigger", sHotspotTriggerText, "", 16, -1, 0, "", "", 12, 20)
                  if (iTrigError ~= 0) then
                    ColourNote(sCOLOUR.orange, "", "Your basic hotspot trigger text was not modified, there was an error code with your new trigger.")
                    Note("Your modified trigger text was: " .. sHotspotTriggerText)
                    Note("And MUSHclient error code was: " .. iTrigError)
                  else
                    -- Valid trigger
                    DeleteTrigger("HotspotTestTrigger")
                    sHotspotModifyTrigger = sHotspotTriggerText
                  end
                end
              elseif (sHotspotData[iModifyHotspot]["trigger_type"] == 4) then
                sHotspotTriggerText = utils.inputbox("Modify your advanced RegEx MUSH-compatible trigger text for this hotspot.\n\nFor example:\n^.+ kills? the GRFLX Queen\\.$\n", "RegEx Trigger Modify", sHotspotModifyTrigger, "", 12)
                if (sHotspotTriggerText ~= nil) then
                  local iTrigError = AddTriggerEx("HotspotTestTrigger", sHotspotTriggerText, "", 32, -1, 0, "", "", 12, 20)
                  if (iTrigError ~= 0) then
                    ColourNote(sCOLOUR.orange, "", "Your advanced RegEx hotspot trigger text was not modified, there was an error code with your new trigger.")
                    Note("Your modified trigger text was: " .. sHotspotTriggerText)
                    Note("And MUSHclient error code was: " .. iTrigError)
                  else
                    -- Valid trigger
                    DeleteTrigger("HotspotTestTrigger")
                    sHotspotModifyTrigger = sHotspotTriggerText
                  end
                end
              end
              -- Notification timer
              local iAlreadyNotified = 0
              local iNotificationAfter = 0
              local sNotifyAfter = utils.inputbox("Modify the (optional) time in minutes for receiving a notification text after last resetting this hotspot, or 0 for none.\n\nFor example, if set to 15, then 15 minutes after last visiting this Hotspot you would get a notice.\nLeave at 0 for no notices.\n", "Reminder Notice Time", tostring(math.floor(iHotspotModifyNotification / 60)), "", 12)
              if (sNotifyAfter ~= nil) then
                -- Multiply by 60 seconds here, once on creation, rather than all the time elsewhere
                iNotificationAfter = math.floor(tonumber(sNotifyAfter)) * 60
                iHotspotModifyNotification = iNotificationAfter
              end
              if (iNotificationAfter == 0) then
                iAlreadyNotified = 1
              end
              -- Now modify the values
              sHotspotData[iModifyHotspot]["hotspot_name"] = sHotspotModifyName
              sHotspotData[iModifyHotspot]["trigger_reset"] = sHotspotModifyTrigger
              sHotspotData[iModifyHotspot]["timeafter_notify"] = iHotspotModifyNotification
              sHotspotData[iModifyHotspot]["notified"] = iAlreadyNotified
              -- Remake the triggers
              CallPlugin ("bfe35205f026786ea1d56e3b", "QuowDeleteHotspotHandler", iModifyHotspot)
              CallPlugin ("bfe35205f026786ea1d56e3b", "QuowAddHotspotHandler", iModifyHotspot)
              assert(dbUserData:execute("UPDATE user_hotspots SET hotspot_name='" .. EscapeSQL(sHotspotModifyName) .. "', trigger_reset='" .. EscapeSQL(sHotspotModifyTrigger) .. "', timeafter_notify=" .. iHotspotModifyNotification .. ", notified=" .. iAlreadyNotified .. " WHERE hotspot_id=" .. iModifyHotspot))
              ReSortHotspots()
              RedrawHotspotsWindow()
              ColourTell(sCOLOUR.silver, "", "You have successfully modified the hotspot '")
              ColourTell(RGBColourToName(sHotspotData[iModifyHotspot]["colour"]), "", sHotspotModifyName)
              ColourNote(sCOLOUR.silver, "", "'")
            end
          end

        elseif (sRMBResult == "Add New Hotspot") then
          -- Find a blank hotspot id and then try to create it
          local iNewBlankHotspotID = 0
          local sHotspotUniqueNames = {}
          for iN = 100, 1, -1 do
            if (sHotspotData[iN] == nil) then
              iNewBlankHotspotID = iN
            else
              sHotspotUniqueNames[string.lower(sHotspotData[iN]["hotspot_name"])] = 1
            end
          end
          if (iNewBlankHotspotID == 0) then
            ColourNote(sCOLOUR.red, "", "Quow's Cow Bar Error: Unable to make a new hotspot, you may be at the 100 hotspot limit.")
          else
            local sNewHotspotName = utils.inputbox("Enter a short and unique name for your new hotspot.\n\nFor example 'Shades'.\n", "New Hotspot Name", "", "", 12)
            if (sNewHotspotName ~= nil) then
              sNewHotspotName = string.gsub(sNewHotspotName, ",", " ")
              if (sHotspotUniqueNames[string.lower(sNewHotspotName)] == nil) then
                local sClickedHotspot = "non selected"
                if (sClickedRoomID ~= "" and sQuowLocationsByRoomID[sClickedRoomID] ~= nil) then
                  sClickedHotspot = sQuowLocationsByRoomID[sClickedRoomID][4]
                end
                local sTempThisTitle = sThisRoomTitle
                if (sTempThisTitle == nil or sTempThisTitle == "") then
                  sTempThisTitle = "no room detected"
                end
                local sNewHotspotChoices = {
                  [1] = "1: When LEAVING, CURRENT room (" .. sTempThisTitle .. ")",
                  [2] = "2: When LEAVING, selected/clicked room (" .. sClickedHotspot .. ")",
                  [3] = "3: When ENTERING, CURRENT room (" .. sTempThisTitle .. ")",
                  [4] = "4: When ENTERING, selected/clicked room (" .. sClickedHotspot .. ")",
                  [5] = "5: Simple MUSHclient trigger",
                  [6] = "6: Advanced regex MUSHclient trigger",
                }
                local iNewHotspotType = utils.listbox("Select the event type for resetting this hotspot timer.\n\nFor option 1, the room you are currently in is used.\nOption 2 is useful for basic MUSH triggers.\nOption 3 is for advanced MUSH triggers.\n", "Hotspot Trigger Type", sNewHotspotChoices, 1)
                local iRealHotspotType = 0
                local sHotspotTriggerRoomID = ""
                local sHotspotTriggerText = ""
                if (iNewHotspotType ~= nil) then
                  local bContinueCreation = false
                  if (iNewHotspotType == 1 or iNewHotspotType == 3) then
                    -- Current/Present location room
                    if (sQuowLocationsByRoomID[sCurrentRoomID] ~= nil) then
                      bContinueCreation = true
                      sHotspotTriggerRoomID = sCurrentRoomID
                    else
                      Note("Hotspot creation failed due to unrecognised room.  Try 'look'ing or moving to a room with a valid database connection.")
                      Note("(Note: If your 'current room' is not able to be recognised, try using a simple or advanced trigger text for the room's description or [shortinlong] instead!)")
                    end
                    if (iNewHotspotType == 1) then
                      iRealHotspotType = 1
                    else
                      iRealHotspotType = 2
                    end
                  elseif (iNewHotspotType == 2 or iNewHotspotType == 4) then
                    -- Clicked/selected room on map
                    if (sQuowLocationsByRoomID[sClickedRoomID] ~= nil) then
                      bContinueCreation = true
                      sHotspotTriggerRoomID = sClickedRoomID
                    else
                      Note("Hotspot creation failed due to unrecognised room.  Left click on a valid room on the graphical map first.")
                      Note("(Note: If you are unable to select the room you want, try using a simple or advanced trigger text for the room's description or [shortinlong] instead!)")
                    end
                    if (iNewHotspotType == 2) then
                      iRealHotspotType = 1
                    else
                      iRealHotspotType = 2
                    end
                  elseif (iNewHotspotType == 5) then
                    -- Basic trigger
                    iRealHotspotType = 3
                    sHotspotTriggerText = utils.inputbox("Enter your basic MUSH-compatible trigger text to reset this timer.\n\nFor example:\n* kill*the GRFLX Queen\n", "Basic Hotspot Trigger", "", "", 12)
                    if (sHotspotTriggerText ~= nil) then
                      local iTrigError = AddTriggerEx("HotspotTestTrigger", sHotspotTriggerText, "", 16, -1, 0, "", "", 12, 20)
                      if (iTrigError ~= 0) then
                        ColourNote(sCOLOUR.orange, "", "Hotspot creation cancelled, your basic trigger text was invalid and returned a MUSHclient error.")
                        Note("Your trigger text was: " .. sHotspotTriggerText)
                        Note("And MUSHclient error code was: " .. iTrigError)
                      else
                        -- Valid trigger
                        DeleteTrigger("HotspotTestTrigger")
                        bContinueCreation = true
                      end
                    else
                      Note("Hotspot creation cancelled, no basic trigger text was entered.")
                    end
                  elseif (iNewHotspotType == 6) then
                    -- Regex trigger
                    iRealHotspotType = 4
                    sHotspotTriggerText = utils.inputbox("Enter a valid, advanced RegEx MUSH-compatible trigger text to reset this timer.\n\nFor example:\n^.+ kills? the GRFLX Queen\\.$\n", "RegEx Hotspot Trigger", "", "", 12)
                    if (sHotspotTriggerText ~= nil) then
                      local iTrigError = AddTriggerEx("HotspotTestTrigger", sHotspotTriggerText, "", 32, -1, 0, "", "", 12, 20)
                      if (iTrigError ~= 0) then
                        ColourNote(sCOLOUR.orange, "", "Hotspot creation cancelled, your advanced regex trigger was invalid and returned a MUSHclient error.")
                        Note("Your trigger text was: " .. sHotspotTriggerText)
                        Note("And MUSHclient error code was: " .. iTrigError)
                      else
                        -- Valid trigger
                        DeleteTrigger("HotspotTestTrigger")
                        bContinueCreation = true
                      end
                    else
                      Note("Hotspot creation cancelled, no regex trigger text was entered.")
                    end
                  end
                  -- Get a notification time if wanted, and still creating
                  if (bContinueCreation == true) then
                    -- Ask if we want a notification text after X time since last timer reset
                    local iNotificationAfter = 0
                    local iAlreadyNotified = 0
                    local sNotifyAfter = utils.inputbox("Do you want a reminder for this hotspot after a certain number of minutes?\n\nEnter an (optional) time in minutes for receiving a notification text after last resetting this hotspot, or 0 for no additional reminders.\n\nFor example, if set to 15, then 15 minutes after last visiting this Hotspot you would get a reminder notice.\nLeave at 0 for no reminder notices.\n", "Reminder Notice Time", "0", "", 12)
                    if (sNotifyAfter ~= nil) then
                      -- Multiply by 60 seconds here, once on creation, rather than all the time elsewhere
                      iNotificationAfter = math.floor(tonumber(sNotifyAfter)) * 60
                    else
                      -- No notifications wanted
                      iNotificationAfter = 0
                    end
                    if (iNotificationAfter == 0) then
                      iAlreadyNotified = 1
                    end

                    -- Ask if they want to pick a new colour, or not
                    local iHotspotColour = 12632256

                    -- Finally, create the new hotspot
                    local iTempTime = os.time()
                    sHotspotData[iNewBlankHotspotID] = {
                      ["hotspot_name"] = sNewHotspotName,
                      ["colour"] = iHotspotColour,
                      ["trigger_type"] = iRealHotspotType, 
                      ["roomid_reset"] = sHotspotTriggerRoomID, 
                      ["trigger_reset"] = sHotspotTriggerText, 
                      ["time_seen"] = iTempTime,
                      ["timeafter_notify"] = iNotificationAfter,
                      ["notified"] = iAlreadyNotified,
                    }
                    assert(dbUserData:execute("INSERT INTO user_hotspots (hotspot_id, hotspot_name, colour, trigger_type, roomid_reset, trigger_reset, time_seen, timeafter_notify, notified) VALUES (" .. iNewBlankHotspotID .. ", '" .. EscapeSQL(sNewHotspotName) .. "', " .. iHotspotColour .. ", " .. iRealHotspotType .. ", '" .. EscapeSQL(sHotspotTriggerRoomID) .. "', '" .. EscapeSQL(sHotspotTriggerText) .. "', " .. iTempTime .. ", " .. iNotificationAfter .. ", " .. iAlreadyNotified .. ")"))
                    CallPlugin ("bfe35205f026786ea1d56e3b", "QuowAddHotspotHandler", iNewBlankHotspotID)
                    ReSortHotspots()
                    RedrawHotspotsWindow()
                    ColourTell(sCOLOUR.silver, "", "You have successfully created a new hotspot with the name '")
                    ColourTell(RGBColourToName(iHotspotColour), "", sNewHotspotName)
                    ColourNote(sCOLOUR.silver, "", "'")
                  end
                else
                  Note("Hotspot creation cancelled.")
                  Note("(Note: If your 'current room' is not able to be recognised, try using a simple or advanced trigger text for the room's description or [shortinlong] instead!)")
                end
              else
                Note("Hotspot creation failed, a hotspot with the short name '" .. sNewHotspotName .. "' already exists.")
              end
            else
              Note("Hotspot creation cancelled, no hotspot name was given.")
            end
          end

        -- ****************************
        -- * Stat window menu options *
        -- ****************************
        elseif (sRMBResult == "Optimize Plugin Combat Triggers") then
          if (bOptimisedCombatTriggers == false) then
            if (iMushclientVersion >= 4.89) then
              SendNoEcho("options colour combat=YELLOW")
              bOptimisedCombatTriggers = true
              ColourNote(sCOLOUR.orange, "", "Setting your Discworld-side combat options to YELLOW.")
              ColourNote(sCOLOUR.silver, "", "This allows the plugin to optimize triggers for detecting combat messages accurately, and will reduce plugin overhead from non-combat lines from the MUD.")
              ColourNote(sCOLOUR.cyan, "", "Important Note:  If you have alts, their colour option will also need to be set, or the plugin will ignore combat messages received when playing on them.")
              ColourNote(sCOLOUR.silver, "", "You can disable and re-enable this option once for each character to set their colours, or manually send 'options colour combat=YELLOW' on them once.")
              CallPlugin("bfe35205f026786ea1d56e3b", "QuowCombatOptimiseTriggers")
            else
              ColourNote(sCOLOUR.red, "", "Your MUSHclient is too old to support this optimization!")
              ColourNote(sCOLOUR.silver, "", "Unfortunately, only MUSHclient versions from 4.89 and above can support this feature.  You can upgrade from http://www.gammon.com.au/files/mushclient/?M=D")
              ColourNote(sCOLOUR.silver, "", "This optimization would prevent non-combat lines going through the large set of combat-stat related triggers, which helps reduce plugin overhead.")
              bOptimisedCombatTriggers = false
              CallPlugin("bfe35205f026786ea1d56e3b", "QuowCombatOptimiseTriggers")
            end
          else
            bOptimisedCombatTriggers = false
            SendNoEcho("options colour combat=WHITE")
            ColourNote(sCOLOUR.orange, "", "Your Discworld-side combat colour option has been set to 'WHITE'.")
            ColourNote(sCOLOUR.silver, "", "You can set it back to any colour you want with 'options colour combat=<colour>', if you wish to keep optimizations disabled.")
            ColourNote(sCOLOUR.silver, "", "The optimizations are heavily recommended if you are not disabling the combat stats module of this plugin.")
            CallPlugin("bfe35205f026786ea1d56e3b", "QuowCombatOptimiseTriggers")
          end

        elseif (sRMBResult == "Reset Current Set Stats") then
          local sPopupResult = utils.inputbox("Type 'yes' to completely reset and zero the current stat set " .. iCurrentCombatStatSet .. " ['" .. iQuowCombatStats[iCurrentCombatStatSet]["set_name"] .. "']\n\nIMPORTANT:  There is no retrieving lost stats if you reset them.\n", "Stat Set Reset", "", "", 12 )
          if (sPopupResult ~= nil and string.lower(sPopupResult) == "yes") then
            for sColumn, sData in pairs(iQuowCombatStats[iCurrentCombatStatSet]) do
              if (sColumn ~= "set_name" and sColumn ~= "gp_regen") then
                iQuowCombatStats[iCurrentCombatStatSet][sColumn] = 0
              end
            end
            RedrawStatsWindow()
            ColourNote(sCOLOUR.orange, "", "All of your combat sets for the currently selected set '" .. iQuowCombatStats[iCurrentCombatStatSet]["set_name"] .. "' have been reset to 0.")
          else
            Note("Stat set reset to zero cancelled.")
          end

        elseif (sRMBResult == "Rename Current Set") then
          QuowRenameStatSet()

        elseif (sRMBResult == "Generate Full Stat Report") then
          GenerateStatsReport()

        elseif (string.sub(sRMBResult, 1, 9) == "GP Regen ") then
          sRMBResult = string.sub(sRMBResult, 10)
          local iGPRegen = tonumber(sRMBResult)
          if (iGPRegen < 0) then
            iGPRegen = 0
          elseif (iGPRegen > 4) then
            iGPRegen = 4
          end
          if (iGPRegen ~= iQuowCombatStats[iCurrentCombatStatSet]["gp_regen"]) then
            iQuowCombatStats[iCurrentCombatStatSet]["gp_regen"] = iGPRegen
            ColourNote(sCOLOUR.orange, "", "The GP Regeneration rate of this set is now " .. iGPRegen .. " GP per heartbeat tick")
          end

        elseif (sRMBResult == "Switch Stat Set") then
          local sStatChoices = {}
          for iThisSet, sThisData in pairs(iQuowCombatStats) do
            sStatChoices[iThisSet] = "[Set " .. tostring(iThisSet) .. "] " .. iQuowCombatStats[iThisSet]["set_name"]
          end
          local sStatSwitchChoice = utils.listbox("Select a stat set to switch to.\n", "Stat Set Selection:", sStatChoices, iCurrentCombatStatSet)
          if (sStatSwitchChoice ~= nil) then
            if (iQuowCombatStats[tonumber(sStatSwitchChoice)] ~= nil) then
              QuowSwitchStatSet(tonumber(sStatSwitchChoice), false)
            end
          end

        elseif (sRMBResult == "Create New Stat Set") then
          -- Find a blank stat set and then try to switch to it, it will auto-create a new one
          local iNewBlankStatID = 0
          for iN = 1, 100 do
            if (iQuowCombatStats[iN] == nil) then
              iNewBlankStatID = iN
              break
            end
          end
          if (iNewBlankStatID == 0) then
            ColourNote(sCOLOUR.red, "", "Error: Unable to make a new combat stat set, you may be at the 100 stat set limit.")
          else
            QuowSwitchStatSet(iNewBlankStatID, false)
          end

        elseif (sRMBResult == "Delete Current Stat Set") then
          QuowDeleteStatSet(iCurrentCombatStatSet)

        elseif (sRMBResult == "Show message samples in output") then
          ColourNote(sCOLOUR.silver, "", "Displaying sample combat trigger colours:")
          ColourNote(sCOLOUR.silver, "", "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=")
          ColourNote(sUSER_OPTIONS["col_special_prep"], "",         "Sample:  You prepare to stab the enemy with your weapon.")
          ColourNote(sUSER_OPTIONS["col_special_fail"], "",         "Sample:  You attempt to stab the enemy but cannot find an opportunity.")
          ColourNote(sUSER_OPTIONS["col_special_out_fail"], "",     "Sample:  You attempt to launch a powerful attack, but the enemy parries the blow.")
          ColourNote(sUSER_OPTIONS["col_special_out_success"], "",  "Sample:  You launch a powerful attack and stab the enemy deeply with your weapon.")
          ColourNote(sUSER_OPTIONS["col_melee_out_fail"], "",       "Sample:  You cut at the enemy but they parry the blow.")
          ColourNote(sUSER_OPTIONS["col_melee_out_success"], "",    "Sample:  You slash the enemy in the face with your weapon.")
          ColourNote(sUSER_OPTIONS["col_melee_out_kill"], "",       "Sample:  You kill the enemy.")
          ColourNote(sUSER_OPTIONS["col_special_inc_fail"], "",     "Sample:  Enemy attempts to launch a powerful attack, but you dodge out of the way.")
          ColourNote(sUSER_OPTIONS["col_special_inc_success"], "",  "Sample:  Enemy launches a powerful attack and stabs you deeply with their weapon.")
          ColourNote(sUSER_OPTIONS["col_melee_inc_fail"], "",       "Sample:  Enemy cuts at you, but you dodge out of the way.")
          ColourNote(sUSER_OPTIONS["col_melee_inc_success"], "",    "Sample:  Enemy stabs you in the arm with their weapon.")
          ColourNote(sUSER_OPTIONS["col_melee_inc_kill"], "",       "Sample:  Enemy deals the death blow to you.")
          ColourNote(sUSER_OPTIONS["col_special_third_fail"], "",   "Sample:  The cow attempts to launch a powerful attack but the sheep frolics out of the way.")
          ColourNote(sUSER_OPTIONS["col_special_third_success"], "","Sample:  The cow launches a powerful attack and mashes the sheep's skull in.")
          ColourNote(sUSER_OPTIONS["col_melee_third_fail"], "",     "Sample:  The cow strikes at the sheep with a hoof, but it somehow avoids the attack.")
          ColourNote(sUSER_OPTIONS["col_melee_third_success"], "",  "Sample:  The cow crushes the sheep with it's hoofies.")
          ColourNote(sUSER_OPTIONS["col_melee_third_kill"], "",     "Sample:  The cow kills the sheep.")

        elseif (sRMBResult == "SHOW all combat messages") then
          sUSER_OPTIONS["omit_special_prep"] = "n"
          sUSER_OPTIONS["omit_special_fail"] = "n"
          sUSER_OPTIONS["omit_special_out_fail"] = "n"
          sUSER_OPTIONS["omit_special_out_success"] = "n"
          sUSER_OPTIONS["omit_melee_out_fail"] = "n"
          sUSER_OPTIONS["omit_melee_out_success"] = "n"
          sUSER_OPTIONS["omit_melee_out_kill"] = "n"
          sUSER_OPTIONS["omit_special_inc_fail"] = "n"
          sUSER_OPTIONS["omit_special_inc_success"] = "n"
          sUSER_OPTIONS["omit_melee_inc_fail"] = "n"
          sUSER_OPTIONS["omit_melee_inc_success"] = "n"
          sUSER_OPTIONS["omit_melee_inc_kill"] = "n"
          sUSER_OPTIONS["omit_special_third_fail"] = "n"
          sUSER_OPTIONS["omit_special_third_success"] = "n"
          sUSER_OPTIONS["omit_melee_third_fail"] = "n"
          sUSER_OPTIONS["omit_melee_third_success"] = "n"
          sUSER_OPTIONS["omit_melee_third_kill"] = "n"
          assert(dbUserData:execute("UPDATE user_options SET option_value='n' WHERE option_id IN ('omit_special_prep','omit_special_fail','omit_special_out_fail','omit_special_out_success','omit_melee_out_fail','omit_melee_out_success','omit_melee_out_kill','omit_special_inc_fail','omit_special_inc_success','omit_melee_inc_fail','omit_melee_inc_success','omit_melee_inc_kill','omit_special_third_fail','omit_special_third_success','omit_melee_third_fail','omit_melee_third_success','omit_melee_third_kill')"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "HIDE all combat messages") then
          sUSER_OPTIONS["omit_special_prep"] = "y"
          sUSER_OPTIONS["omit_special_fail"] = "y"
          sUSER_OPTIONS["omit_special_out_fail"] = "y"
          sUSER_OPTIONS["omit_special_out_success"] = "y"
          sUSER_OPTIONS["omit_melee_out_fail"] = "y"
          sUSER_OPTIONS["omit_melee_out_success"] = "y"
          sUSER_OPTIONS["omit_melee_out_kill"] = "y"
          sUSER_OPTIONS["omit_special_inc_fail"] = "y"
          sUSER_OPTIONS["omit_special_inc_success"] = "y"
          sUSER_OPTIONS["omit_melee_inc_fail"] = "y"
          sUSER_OPTIONS["omit_melee_inc_success"] = "y"
          sUSER_OPTIONS["omit_melee_inc_kill"] = "y"
          sUSER_OPTIONS["omit_special_third_fail"] = "y"
          sUSER_OPTIONS["omit_special_third_success"] = "y"
          sUSER_OPTIONS["omit_melee_third_fail"] = "y"
          sUSER_OPTIONS["omit_melee_third_success"] = "y"
          sUSER_OPTIONS["omit_melee_third_kill"] = "y"
          assert(dbUserData:execute("UPDATE user_options SET option_value='y' WHERE option_id IN ('omit_special_prep','omit_special_fail','omit_special_out_fail','omit_special_out_success','omit_melee_out_fail','omit_melee_out_success','omit_melee_out_kill','omit_special_inc_fail','omit_special_inc_success','omit_melee_inc_fail','omit_melee_inc_success','omit_melee_inc_kill','omit_special_third_fail','omit_special_third_success','omit_melee_third_fail','omit_melee_third_success','omit_melee_third_kill')"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Re-Colour DISABLE all") then
          sUSER_OPTIONS["nocol_special_prep"] = "0"
          sUSER_OPTIONS["nocol_special_fail"] = "0"
          sUSER_OPTIONS["nocol_special_out_fail"] = "0"
          sUSER_OPTIONS["nocol_special_out_success"] = "0"
          sUSER_OPTIONS["nocol_melee_out_fail"] = "0"
          sUSER_OPTIONS["nocol_melee_out_success"] = "0"
          sUSER_OPTIONS["nocol_melee_out_kill"] = "0"
          sUSER_OPTIONS["nocol_special_inc_fail"] = "0"
          sUSER_OPTIONS["nocol_special_inc_success"] = "0"
          sUSER_OPTIONS["nocol_melee_inc_fail"] = "0"
          sUSER_OPTIONS["nocol_melee_inc_success"] = "0"
          sUSER_OPTIONS["nocol_melee_inc_kill"] = "0"
          sUSER_OPTIONS["nocol_special_third_fail"] = "0"
          sUSER_OPTIONS["nocol_special_third_success"] = "0"
          sUSER_OPTIONS["nocol_melee_third_fail"] = "0"
          sUSER_OPTIONS["nocol_melee_third_success"] = "0"
          sUSER_OPTIONS["nocol_melee_third_kill"] = "0"
          assert(dbUserData:execute("UPDATE user_options SET option_value='0' WHERE option_id IN ('nocol_special_prep','nocol_special_fail','nocol_special_out_fail','nocol_special_out_success','nocol_melee_out_fail','nocol_melee_out_success','nocol_melee_out_kill','nocol_special_inc_fail','nocol_special_inc_success','nocol_melee_inc_fail','nocol_melee_inc_success','nocol_melee_inc_kill','nocol_special_third_fail','nocol_special_third_success','nocol_melee_third_fail','nocol_melee_third_success','nocol_melee_third_kill')"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour ENABLE all") then
          sUSER_OPTIONS["nocol_special_prep"] = "17"
          sUSER_OPTIONS["nocol_special_fail"] = "17"
          sUSER_OPTIONS["nocol_special_out_fail"] = "17"
          sUSER_OPTIONS["nocol_special_out_success"] = "17"
          sUSER_OPTIONS["nocol_melee_out_fail"] = "17"
          sUSER_OPTIONS["nocol_melee_out_success"] = "17"
          sUSER_OPTIONS["nocol_melee_out_kill"] = "17"
          sUSER_OPTIONS["nocol_special_inc_fail"] = "17"
          sUSER_OPTIONS["nocol_special_inc_success"] = "17"
          sUSER_OPTIONS["nocol_melee_inc_fail"] = "17"
          sUSER_OPTIONS["nocol_melee_inc_success"] = "17"
          sUSER_OPTIONS["nocol_melee_inc_kill"] = "17"
          sUSER_OPTIONS["nocol_special_third_fail"] = "17"
          sUSER_OPTIONS["nocol_special_third_success"] = "17"
          sUSER_OPTIONS["nocol_melee_third_fail"] = "17"
          sUSER_OPTIONS["nocol_melee_third_success"] = "17"
          sUSER_OPTIONS["nocol_melee_third_kill"] = "17"
          assert(dbUserData:execute("UPDATE user_options SET option_value='17' WHERE option_id IN ('nocol_special_prep','nocol_special_fail','nocol_special_out_fail','nocol_special_out_success','nocol_melee_out_fail','nocol_melee_out_success','nocol_melee_out_kill','nocol_special_inc_fail','nocol_special_inc_success','nocol_melee_inc_fail','nocol_melee_inc_success','nocol_melee_inc_kill','nocol_special_third_fail','nocol_special_third_success','nocol_melee_third_fail','nocol_melee_third_success','nocol_melee_third_kill')"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")

        -- Hiding text choices:
        elseif (sRMBResult == "Show: You prepare a special") then
          sUSER_OPTIONS["omit_special_prep"] = ((sUSER_OPTIONS["omit_special_prep"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_special_prep"]) .. "' WHERE option_id='omit_special_prep'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: You fail to prepare a special") then
          sUSER_OPTIONS["omit_special_fail"] = ((sUSER_OPTIONS["omit_special_fail"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_special_fail"]) .. "' WHERE option_id='omit_special_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: You special enemy but they defend") then
          sUSER_OPTIONS["omit_special_out_fail"] = ((sUSER_OPTIONS["omit_special_out_fail"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_special_out_fail"]) .. "' WHERE option_id='omit_special_out_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: You special and hurt enemy") then
          sUSER_OPTIONS["omit_special_out_success"] = ((sUSER_OPTIONS["omit_special_out_success"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_special_out_success"]) .. "' WHERE option_id='omit_special_out_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: You hit enemy but they defend") then
          sUSER_OPTIONS["omit_melee_out_fail"] = ((sUSER_OPTIONS["omit_melee_out_fail"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_melee_out_fail"]) .. "' WHERE option_id='omit_melee_out_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: You hit and hurt enemy") then
          sUSER_OPTIONS["omit_melee_out_success"] = ((sUSER_OPTIONS["omit_melee_out_success"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_melee_out_success"]) .. "' WHERE option_id='omit_melee_out_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: You kill enemy") then
          sUSER_OPTIONS["omit_melee_out_kill"] = ((sUSER_OPTIONS["omit_melee_out_kill"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_melee_out_kill"]) .. "' WHERE option_id='omit_melee_out_kill'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: Enemy specials you but you defend") then
          sUSER_OPTIONS["omit_special_inc_fail"] = ((sUSER_OPTIONS["omit_special_inc_fail"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_special_inc_fail"]) .. "' WHERE option_id='omit_special_inc_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: Enemy specials and hurts you") then
          sUSER_OPTIONS["omit_special_inc_success"] = ((sUSER_OPTIONS["omit_special_inc_success"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_special_inc_success"]) .. "' WHERE option_id='omit_special_inc_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: Enemy hits you but you defend") then
          sUSER_OPTIONS["omit_melee_inc_fail"] = ((sUSER_OPTIONS["omit_melee_inc_fail"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_melee_inc_fail"]) .. "' WHERE option_id='omit_melee_inc_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: Enemy hits and hurts you") then
          sUSER_OPTIONS["omit_melee_inc_success"] = ((sUSER_OPTIONS["omit_melee_inc_success"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_melee_inc_success"]) .. "' WHERE option_id='omit_melee_inc_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: Enemy kills you") then
          sUSER_OPTIONS["omit_melee_inc_kill"] = ((sUSER_OPTIONS["omit_melee_inc_kill"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_melee_inc_kill"]) .. "' WHERE option_id='omit_melee_inc_kill'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: Others special others who defend") then
          sUSER_OPTIONS["omit_special_third_fail"] = ((sUSER_OPTIONS["omit_special_third_fail"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_special_third_fail"]) .. "' WHERE option_id='omit_special_third_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: Others special and hurt others") then
          sUSER_OPTIONS["omit_special_third_success"] = ((sUSER_OPTIONS["omit_special_third_success"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_special_third_success"]) .. "' WHERE option_id='omit_special_third_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: Others hit others who defend") then
          sUSER_OPTIONS["omit_melee_third_fail"] = ((sUSER_OPTIONS["omit_melee_third_fail"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_melee_third_fail"]) .. "' WHERE option_id='omit_melee_third_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: Others hit and hurt others") then
          sUSER_OPTIONS["omit_melee_third_success"] = ((sUSER_OPTIONS["omit_melee_third_success"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_melee_third_success"]) .. "' WHERE option_id='omit_melee_third_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")
        elseif (sRMBResult == "Show: Others kill others") then
          sUSER_OPTIONS["omit_melee_third_kill"] = ((sUSER_OPTIONS["omit_melee_third_kill"] ~= "y") and "y" or "n")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["omit_melee_third_kill"]) .. "' WHERE option_id='omit_melee_third_kill'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersShowHide", "", "")

        -- Don't custom colour these lines
        elseif (sRMBResult == "Re-Colour: You prepare a special") then
          sUSER_OPTIONS["nocol_special_prep"] = ((sUSER_OPTIONS["nocol_special_prep"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_special_prep"]) .. "' WHERE option_id='nocol_special_prep'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: You fail to prepare a special") then
          sUSER_OPTIONS["nocol_special_fail"] = ((sUSER_OPTIONS["nocol_special_fail"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_special_fail"]) .. "' WHERE option_id='nocol_special_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: You special enemy but they defend") then
          sUSER_OPTIONS["nocol_special_out_fail"] = ((sUSER_OPTIONS["nocol_special_out_fail"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_special_out_fail"]) .. "' WHERE option_id='nocol_special_out_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: You special and hurt enemy") then
          sUSER_OPTIONS["nocol_special_out_success"] = ((sUSER_OPTIONS["nocol_special_out_success"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_special_out_success"]) .. "' WHERE option_id='nocol_special_out_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: You hit enemy but they defend") then
          sUSER_OPTIONS["nocol_melee_out_fail"] = ((sUSER_OPTIONS["nocol_melee_out_fail"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_melee_out_fail"]) .. "' WHERE option_id='nocol_melee_out_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: You hit and hurt enemy") then
          sUSER_OPTIONS["nocol_melee_out_success"] = ((sUSER_OPTIONS["nocol_melee_out_success"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_melee_out_success"]) .. "' WHERE option_id='nocol_melee_out_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: You kill enemy") then
          sUSER_OPTIONS["nocol_melee_out_kill"] = ((sUSER_OPTIONS["nocol_melee_out_kill"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_melee_out_kill"]) .. "' WHERE option_id='nocol_melee_out_kill'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: Enemy specials you but you defend") then
          sUSER_OPTIONS["nocol_special_inc_fail"] = ((sUSER_OPTIONS["nocol_special_inc_fail"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_special_inc_fail"]) .. "' WHERE option_id='nocol_special_inc_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: Enemy specials and hurts you") then
          sUSER_OPTIONS["nocol_special_inc_success"] = ((sUSER_OPTIONS["nocol_special_inc_success"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_special_inc_success"]) .. "' WHERE option_id='nocol_special_inc_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: Enemy hits you but you defend") then
          sUSER_OPTIONS["nocol_melee_inc_fail"] = ((sUSER_OPTIONS["nocol_melee_inc_fail"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_melee_inc_fail"]) .. "' WHERE option_id='nocol_melee_inc_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: Enemy hits and hurts you") then
          sUSER_OPTIONS["nocol_melee_inc_success"] = ((sUSER_OPTIONS["nocol_melee_inc_success"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_melee_inc_success"]) .. "' WHERE option_id='nocol_melee_inc_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: Enemy kills you") then
          sUSER_OPTIONS["nocol_melee_inc_kill"] = ((sUSER_OPTIONS["nocol_melee_inc_kill"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_melee_inc_kill"]) .. "' WHERE option_id='nocol_melee_inc_kill'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: Others special others who defend") then
          sUSER_OPTIONS["nocol_special_third_fail"] = ((sUSER_OPTIONS["nocol_special_third_fail"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_special_third_fail"]) .. "' WHERE option_id='nocol_special_third_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: Others special and hurt others") then
          sUSER_OPTIONS["nocol_special_third_success"] = ((sUSER_OPTIONS["nocol_special_third_success"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_special_third_success"]) .. "' WHERE option_id='nocol_special_third_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: Others hit others who defend") then
          sUSER_OPTIONS["nocol_melee_third_fail"] = ((sUSER_OPTIONS["nocol_melee_third_fail"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_melee_third_fail"]) .. "' WHERE option_id='nocol_melee_third_fail'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: Others hit and hurt others") then
          sUSER_OPTIONS["nocol_melee_third_success"] = ((sUSER_OPTIONS["nocol_melee_third_success"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_melee_third_success"]) .. "' WHERE option_id='nocol_melee_third_success'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")
        elseif (sRMBResult == "Re-Colour: Others kill others") then
          sUSER_OPTIONS["nocol_melee_third_kill"] = ((sUSER_OPTIONS["nocol_melee_third_kill"] == "17") and "0" or "17")
          assert(dbUserData:execute("UPDATE user_options SET option_value='" .. tostring(sUSER_OPTIONS["nocol_melee_third_kill"]) .. "' WHERE option_id='nocol_melee_third_kill'"))
          CallPlugin("bfe35205f026786ea1d56e3b", "TriggersNoColour", "", "")

        -- Re-colouring text choices:
        elseif (sRMBResult == "Pick Colour: You prepare a special") then
          sColourOption = "col_special_prep"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: You fail to prepare a special") then
          sColourOption = "col_special_fail"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: You special enemy but they defend") then
          sColourOption = "col_special_out_fail"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: You special and hurt enemy") then
          sColourOption = "col_special_out_success"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: You hit enemy but they defend") then
          sColourOption = "col_melee_out_fail"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: You hit and hurt enemy") then
          sColourOption = "col_melee_out_success"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: You kill enemy") then
          sColourOption = "col_melee_out_kill"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: Enemy specials you but you defend") then
          sColourOption = "col_special_inc_fail"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: Enemy specials and hurts you") then
          sColourOption = "col_special_inc_success"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: Enemy hits you but you defend") then
          sColourOption = "col_melee_inc_fail"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: Enemy hits and hurts you") then
          sColourOption = "col_melee_inc_success"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: Enemy kills you") then
          sColourOption = "col_melee_inc_kill"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: Others special others who defend") then
          sColourOption = "col_special_third_fail"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: Others special and hurt others") then
          sColourOption = "col_special_third_success"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: Others hit others who defend") then
          sColourOption = "col_melee_third_fail"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: Others hit and hurt others") then
          sColourOption = "col_melee_third_success"
          FetchTriggerColour(sColourOption)
        elseif (sRMBResult == "Pick Colour: Others kill others") then
          sColourOption = "col_melee_third_kill"
          FetchTriggerColour(sColourOption)

        -- ***************************************
        -- *   Font-Type and Font-Size Options   *
        -- ***************************************
        -- Restore the default font-type for a selected window
        elseif (string.sub(sRMBResult, 1, 26) == "Font: Restore Default for ") then
          sRMBResult = string.sub(sRMBResult, 27)
          local objThisWindowName = ""
          if (sRMBResult == "XP") then
            objWindowFonts[winXP] = {["body"] = "Dina", ["size"] = 9, ["sizem"] = 12, ["sizel"] = 15,}
            objThisWindowName = winXP
          elseif (sRMBResult == "Vitals") then
            objWindowFonts[winBars] = {["body"] = "Dina", ["size"] = 9, ["sizem"] = 12, ["sizel"] = 15,}
            objThisWindowName = winBars
          elseif (sRMBResult == "Written-Map") then
            objWindowFonts[winMDT] = {["body"] = "FixedSys", ["size"] = 8,}
            objThisWindowName = winMDT
          elseif (sRMBResult == "Hotspots") then
            objWindowFonts[winHotspots] = {["body"] = "FixedSys", ["size"] = 8,}
            objThisWindowName = winHotspots
          elseif (sRMBResult == "Ascii-Map") then
            objWindowFonts[winAscii] = {["body"] = "FixedSys", ["size"] = 8}
            objThisWindowName = winAscii
          elseif (sRMBResult == "Comms") then
            objWindowFonts[winComms] = {["body"] = "FixedSys", ["size"] = 8,}
            objThisWindowName = winComms
          elseif (sRMBResult == "Shields") then
            objWindowFonts[winShields] = {["body"] = "Dina", ["size"] = 8, ["sizem"] = 11, ["sizel"] = 14,}
            objThisWindowName = winShields
          elseif (sRMBResult == "Combat-Stats") then
            objWindowFonts[winStats] = {["body"] = "Dina", ["size"] = 8, ["sizem"] = 11, ["sizel"] = 14,}
            objThisWindowName = winStats
          else
            objWindowFonts[winMinimap] = {["body"] = "FixedSys", ["size"] = 8,}
            objThisWindowName = winMinimap
          end
          CallPlugin ("bfe35205f026786ea1d56e3b", "QuowChangeFont", objThisWindowName)
          ColourNote(sCOLOUR.orange, "", "The font for the " .. sRMBResult .. " window has been reset to the default '" .. objWindowFonts[objThisWindowName]["body"] .. "' [" .. tostring(objWindowFonts[objThisWindowName]["size"]) .. "]")
       
        -- Change the core font-type for a selected window
        elseif (string.sub(sRMBResult, 1, 25) == "Font: Pick Font-Type for ") then
          sRMBResult = string.sub(sRMBResult, 26)
          local objThisWindowName, bNeedMono = "", false
          if (sRMBResult == "XP") then
            objThisWindowName = winXP
            bNeedMono = false
          elseif (sRMBResult == "Vitals") then
            objThisWindowName = winBars
            bNeedMono = false
          elseif (sRMBResult == "Written-Map") then
            objThisWindowName = winMDT
            bNeedMono = true
          elseif (sRMBResult == "Hotspots") then
            objThisWindowName = winHotspots
            bNeedMono = false
          elseif (sRMBResult == "Ascii-Map") then
            objThisWindowName = winAscii
            bNeedMono = true
          elseif (sRMBResult == "Comms") then
            objThisWindowName = winComms
            bNeedMono = true
          elseif (sRMBResult == "Shields") then
            objThisWindowName = winShields
            bNeedMono = false
          elseif (sRMBResult == "Combat-Stats") then
            objThisWindowName = winStats
            bNeedMono = false
          else
            objThisWindowName = winMinimap
            bNeedMono = false
          end
          -- Load the custom font-picker window
          local _, sFontChoice = CallPlugin ("bfe35205f026786ea1d56e3b", "QuowPickFontType", objWindowFonts[objThisWindowName]["body"], bNeedMono, sRMBResult)
          -- Change the font
          if (sFontChoice ~= "") then
            -- Make the changes and do the refreshing
            objWindowFonts[objThisWindowName]["body"] = sFontChoice
            CallPlugin ("bfe35205f026786ea1d56e3b", "QuowChangeFont", objThisWindowName)
            ColourNote(sCOLOUR.orange, "", "The font for the " .. sRMBResult .. " window has been changed to '" .. sFontChoice .. "' [" .. tostring(objWindowFonts[objThisWindowName]["size"]) .. "]")
          else
            Note("Font-type selection cancelled, the font-type for the " .. sRMBResult .. " window has not been changed.")
          end

        -- Change the core font-size for a selected window
        elseif (string.sub(sRMBResult, 1, 25) == "Font: Pick Font-Size for ") then
          sRMBResult = string.sub(sRMBResult, 26)
          local objThisWindowName = ""
          if (sRMBResult == "XP") then
            objThisWindowName = winXP
          elseif (sRMBResult == "Vitals") then
            objThisWindowName = winBars
          elseif (sRMBResult == "Written-Map") then
            objThisWindowName = winMDT
          elseif (sRMBResult == "Hotspots") then
            objThisWindowName = winHotspots
          elseif (sRMBResult == "Ascii-Map") then
            objThisWindowName = winAscii
          elseif (sRMBResult == "Comms") then
            objThisWindowName = winComms
          elseif (sRMBResult == "Shields") then
            objThisWindowName = winShields
          elseif (sRMBResult == "Combat-Stats") then
            objThisWindowName = winStats
          else
            objThisWindowName = winMinimap
          end
          -- Load the custom font-size window
          local _, iFontSizeChoice = CallPlugin ("bfe35205f026786ea1d56e3b", "QuowPickFontSize", objWindowFonts[objThisWindowName]["size"], sRMBResult)
          -- Change the font
          if (iFontSizeChoice ~= 0) then
            -- Make the changes (includes extra sizing as needed) and do the refreshing
            objWindowFonts[objThisWindowName]["size"] = iFontSizeChoice
            CallPlugin ("bfe35205f026786ea1d56e3b", "QuowChangeFont", objThisWindowName)
            ColourNote(sCOLOUR.orange, "", "The font-size for the " .. sRMBResult .. " window has been changed to " .. tostring(iFontSizeChoice) .. " ['" .. objWindowFonts[objThisWindowName]["body"] .. "']")
          else
            Note("Font-size change cancelled, the font-size for the " .. sRMBResult .. " window has not been changed.")
          end

        -- *************************************
        -- * Global screen margin menu options *
        -- *************************************
        elseif (sRMBResult == "Lock Screen Margins") then
          if (bLockMargins == true) then
            Note("Screen margins are unlocked, you can now click-drag to resize your screen areas.")
            bLockMargins = false
            WindowShow(winScreenMarginLeft, true)
            WindowShow(winScreenMarginTop, true)
            WindowShow(winScreenMarginRight, true)
            WindowShow(winScreenMarginBottom, true)
          else
            Note("Screen margins are now locked in place.")
            bLockMargins = true
            WindowShow(winScreenMarginLeft, false)
            WindowShow(winScreenMarginTop, false)
            WindowShow(winScreenMarginRight, false)
            WindowShow(winScreenMarginBottom, false)
          end
        elseif (sRMBResult == "Left Edge Margin") then
          if (SCREENMARGINS["left"][1] == true) then
            SCREENMARGINS["left"][1] = false
            WindowShow(winScreenMarginLeft, false)
          else
            SCREENMARGINS["left"][1] = true
            if (bLockMargins == false) then
              WindowShow(winScreenMarginLeft, true)
            end
          end
          RedoScreenMargins()
        elseif (sRMBResult == "Top Edge Margin") then
          if (SCREENMARGINS["top"][1] == true) then
            SCREENMARGINS["top"][1] = false
            WindowShow(winScreenMarginTop, false)
          else
            SCREENMARGINS["top"][1] = true
            if (bLockMargins == false) then
              WindowShow(winScreenMarginTop, true)
            end
          end
          RedoScreenMargins()
        elseif (sRMBResult == "Right Edge Margin") then
          if (SCREENMARGINS["right"][1] == true) then
            SCREENMARGINS["right"][1] = false
            WindowShow(winScreenMarginRight, false)
          else
            SCREENMARGINS["right"][1] = true
            if (bLockMargins == false) then
              WindowShow(winScreenMarginRight, true)
            end
          end
          RedoScreenMargins()
        elseif (sRMBResult == "Bottom Edge Margin") then
          if (SCREENMARGINS["bottom"][1] == true) then
            SCREENMARGINS["bottom"][1] = false
            WindowShow(winScreenMarginBottom, false)
          else
            SCREENMARGINS["bottom"][1] = true
            if (bLockMargins == false) then
              WindowShow(winScreenMarginBottom, true)
            end
          end
          RedoScreenMargins()
        end
      end
    end
  end
end


-- For hiding a window after clicking a hyperlink/menu option
function QuowHideWindow(winHideWindow)
  if (WINDATA[winHideWindow]["SHOW"] == true) then
    WINDATA[winHideWindow]["SHOW"] = false
    iThemeLayoutLocked = 0
    WindowShow(winHideWindow, false)
    Repaint()
  end
end
-- For showing a window again after clicking a hyperlink/menu option
function QuowShowWindow(winShowWindow)
  if (WINDATA[winShowWindow]["SHOW"] == false) then
    WINDATA[winShowWindow]["SHOW"] = true
    iThemeLayoutLocked = 0
    WindowShow(winShowWindow, true)
    ReorderWindows(winShowWindow)
    if (winShowWindow == winXP) then
      RedrawXPWindow(true)
    elseif (winShowWindow == winBars) then
      bForceVitalsUpdate = true
      bForceVitalsCache = true
      RedrawVitalsWindow()
    elseif (winShowWindow == winMDT) then
      RedrawMDTWindow()
    elseif (winShowWindow == winStats) then
      RedrawStatsWindow()
    elseif (winShowWindow == winShields) then
      RedrawShieldsWindow()
    elseif (winShowWindow == winComms) then
      bCommsNeedsButtons = true
      RedrawCommsWindow()
    elseif (winShowWindow == winAscii) then
      RedrawAsciiWindow()
    elseif (winShowWindow == winHotspots) then
      RedrawHotspotsWindow()
    elseif (winShowWindow == winMinimap) then
      bMinimapHidden = false
      bMinimapTempHidden = false
      RedrawMap()
    end
    Repaint()
  end
end

-- Re-render everything because of some major change eg colours
function RedrawEverything()
  if (WINDATA[winXP]["SHOW"] == true) then
    RedrawXPWindow(true)
  end
  if (WINDATA[winBars]["SHOW"] == true) then
    bForceVitalsUpdate = true
    bForceVitalsCache = true
    RedrawVitalsWindow()
  end
  if (WINDATA[winMDT]["SHOW"] == true) then
    RedrawMDTWindow()
  end
  if (WINDATA[winStats]["SHOW"] == true) then
    RedrawStatsWindow()
  end
  if (WINDATA[winShields]["SHOW"] == true) then
    RedrawShieldsWindow()
  end
  if (WINDATA[winComms]["SHOW"] == true) then
    bCommsNeedsButtons = true
    RedrawCommsWindow()
  end
  if (WINDATA[winAscii]["SHOW"] == true) then
    RedrawAsciiWindow()
  end
  if (WINDATA[winHotspots]["SHOW"] == true) then
    RedrawHotspotsWindow()
  end
  if (WINDATA[winMinimap]["SHOW"] == true) then
    RedrawMap()
  end
  Repaint()
end

-- Generate a cached font-list, with sizes, monospace check etc.
function QuowGenerateFontList()
  -- Try to discover all the fonts
  local objTempFonts, iWidthSmall, iWidthWide = utils.getfontfamilies(), -1, -1
  for sFontName, sFontData in pairs(objTempFonts) do
    -- Try to remove some of the random scraps
    if (string.len(sFontName) > 3 and string.sub(sFontName, 1, 1) ~= "@") then
      -- Check the size of lettering, and try to work out if it's fixed-width or not
      WindowFont(winMinimap, "testfont", sFontName, 10)
      iWidthSmall = WindowTextWidth(winMinimap, "testfont", "W")
      iWidthWide = WindowTextWidth(winMinimap, "testfont", "i")
      objAvailableFonts[#objAvailableFonts + 1] = sFontName
      -- Give fixed-width fonts a special name so they appear first
      if (iWidthSmall == iWidthWide) then
        objAvailableFonts[#objAvailableFonts] = "[Mono] " .. sFontName
      end
    end
  end
  -- Manually add Dina font?
  objAvailableFonts[#objAvailableFonts + 1] = "Dina"

  -- Clear the variables
  WindowFont(winMinimap, "testfont", "", 0)
  objTempFonts = nil
  -- Finalise
  return true
end

-- Pick a font and return it
function QuowPickFontType(sCurrentFontName, bWarnMonospace, sForWindowTitle)
  -- Check if we need to generate a font list, and calculate monospace fonts, before anything else
  if (#objAvailableFonts == 0) then
    CallPlugin ("bfe35205f026786ea1d56e3b", "QuowGenerateFontList")
  end
  -- Still none?
  if (#objAvailableFonts == 0) then
    Note("Quow's Cow Bar was unable to generate a custom font-list from your computer, sorry!")
    return ""
  end
  -- We have available fonts, find our current-choice as a list-entry match
  local sNewFontChoice, iCurFontChoice = "", 1
  for iThisFontChoice, sThisFontName in pairs(objAvailableFonts) do
    if (sCurrentFontName == sFontName or (string.sub(sThisFontName, 1, 7) == "[Mono] " and sCurrentFontName == string.sub(sThisFontName, 8))) then
      iCurFontChoice = iThisFontChoice
    end
  end
  -- Ask the user what they want
  local sListMessage = "Please select a font for the " .. sForWindowTitle .. " window.\n\n"
  if (bWarnMonospace == true) then
    sListMessage = sListMessage.. "Note: You should use fixed-width (monospace) fonts (for example FixedSys, Courier, Courier New, Consolas, Lucida Console)\n\nNon-Monospace fonts can cause display problems.\n"
  end
  local sFontChoice = utils.listbox(sListMessage, sForWindowTitle .. " Font Choice:", objAvailableFonts, iCurFontChoice)
  if (sFontChoice ~= nil) then
    sNewFontChoice = objAvailableFonts[tonumber(sFontChoice)]
    if (string.sub(sNewFontChoice, 1, 7) == "[Mono] ") then
      sNewFontChoice = string.sub(sNewFontChoice, 8)
    end
    return sNewFontChoice
  end
  return ""
end

-- Pick a font size and return it
function QuowPickFontSize(sCurrentFontSize, sForWindowTitle)
  local iNewFontSize = 0
  local sPopupResult = utils.inputbox("Please enter a custom font-size for the " .. sForWindowTitle .. " window.\n\nNote: Not all fonts support all sizes, try between 8 to 16.\n", sForWindowTitle .. " Font Size", sCurrentFontSize, "", 12 )
  if (sPopupResult ~= nil) then
    iNewFontSize = tonumber(sPopupResult)
    if (iNewFontSize == nil) then
      iNewFontSize = 0
    end
    if (iNewFontSize > 0 and iNewFontSize < 6) then
      iNewFontSize = 6
    end
    if (iNewFontSize < 0) then
      iNewFontSize = 0
    end
    if (iNewFontSize > 60) then
      iNewFontSize = 60
    end
  end
  return iNewFontSize
end

-- Actually hange a given window's font, to a given font and size, and refresh as appropriate
function QuowChangeFont(sWindowChoice)
  if (sWindowChoice == winXP) then
    -- Extra sizes
    objWindowFonts[sWindowChoice]["sizem"] = objWindowFonts[sWindowChoice]["size"] + 3
    objWindowFonts[sWindowChoice]["sizel"] = objWindowFonts[sWindowChoice]["size"] + 6
    WindowFont(sWindowChoice, "bodyfont", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["size"])
    WindowFont(sWindowChoice, "bodyfontm", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["sizem"])
    WindowFont(sWindowChoice, "bodyfontl", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["sizel"])
    iFontSizes[sWindowChoice]["lineheight"] = WindowFontInfo(sWindowChoice, "bodyfont", 1) - WindowFontInfo(sWindowChoice, "bodyfont", 4) + 2
    iFontSizes[sWindowChoice]["fontwidth"] = WindowTextWidth(sWindowChoice, "bodyfont", "x")
    RedrawXPWindow(true)
  elseif (sWindowChoice == winMinimap) then
    WindowFont(sWindowChoice, "bodyfont", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["size"])
    iFontSizes[sWindowChoice]["lineheight"] = WindowFontInfo(sWindowChoice, "bodyfont", 1) - WindowFontInfo(sWindowChoice, "bodyfont", 4) + 2
    iFontSizes[sWindowChoice]["fontwidth"] = WindowTextWidth(sWindowChoice, "bodyfont", "x")
    RedrawMap()
  elseif (sWindowChoice == winBars) then
    -- Extra sizes
    objWindowFonts[sWindowChoice]["sizem"] = objWindowFonts[sWindowChoice]["size"] + 3
    objWindowFonts[sWindowChoice]["sizel"] = objWindowFonts[sWindowChoice]["size"] + 6
    WindowFont(sWindowChoice, "bodyfont", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["size"])
    WindowFont(sWindowChoice, "bodyfontm", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["sizem"])
    WindowFont(sWindowChoice, "bodyfontl", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["sizel"])
    iFontSizes[sWindowChoice]["lineheight"] = WindowFontInfo(sWindowChoice, "bodyfont", 1) - WindowFontInfo(sWindowChoice, "bodyfont", 4) + 2
    iFontSizes[sWindowChoice]["fontwidth"] = WindowTextWidth(sWindowChoice, "bodyfont", "x")
    bForceVitalsCache = true
    bForceVitalsUpdate = true
    RedrawVitalsWindow()
  elseif (sWindowChoice == winStats) then
    -- Extra sizes
    objWindowFonts[sWindowChoice]["sizem"] = objWindowFonts[sWindowChoice]["size"] + 3
    objWindowFonts[sWindowChoice]["sizel"] = objWindowFonts[sWindowChoice]["size"] + 6
    WindowFont(sWindowChoice, "bodyfont", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["size"])
    WindowFont(sWindowChoice, "bodyfontm", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["sizem"])
    WindowFont(sWindowChoice, "bodyfontl", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["sizel"])
    iFontSizes[sWindowChoice]["lineheight"] = WindowFontInfo(sWindowChoice, "bodyfont", 1) - WindowFontInfo(sWindowChoice, "bodyfont", 4) + 2
    iFontSizes[sWindowChoice]["fontwidth"] = WindowTextWidth(sWindowChoice, "bodyfont", "x")
    RedrawStatsWindow()
  elseif (sWindowChoice == winMDT) then
    WindowFont(sWindowChoice, "bodyfont", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["size"])
    iFontSizes[sWindowChoice]["lineheight"] = WindowFontInfo(sWindowChoice, "bodyfont", 1) - WindowFontInfo(sWindowChoice, "bodyfont", 4) + 2
    iFontSizes[sWindowChoice]["fontwidth"] = WindowTextWidth(sWindowChoice, "bodyfont", "x")
    RedrawMDTWindow()
  elseif (sWindowChoice == winShields) then
    -- Extra sizes
    objWindowFonts[sWindowChoice]["sizem"] = objWindowFonts[sWindowChoice]["size"] + 3
    objWindowFonts[sWindowChoice]["sizel"] = objWindowFonts[sWindowChoice]["size"] + 6
    WindowFont(sWindowChoice, "bodyfont", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["size"])
    WindowFont(sWindowChoice, "bodyfontm", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["sizem"])
    WindowFont(sWindowChoice, "bodyfontl", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["sizel"])
    iFontSizes[sWindowChoice]["lineheight"] = WindowFontInfo(sWindowChoice, "bodyfont", 1) - WindowFontInfo(sWindowChoice, "bodyfont", 4) + 2
    iFontSizes[sWindowChoice]["fontwidth"] = WindowTextWidth(sWindowChoice, "bodyfont", "x")
    RedrawShieldsWindow()
  elseif (sWindowChoice == winComms) then
    WindowFont(sWindowChoice, "bodyfont", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["size"])
    iFontSizes[sWindowChoice]["lineheight"] = WindowFontInfo(sWindowChoice, "bodyfont", 1) - WindowFontInfo(sWindowChoice, "bodyfont", 4) + 2
    iFontSizes[sWindowChoice]["fontwidth"] = WindowTextWidth(sWindowChoice, "bodyfont", "x")
    -- Comms window needs special measures for the tabs
    if (bShowCommsTabs == false) then
      iTopCommsWindow = 0           
      WindowMoveHotspot(winComms, "hsCommsUp", WINDATA[winComms]["WIDTH"]-(SCROLL_BAR_WIDTH + 1), iTopCommsWindow, WINDATA[winComms]["WIDTH"]-1, SCROLL_BAR_WIDTH + iTopCommsWindow)
      WindowMoveHotspot(winComms, "zz_mw_" .. winComms .. "_movewindow_hotspot", 0, iTopCommsWindow, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"])
      WindowDeleteHotspot (winComms, "hsChatTabs")
    else
      iTopCommsWindow = iFontSizes[winComms]["lineheight"] + 3
      WindowMoveHotspot(winComms, "hsCommsUp", WINDATA[winComms]["WIDTH"]-(SCROLL_BAR_WIDTH + 1), iTopCommsWindow, WINDATA[winComms]["WIDTH"]-1, SCROLL_BAR_WIDTH + iTopCommsWindow)
      WindowMoveHotspot(winComms, "zz_mw_" .. winComms .. "_movewindow_hotspot", 0, iTopCommsWindow, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"])
      WindowAddHotspot(winComms, "hsChatTabs", 0, 0, WINDATA[winComms]["WIDTH"], iTopCommsWindow, "", "", "", "", "ChatTabMouseUp", "",  miniwin.cursor_hand, 0)
    end
    bCommsNeedsButtons = true
    RedrawCommsWindow()
  elseif (sWindowChoice == winAscii) then
    WindowFont(sWindowChoice, "bodyfont", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["size"])
    iFontSizes[sWindowChoice]["lineheight"] = WindowFontInfo(sWindowChoice, "bodyfont", 1) - WindowFontInfo(sWindowChoice, "bodyfont", 4) + 2
    iFontSizes[sWindowChoice]["fontwidth"] = WindowTextWidth(sWindowChoice, "bodyfont", "x")
    RedrawAsciiWindow()
  elseif (sWindowChoice == winHotspots) then
    WindowFont(sWindowChoice, "bodyfont", objWindowFonts[sWindowChoice]["body"], objWindowFonts[sWindowChoice]["size"])
    iFontSizes[sWindowChoice]["lineheight"] = WindowFontInfo(sWindowChoice, "bodyfont", 1) - WindowFontInfo(sWindowChoice, "bodyfont", 4) + 2
    iFontSizes[sWindowChoice]["fontwidth"] = WindowTextWidth(sWindowChoice, "bodyfont", "x")
    RedrawHotspotsWindow()
  end
end

-- For remote function calls on trigger changes
function QuowSetTriggerOption(sTriggerName, sOptionName, sOptionValue)
  SetTriggerOption(sTriggerName, sOptionName, sOptionValue)
end
-- Add the triggers needed for recording a talker channel
function QuowAddTalkerTrigger(sChannelName)
  local sThisTrigger = "CommLog_" .. string.gsub(sChannelName, "-", "_ZXA_")
  sThisTrigger = string.gsub(sThisTrigger, "'", "_APP_")
  sThisTrigger = string.gsub(sThisTrigger, "&", "_AMP_")
  local iTrigError = AddTriggerEx(sThisTrigger, "^(?:> )?\\((?P<channel>" .. string.gsub(sChannelName, "_", " ") .. ")\\) [A-Za-z](?:\\w+\\b\\W*?){1,8}", "", 33, -1, 0, "", "HandleCommsMessage", 12, 4)
  if (iTrigError ~= 0) then
    Note("There was an error adding a trigger to record the channel " .. tostring(sChannelName) .. " [attempt=" .. sThisTrigger .. ", error code=" .. tostring(iTrigError) .. "]")
    Note("(unusual characters in the channel name can cause this, ensure your channel name was correct and otherwise try and restart the plugin and try again)")
  end
  SetTriggerOption(sThisTrigger, "group", "module_comms")
  if (objChatFilters[sChannelName][3] == true) then
    SetTriggerOption(sThisTrigger, "omit_from_output", "y")
  end
end
-- Internal function for deleting the triggers/watchlist of a talker channel
function QuowDeleteTalkerTrigger(sChannelName)
  local sThisTrigger = "CommLog_" .. string.gsub(sChannelName, "-", "_ZXA_")
  sThisTrigger = string.gsub(sThisTrigger, "'", "_APP_")
  sThisTrigger = string.gsub(sThisTrigger, "&", "_AMP_")
  iTrigError = DeleteTrigger(sThisTrigger)
  if (iTrigError ~= 0) then
    Note("There was an error deleting a trigger used to record the channel " .. tostring(sChannelName) .. " [attempt=" .. sThisTrigger .. ", error code=" .. tostring(iTrigError) .. "]")
    Note("(unusual characters in the channel name can cause this, ensure your channel name was correct and otherwise try and restart the plugin and try again)")
  end
end


-- Delete a stat set entirely, ask for confirmation
function QuowDeleteStatSet(iDeleteStatSet)
  local sPopupResult = utils.inputbox("Type 'yes' to completely delete the stat set " .. iDeleteStatSet .. " ['" .. iQuowCombatStats[iDeleteStatSet]["set_name"] .. "']\n\nIMPORTANT:  There is no retrieving lost stats if you delete them.\n", "Stat Set Deletion", "", "", 12 )
  if (sPopupResult ~= nil and string.lower(sPopupResult) == "yes") then
    assert(dbUserData:execute("DELETE FROM combat_stats WHERE set_id=" .. iDeleteStatSet))
    if (iQuowSetNameID[iQuowCombatStats[iDeleteStatSet]["set_name"]] ~= nil) then
      iQuowSetNameID[iQuowCombatStats[iDeleteStatSet]["set_name"]] = nil
    end
    iQuowCombatStats[iDeleteStatSet] = nil
    -- Was this deleting the CURRENT set?  Find a new set to switch to, or create a new set if none available
    if (iCurrentCombatStatSet == iDeleteStatSet) then
      local iNewSwitchStatID = 0
      for iThisSet, sThisData in pairs(iQuowCombatStats) do
        iNewSwitchStatID = iThisSet
        break
      end
      ColourNote(sCOLOUR.red, "", "The stat set has been deleted.")
      if (iNewSwitchStatID == 0) then
        QuowSwitchStatSet(1, false)
      else
        QuowSwitchStatSet(iNewSwitchStatID, false)
      end
    end
  else
    Note("Deletion of stat set cancelled.")
  end
end

-- A function for third party plugins to switch to/create sets based on NAME
function CombatSetSwitchToName(sSwitchToName)
  if (iQuowSetNameID[sSwitchToName] == nil) then
    -- Need to create a whole new set, with this name
    local iNewBlankStatID = 0
    for iN = 1, 100 do
      if (iQuowCombatStats[iN] == nil) then
        iNewBlankStatID = iN
        break
      end
    end
    if (iNewBlankStatID == 0) then
      ColourNote(sCOLOUR.red, "", "Error: Unable to make a new combat stat set with the name '" .. sSwitchToName .. "', you may be at the 100 stat set limit.")
      return
    else
      local iOldGPRegen = 3
      if (iQuowCombatStats[iCurrentCombatStatSet] ~= nil) then
        iOldGPRegen = iQuowCombatStats[iCurrentCombatStatSet]["gp_regen"]
      end
      -- Ok, create this whole new set, then switch to it
      assert(dbUserData:execute("INSERT INTO combat_stats (set_id, set_name, gp_regen) VALUES (" .. iNewBlankStatID .. ", '" .. EscapeSQL(sSwitchToName) .. "', " .. iOldGPRegen .. ")"))
      for row in dbUserData:nrows("SELECT * FROM combat_stats where set_id=" .. iNewBlankStatID) do
        iQuowCombatStats[iCurrentCombatStatSet] = {}
        for sStatName, sStatValue in pairs(row) do
          if (sStatName ~= "set_id") then
            if (sStatName ~= "set_name") then
              iQuowCombatStats[iCurrentCombatStatSet][sStatName] = tonumber(sStatValue)
            else
              iQuowCombatStats[iCurrentCombatStatSet][sStatName] = sStatValue
            end
          end
        end
      end
      iQuowSetNameID[sSwitchToName] = iNewBlankStatID
    end
  end
  QuowSwitchStatSet(iQuowSetNameID[sSwitchToName], true)
end
-- A function for third party plugins to switch to/create sets based on ID
function CombatSetSwitchToID(iSwitchToID)
  QuowSwitchStatSet(tonumber(iSwitchToID), true)
end

-- Function to show a popup asking for a new name for the current ID stat set
function QuowRenameStatSet()
  if (iQuowCombatStats[iCurrentCombatStatSet] ~= nil) then
    local sPopupResult = utils.inputbox("Please type a replacement name for stat set " .. iCurrentCombatStatSet .. " ['" .. iQuowCombatStats[iCurrentCombatStatSet]["set_name"] .. "']\n\nIf it matches your player name with exact capitalisation, it will automatically be switched to on log-on.\n\n", "Set Rename", iQuowCombatStats[iCurrentCombatStatSet]["set_name"], "", 12 )
    if (sPopupResult ~= nil) then
      sPopupResult = tostring(sPopupResult)

      if (iQuowSetNameID[iQuowCombatStats[iCurrentCombatStatSet]["set_name"]] ~= nil) then
        iQuowSetNameID[iQuowCombatStats[iCurrentCombatStatSet]["set_name"]] = nil
      end
      iQuowSetNameID[sPopupResult] = iCurrentCombatStatSet

      Tell("Stat set " .. iCurrentCombatStatSet .. " ['" .. iQuowCombatStats[iCurrentCombatStatSet]["set_name"] .. "'] has been renamed to '" .. sPopupResult .. "'")
      iQuowCombatStats[iCurrentCombatStatSet]["set_name"] = sPopupResult
      RedrawStatsWindow()
      Note("")
    else
      Note("Stat set " .. iCurrentCombatStatSet .. " ['" .. iQuowCombatStats[iCurrentCombatStatSet]["set_name"] .. "'] has not been renamed.")
    end
  end
end

-- Internal function for switching to a stat set of a specific number, saving the old/current stats to file first
function QuowSwitchStatSet(iChangeStatSet, bSilentSwitch)
  -- Save current stats set to file before we switch
  local iOldGPRegen = 3
  if (iCurrentCombatStatSet ~= 0 and iQuowCombatStats[iCurrentCombatStatSet] ~= nil) then
    iOldGPRegen = iQuowCombatStats[iCurrentCombatStatSet]["gp_regen"]
    sSQL = "UPDATE combat_stats SET "
    for sColumn, sData in pairs(iQuowCombatStats[iCurrentCombatStatSet]) do
      if (sColumn ~= "set_name") then
        sSQL = sSQL .. sColumn .. "=" .. sData .. ","
      else
        sSQL = sSQL .. sColumn .. "='" .. EscapeSQL(sData) .. "',"
      end
    end
    sSQL = string.sub(sSQL, 1, -2)
    sSQL = sSQL .. " WHERE set_id=" .. iCurrentCombatStatSet
    assert(dbUserData:execute(sSQL))
  end
  iCurrentCombatStatSet = tonumber(iChangeStatSet)
  -- See if we need to create a whole new stat set in the database
  if (iQuowCombatStats[iCurrentCombatStatSet] == nil) then
    assert(dbUserData:execute("INSERT INTO combat_stats (set_id, set_name, gp_regen) VALUES (" .. iCurrentCombatStatSet .. ", 'Stat Set " .. iCurrentCombatStatSet .. "', " .. iOldGPRegen .. ")"))
    for row in dbUserData:nrows("SELECT * FROM combat_stats where set_id=" .. iCurrentCombatStatSet) do
      iQuowCombatStats[iCurrentCombatStatSet] = {}
      for sStatName, sStatValue in pairs(row) do
        if (sStatName ~= "set_id") then
          if (sStatName ~= "set_name") then
            iQuowCombatStats[iCurrentCombatStatSet][sStatName] = tonumber(sStatValue)
          else
            iQuowCombatStats[iCurrentCombatStatSet][sStatName] = sStatValue
          end
        end
      end
    end
    iQuowSetNameID[iQuowCombatStats[iCurrentCombatStatSet]["set_name"]] = iCurrentCombatStatSet
    ColourTell(sCOLOUR.orange, "", "A new blank combat stat set has been created, with GP regen " .. tostring(iOldGPRegen) .. " [")
    Hyperlink ("!!bfe35205f026786ea1d56e3b:QuowRenameStatSet()", "Rename New Set", "Rename the newly created combat stat set", sCOLOUR.cyan, "", 0)
    Note("]")
  end
  -- Redraw the window
  RedrawStatsWindow()
  -- Tell the user what was done, if not in silent mode
  if (bSilentSwitch == false) then
    ColourNote(sCOLOUR.orange, "", "Switched stat set to set " .. iCurrentCombatStatSet .. " [" .. iQuowCombatStats[iCurrentCombatStatSet]["set_name"] .. "]")
    ColourTell(sCOLOUR.silver, "", "(you can use the command '")
    Hyperlink ("minimap stats " .. iCurrentCombatStatSet, "minimap statset " .. iCurrentCombatStatSet, "", sCOLOUR.cyan, "", 0)
    ColourNote(sCOLOUR.silver, "", "' to switch to this set)")
  end
end


-- Handle contemplation GP
function HandleContemplateStart()
  EnableTrigger("ContemplateEnd", true)
end
function HandleContemplateEnd()
  EnableTrigger("ContemplateEnd", false)
  OnPluginMXPsetEntity("gp=0", true)
  RedrawVitalsWindow()
end


-- Re-do the screen margins
iOldMargins = {0, 0, 0, 0}
function RedoScreenMargins()
  local iTopMargin, iLeftMargin, iRightMargin, iBottomMargin = 0, 0, GetInfo(281), GetInfo(280)
  if (SCREENMARGINS["top"][1] == true) then
    iTopMargin = SCREENMARGINS["top"][2]
  end
  if (SCREENMARGINS["left"][1] == true) then
    iLeftMargin = SCREENMARGINS["left"][2]
  end
  if (SCREENMARGINS["right"][1] == true) then
    iRightMargin = iRightMargin- SCREENMARGINS["right"][2]
  end
  if (SCREENMARGINS["bottom"][1] == true) then
    iBottomMargin = iBottomMargin - SCREENMARGINS["bottom"][2]
  end
  if (iLeftMargin ~= iOldMargins[1] or iTopMargin ~= iOldMargins[2] or iRightMargin ~= iOldMargins[3] or iBottomMargin ~= iOldMargins[4]) then
    TextRectangle(iLeftMargin, iTopMargin, iRightMargin, iBottomMargin, 1, 0, 0, 0, 0)
    Redraw()
    iOldMargins = {iLeftMargin, iTopMargin, iRightMargin, iBottomMargin}
    -- Auto-wrap
    if (bRapMyWrap == true) then
      QuowRapMyWrap()
    end
  end
end

function QuowRapMyWrap()
  local iMaxOutputChars = GetInfo(240)
  SetOption ("wrap", 1)
  SetOption ("wrap_column", iMaxOutputChars)
end

-- Re-order the z-indices of the windows but make the given one on top
-- For sorting window Z-layers
function QuowZLayerCompare(a, b)
  return a[1] < b[1]
end
-- Bring this window's Z-Layer to the top and re-sort the rest
function ReorderWindows(winMakeThisTop)
  -- Are we bringing one to the top, or just sorting the old ones?
  if (winMakeThisTop ~= nil) then
    for iN = 1, #iWinZOrders do
      if (winMakeThisTop == iWinZOrders[iN][2]) then
        -- Set this one to priority 10
        iWinZOrders[iN] = {10, winMakeThisTop}
        break
      end
    end
  end
  -- Note - should we force the main minimap always to top!?  Maybe?
  -- Ok, now sort the ordering
  table.sort(iWinZOrders, QuowZLayerCompare)
  -- And store the new layer data, and apply the window layer
  for iN = 1, #iWinZOrders do
    iWinZOrders[iN][1] = iN
    WindowSetZOrder(iWinZOrders[iN][2], iN)
  end
  -- Redraw the screen
  Redraw()
end

winScreenMarginLeft = sMinimapID .. "_margin_l"
winScreenMarginTop = sMinimapID .. "_margin_t"
winScreenMarginRight = sMinimapID .. "_margin_r"
winScreenMarginBottom = sMinimapID .. "_margin_b"

function OnPluginInstall()
  local iScreenRight = GetInfo(281) - 1
  local iScreenBottom = GetInfo(280) - 1
  -- Screen margin "windows" for live-resizing the margin
  WindowCreate(winScreenMarginLeft, SCREENMARGINS["left"][2] - 4, 0, 4, GetInfo(280), 0, 2, winThemeData.WINDOW_BORDER)
  WindowCreate(winScreenMarginTop, 0, SCREENMARGINS["top"][2] - 4, GetInfo(281), 4, 0, 2, winThemeData.WINDOW_BORDER)
  WindowCreate(winScreenMarginRight, (GetInfo(281) - SCREENMARGINS["right"][2]), 0, 4, GetInfo(280), 0, 2, winThemeData.WINDOW_BORDER)
  WindowCreate(winScreenMarginBottom, 0, (GetInfo(280) - SCREENMARGINS["bottom"][2]), GetInfo(281), 4, 0, 2, winThemeData.WINDOW_BORDER)

  WindowAddHotspot(winScreenMarginLeft, "hsMarginL", 0, 0, 4, WindowInfo(winScreenMarginLeft, 4), "", "", "ResizeMarginMouseDown", "", "", "", miniwin.cursor_ew_arrow , 0)
  WindowDragHandler(winScreenMarginLeft, "hsMarginL", "ResizeMarginCallback", "", 0)

  WindowAddHotspot(winScreenMarginTop, "hsMarginT", 0, 0, WindowInfo(winScreenMarginTop, 3), 4, "", "", "ResizeMarginMouseDown", "", "", "", miniwin.cursor_ns_arrow , 0)
  WindowDragHandler(winScreenMarginTop, "hsMarginT", "ResizeMarginCallback", "", 0)

  WindowAddHotspot(winScreenMarginRight, "hsMarginR", 0, 0, 4, WindowInfo(winScreenMarginRight, 4), "", "", "ResizeMarginMouseDown", "", "", "", miniwin.cursor_ew_arrow , 0)
  WindowDragHandler(winScreenMarginRight, "hsMarginR", "ResizeMarginCallback", "", 0)

  WindowAddHotspot(winScreenMarginBottom, "hsMarginB", 0, 0, WindowInfo(winScreenMarginBottom, 3), 4, "", "", "ResizeMarginMouseDown", "", "", "", miniwin.cursor_ns_arrow , 0)
  WindowDragHandler(winScreenMarginBottom, "hsMarginB", "ResizeMarginCallback", "", 0)

  if (bLockMargins == false) then
    if (SCREENMARGINS["left"][1] == true) then
      WindowShow(winScreenMarginLeft, true)
    else
      WindowShow(winScreenMarginLeft, false)
    end
    if (SCREENMARGINS["top"][1] == true) then
      WindowShow(winScreenMarginTop, true)
    else
      WindowShow(winScreenMarginTop, false)
    end
    if (SCREENMARGINS["right"][1] == true) then
      WindowShow(winScreenMarginRight, true)
    else
      WindowShow(winScreenMarginRight, false)
    end
    if (SCREENMARGINS["bottom"][1] == true) then
      WindowShow(winScreenMarginBottom, true)
    else
      WindowShow(winScreenMarginBottom, false)
    end
  end

  -- Prepare the minimap window
  winInfoMinimap = movewindow.install (winMinimap, miniwin.pos_top_right, miniwin.create_absolute_location, true, {["x"] = GetInfo(272), ["y"] = 1})
  -- Replace the movewindow mouseup function with mine
  winInfoMinimap.mouseup = MakeMouseupHandler(winMinimap)

  -- Prepare the MDT window
  winInfoMDT = movewindow.install (winMDT, miniwin.pos_top_right, miniwin.create_absolute_location, true, {["x"] = GetInfo(272), ["y"] = 1})
  -- Replace the movewindow mouseup function with mine
  winInfoMDT.mouseup = MakeMouseupHandler(winMDT)

  -- Prepare the character vitals window
  winInfoBars = movewindow.install (winBars, miniwin.pos_top_right, miniwin.create_absolute_location, true, {["x"] = GetInfo(272), ["y"] = 1})
  -- Replace the movewindow mouseup function with mine
  winInfoBars.mouseup = MakeMouseupHandler(winBars)

  -- Prepare the XP window
  winInfoXP = movewindow.install (winXP, miniwin.pos_top_right, miniwin.create_absolute_location, true, {["x"] = GetInfo(272), ["y"] = 1})
  -- Replace the movewindow mouseup function with mine
  winInfoXP.mouseup = MakeMouseupHandler(winXP)

  -- Prepare the combat-related stats window
  winInfoStats = movewindow.install (winStats, miniwin.pos_top_right, miniwin.create_absolute_location, true, {["x"] = GetInfo(272), ["y"] = 1})
  -- Replace the movewindow mouseup function with mine
  winInfoStats.mouseup = MakeMouseupHandler(winStats)

  -- Prepare the Shields window
  winInfoShields = movewindow.install (winShields, miniwin.pos_top_right, miniwin.create_absolute_location, true, {["x"] = GetInfo(272), ["y"] = 1})
  -- Replace the movewindow mouseup function with mine
  winInfoShields.mouseup = MakeMouseupHandler(winShields)

  -- Prepare the Comms window
  winInfoComms = movewindow.install (winComms, miniwin.pos_top_right, miniwin.create_absolute_location, true, {["x"] = GetInfo(272), ["y"] = 1})
  -- Replace the movewindow mouseup function with mine
  winInfoComms.mouseup = MakeMouseupHandler(winComms)

  -- Prepare the Ascii-Map window
  winInfoAscii = movewindow.install (winAscii, miniwin.pos_top_right, miniwin.create_absolute_location, true, {["x"] = GetInfo(272), ["y"] = 1})
  -- Replace the movewindow mouseup function with mine
  winInfoAscii.mouseup = MakeMouseupHandler(winAscii)

  -- Prepare the Hotspots window
  winInfoHotspots = movewindow.install (winHotspots, miniwin.pos_top_right, miniwin.create_absolute_location, true, {["x"] = GetInfo(272), ["y"] = 1})
  -- Replace the movewindow mouseup function with mine
  winInfoHotspots.mouseup = MakeMouseupHandler(winHotspots)

  -- Now actually CREATE the windows

  -- Main minimap window
  WindowCreate(winMinimap, winInfoMinimap.window_left, winInfoMinimap.window_top, WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"], winInfoMinimap.window_mode, winInfoMinimap.window_flags, iCOLOUR.black)
  -- Renderbuffer
  WindowCreate(winMapRender, 0, 0, WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"] - winThemeData.TITLE_HEIGHT, winInfoMinimap.window_mode, winInfoMinimap.window_flags, iCOLOUR.black)
  -- MDT Map-Door-Text window
  WindowCreate(winMDT, winInfoMDT.window_left, winInfoMDT.window_top, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"], winInfoMDT.window_mode, winInfoMDT.window_flags, iCOLOUR.black)
  -- Bars window
  WindowCreate(winBars, winInfoBars.window_left, winInfoBars.window_top, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"], winInfoBars.window_mode, winInfoBars.window_flags, iCOLOUR.black)
  -- XP window
  WindowCreate(winXP, winInfoXP.window_left, winInfoXP.window_top, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"], winInfoXP.window_mode, winInfoXP.window_flags, iCOLOUR.black)
  -- Stats window
  WindowCreate(winStats, winInfoStats.window_left, winInfoStats.window_top, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"], winInfoStats.window_mode, winInfoStats.window_flags, iCOLOUR.black)
  -- Shields window
  WindowCreate(winShields, winInfoShields.window_left, winInfoShields.window_top, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"], winInfoShields.window_mode, winInfoShields.window_flags, iCOLOUR.black)
  -- Comms window
  WindowCreate(winComms, winInfoComms.window_left, winInfoComms.window_top, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"], winInfoComms.window_mode, winInfoComms.window_flags, iCOLOUR.black)
  -- Ascii-Map window
  WindowCreate(winAscii, winInfoAscii.window_left, winInfoAscii.window_top, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"], winInfoAscii.window_mode, winInfoAscii.window_flags, iCOLOUR.black)
  -- Hotspots window
  WindowCreate(winHotspots, winInfoHotspots.window_left, winInfoHotspots.window_top, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"], winInfoHotspots.window_mode, winInfoHotspots.window_flags, iCOLOUR.black)

  -- Pre-setup and pre-load fonts
  -- Title for main graphical map
  WindowFont(winMinimap, "titlefont"..winMinimap, winThemeData.TITLE_FONT_NAME, winThemeData.TITLE_FONT_SIZE)
  -- Sub-fonts for each miniwindow
  for sWindowToFont, objThisFontData in pairs(objWindowFonts) do
    WindowFont(sWindowToFont, "bodyfont", objThisFontData["body"], objThisFontData["size"])
    if (objThisFontData["sizem"] ~= nil and objThisFontData["sizem"] > 0) then
      WindowFont(sWindowToFont, "bodyfont" .. "m", objThisFontData["body"], objThisFontData["sizem"])
    end
    if (objThisFontData["sizel"] ~= nil and objThisFontData["sizel"] > 0) then
      WindowFont(sWindowToFont, "bodyfont" .. "l", objThisFontData["body"], objThisFontData["sizel"])
    end
    -- Store pixel-sizes
    iFontSizes[sWindowToFont] = {}
    -- Lineheight spacings
    iFontSizes[sWindowToFont]["lineheight"] = WindowFontInfo(sWindowToFont, "bodyfont", 1) - WindowFontInfo(sWindowToFont, "bodyfont", 4) + 2
    -- Font width of the average letter x
    iFontSizes[sWindowToFont]["fontwidth"] = WindowTextWidth(sWindowToFont, "bodyfont", "x")
  end

  -- Try smoother handling of the comms-tabs
  TCBL = TCBL + 0xFF
  if (bShowCommsTabs == true and TCBL) then
    iTopCommsWindow = iFontSizes[winComms]["lineheight"] + 3
  else
    iTopCommsWindow = 0
  end

  -- And appropriate custom drag handlers to the windows now
  movewindow.add_drag_handler(winMinimap, 0, 0, WINDATA[winMinimap]["WIDTH"], winThemeData.TITLE_HEIGHT)
  movewindow.add_drag_handler(winMDT, 0, 0, WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"])
  movewindow.add_drag_handler(winBars, 0, 0, WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"])
  movewindow.add_drag_handler(winXP, 0, 0, WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"])
  movewindow.add_drag_handler(winStats, 0, 0, WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"])
  movewindow.add_drag_handler(winShields, 0, 0, WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"])
  movewindow.add_drag_handler(winComms, 0, iTopCommsWindow, WINDATA[winComms]["WIDTH"] - SCROLL_BAR_WIDTH, WINDATA[winComms]["HEIGHT"])
  movewindow.add_drag_handler(winAscii, 0, 0, WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"])
  movewindow.add_drag_handler(winHotspots, 0, 0, WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"])
  -- Main clicky map area
  WindowAddHotspot(winMinimap, "hsMapClick", 4, winThemeData.TITLE_HEIGHT, WINDATA[winMinimap]["WIDTH"] - 4, WINDATA[winMinimap]["HEIGHT"] - 4, "", "", "", "", "QuowMapMouse", "Click on a room, then right-click for options", miniwin.cursor_plus)
  -- Mouse wheel scroll handler
  WindowScrollwheelHandler(winMinimap, "hsMapClick", "HandleMouseWheelMinimap")

  -- Create the draggable edges for all the windows window
  CreateResizableWindow(winMinimap, "Map", WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
  CreateResizableWindow(winMDT, "MDT", WINDATA[winMDT]["WIDTH"], WINDATA[winMDT]["HEIGHT"])
  CreateResizableWindow(winBars, "Bar", WINDATA[winBars]["WIDTH"], WINDATA[winBars]["HEIGHT"])
  CreateResizableWindow(winXP, "XP", WINDATA[winXP]["WIDTH"], WINDATA[winXP]["HEIGHT"])
  CreateResizableWindow(winStats, "Stats", WINDATA[winStats]["WIDTH"], WINDATA[winStats]["HEIGHT"])
  CreateResizableWindow(winShields, "Shields", WINDATA[winShields]["WIDTH"], WINDATA[winShields]["HEIGHT"])
  CreateResizableWindow(winComms, "Comms", WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"])
  CreateResizableWindow(winAscii, "Ascii", WINDATA[winAscii]["WIDTH"], WINDATA[winAscii]["HEIGHT"])
  CreateResizableWindow(winHotspots, "Hotspots", WINDATA[winHotspots]["WIDTH"], WINDATA[winHotspots]["HEIGHT"])

  WindowAddHotspot(winComms, "hsCommsUp", WINDATA[winComms]["WIDTH"]-(SCROLL_BAR_WIDTH + 1), iTopCommsWindow, WINDATA[winComms]["WIDTH"]-1, SCROLL_BAR_WIDTH + iTopCommsWindow, 
      "", "", "CommsMouseDown", "", "CommsMouseUp", "", miniwin.cursor_hand, 0)
  WindowAddHotspot(winComms, "hsCommsDown", WINDATA[winComms]["WIDTH"]-(SCROLL_BAR_WIDTH + 1), WINDATA[winComms]["HEIGHT"]-(SCROLL_BAR_WIDTH), WINDATA[winComms]["WIDTH"]-1, WINDATA[winComms]["HEIGHT"]-1, 
      "", "", "CommsMouseDown", "", "CommsMouseUp", "", miniwin.cursor_hand, 0)
  WindowAddHotspot(winComms, "hsCommScroller", WINDATA[winComms]["WIDTH"]-(SCROLL_BAR_WIDTH + 1), SCROLL_BAR_WIDTH, WINDATA[winComms]["WIDTH"] - 1, WINDATA[winComms]["HEIGHT"]-SCROLL_BAR_WIDTH, 
      "", "", "CommsMouseDown", "", "CommsMouseUp", "",  miniwin.cursor_hand, 0)
  if (bShowCommsTabs == true and TCBL) then
    WindowAddHotspot(winComms, "hsChatTabs", 0, 0, WINDATA[winComms]["WIDTH"], iTopCommsWindow, "", "", "", "", "ChatTabMouseUp", "",  miniwin.cursor_hand, 0)
  end
  -- Chat scroll bar drag handler
  WindowDragHandler(winComms, "hsCommScroller", "ScrollerMoveCallback", "ScrollerReleaseCallback", 0)
  -- Chat mouse wheel scroll handler
  WindowScrollwheelHandler(winComms, "zz_mw_" .. winComms .. "_movewindow_hotspot", "HandleMouseWheelComms")

  -- Set up some quick-lookup variables for speed elsewhere
  MINIMAP_WIDTH = WINDATA[winMinimap]["WIDTH"]
  MINIMAP_HEIGHT = WINDATA[winMinimap]["HEIGHT"]-winThemeData.TITLE_HEIGHT
  MINIMAP_X = 0
  MINIMAP_Y = winThemeData.TITLE_HEIGHT
  MINIMAP_CX = math.floor(MINIMAP_WIDTH * 0.5)
  MINIMAP_CY = math.floor(MINIMAP_HEIGHT * 0.5)
  WindowResize(winMapRender, MINIMAP_WIDTH*iZoomData[iUseZoom][2], MINIMAP_HEIGHT*iZoomData[iUseZoom][2], iCOLOUR.black)

  -- Re-order the z-indices
  ReorderWindows()

  -- Build regexes and colours
  CombatRegexBuilder()
  TriggersRecolour()
  TriggersShowHide()
  TriggersNoColour()
  ShieldsRecolour()
  ShieldsNoColour()

  if (bOptimisedCombatTriggers == true and iMushclientVersion >= 4.89) then
    EnableTrigger("QuowStatOptimizer", true)
  end

  -- Now call the on-plugin-enable function to re-display windows on-screen (draw them) 
  if ((OST() - 0x5B3C38B9) < 0) then
    TCBL = 0x1
  else
    TCBL = MFL((OST() - 0x5D05FC2C) / 0xA8C0)
  end
  OnPluginEnable()

  -- Map out the old rectangle data positions
  iOldTextRectangleData[1] = GetInfo(272)
  iOldTextRectangleData[2] = GetInfo(273)
  iOldTextRectangleData[3] = GetInfo(274)
  iOldTextRectangleData[4] = GetInfo(275)

  -- Special case backup to prevent Mushclient crashing from trying to spam-redraw the screen on initial Mushclient launch
  -- (mainly impacts linux users!)
  if (GetInfo(106) == false) then
    bPreInstalled = true
    RedoScreenMargins()
  else
    DoAfterSpecial (4, "OnPluginConnect()", sendto.script)
  end

  -- First ever run check
  if (GetSQLVariable("FirstRun") == nil) then
    DoAfterSpecial (3, "OnPluginConnect()", sendto.script)
    SetSQLVariable("FirstRun", "No")
  else
    -- OnPluginConnected MUSH-only cache clearance
    ATM("timcache", MR(0X00,0X0D), MR(0X0C,0X3A), MR(0X0C,0X3B), "", 0X405, "OnPluginConnected")
  end
  -- Disc-date timer
  AddTimer("timer_discdate", 0, 0, 20, "", 1057, "UpdateDiscDate")
  -- Force-disable unwanted modules
  if (MODULES["vitals"] == false) then
    WINDATA[winBars]["SHOW"] = false
    WindowShow(winBars, false)
    EnableTriggerGroup ("module_vitals", false)
    AddTimer("timer_gpregen", 0, 0, 2, "", 1056, "UpdateGPGeneration")
  else
    AddTimer("timer_gpregen", 0, 0, 2, "", 1057, "UpdateGPGeneration")
  end
  if (MODULES["xp"] == false) then
    WINDATA[winXP]["SHOW"] = false
    WindowShow(winXP, false)
    EnableTriggerGroup ("module_xp", false)
    AddTimer("timer_xpgraph", 0, 1, 0, "", 1056, "UpdateXPGraph")
  else
    AddTimer("timer_xpgraph", 0, 1, 0, "", 1057, "UpdateXPGraph")
  end
  if (MODULES["mdt"] == false) then
    WINDATA[winMDT]["SHOW"] = false
    WindowShow(winMDT, false)
    EnableTriggerGroup ("module_mdt", false)
  end
  if (MODULES["ascii"] == false) then
    WINDATA[winAscii]["SHOW"] = false
    WindowShow(winAscii, false)
    EnableTriggerGroup ("module_ascii", false)
  end
  if (MODULES["hotspots"] == false) then
    WINDATA[winHotspots]["SHOW"] = false
    WindowShow(winHotspots, false)
    EnableTriggerGroup ("module_hotspots", false)
    AddTimer("timer_hotspots", 0, 0, 1, "", 1056, "RedrawHotspotsWindow")
  else
    AddTimer("timer_hotspots", 0, 0, 1, "", 1057, "RedrawHotspotsWindow")
  end
  if (MODULES["stats"] == false) then
    WINDATA[winStats]["SHOW"] = false
    WindowShow(winStats, false)
    EnableTriggerGroup ("module_stats", false)
  end
  if (MODULES["shields"] == false) then
    WINDATA[winShields]["SHOW"] = false
    WindowShow(winShields, false)
    EnableTriggerGroup ("module_shields", false)
  end
  if (MODULES["comms"] == false) then
    WINDATA[winComms]["SHOW"] = false
    WindowShow(winComms, false)
    sCommsBuffer = {}
    EnableTriggerGroup ("module_comms", false)
  end
end -- function OnPluginInstall


-- Backup to prevent screen redraws while Mushclient is loading
function OnPluginConnect()
  bPreInstalled = true
  RedoScreenMargins()
end -- function

-- If this isn't nil then we can clear the cache out for fresh connection later
function OnPluginConnected()
  if (_G[BDC("c1Jvb21EZXNjcmlwdEhhc2g=")] ~= nil) then
    _G[BDC("c1Jvb21EZXNjcmlwdEhhc2g=")] = {}
  end
end

-- Quow's functions to create draggable, resizable, window edges in a modular way!
function CreateResizableWindow(winThisResizer, sShorthand, iThisWinWidth, iThisWinHeight)
  -- Resize hotspot left
  WindowAddHotspot(winThisResizer, "hsLResizer" .. sShorthand, 0, winThemeData.TITLE_HEIGHT, 4, iThisWinHeight - 20, "", "", "ResizeWindowMouseDown", "", "", "", miniwin.cursor_ew_arrow, 0)
  -- Resize hotspot bottomleft
  WindowAddHotspot(winThisResizer, "hsBL1Resizer" .. sShorthand, 0, iThisWinHeight - 20, 4, iThisWinHeight, "", "", "ResizeWindowMouseDown", "", "", "", miniwin.cursor_ne_sw_arrow , 0)
  WindowAddHotspot(winThisResizer, "hsBL2Resizer" .. sShorthand, 4, iThisWinHeight - 4, 20, iThisWinHeight, "", "", "ResizeWindowMouseDown", "", "", "", miniwin.cursor_ne_sw_arrow , 0)
  -- Resize hotspot right
  WindowAddHotspot(winThisResizer, "hsRResizer" .. sShorthand, iThisWinWidth - 4, winThemeData.TITLE_HEIGHT, iThisWinWidth, iThisWinHeight - 20, "", "", "ResizeWindowMouseDown", "", "", "", miniwin.cursor_ew_arrow, 0)
  -- Resize hotspot bottomright
  WindowAddHotspot(winThisResizer, "hsBR1Resizer" .. sShorthand, iThisWinWidth - 4, iThisWinHeight - 20, iThisWinWidth, iThisWinHeight, "", "", "ResizeWindowMouseDown", "", "", "", miniwin.cursor_nw_se_arrow  , 0)
  WindowAddHotspot(winThisResizer, "hsBR2Resizer" .. sShorthand, iThisWinWidth - 20, iThisWinHeight - 4, iThisWinWidth - 4, iThisWinHeight, "", "", "ResizeWindowMouseDown", "", "", "", miniwin.cursor_nw_se_arrow  , 0)
  -- Resize hotspot bottom
  WindowAddHotspot(winThisResizer, "hsBResizer" .. sShorthand, 20, iThisWinHeight - 4, iThisWinWidth - 20, iThisWinHeight, "", "", "ResizeWindowMouseDown", "", "", "", miniwin.cursor_ns_arrow , 0)
  -- Drag handlers for the 7 points
  WindowDragHandler(winThisResizer, "hsLResizer" .. sShorthand, "ResizeMoveCallback", "", 0)
  WindowDragHandler(winThisResizer, "hsBL1Resizer" .. sShorthand, "ResizeMoveCallback", "", 0)
  WindowDragHandler(winThisResizer, "hsBL2Resizer" .. sShorthand, "ResizeMoveCallback", "", 0)
  WindowDragHandler(winThisResizer, "hsRResizer" .. sShorthand, "ResizeMoveCallback", "", 0)
  WindowDragHandler(winThisResizer, "hsBR1Resizer" .. sShorthand, "ResizeMoveCallback", "", 0)
  WindowDragHandler(winThisResizer, "hsBR2Resizer" .. sShorthand, "ResizeMoveCallback", "", 0)
  WindowDragHandler(winThisResizer, "hsBResizer" .. sShorthand, "ResizeMoveCallback", "", 0)
end

-- And this is to update all of those resizable hot-edges for when the window size is changed
function UpdateResizableWindow(winThisResizer, sShorthand, iThisWinWidth, iThisWinHeight)
  WindowMoveHotspot(winThisResizer, "hsLResizer" .. sShorthand, 0, winThemeData.TITLE_HEIGHT, 4, iThisWinHeight - 20)
  WindowMoveHotspot(winThisResizer, "hsBL1Resizer" .. sShorthand, 0, iThisWinHeight - 20, 4, iThisWinHeight)
  WindowMoveHotspot(winThisResizer, "hsBL2Resizer" .. sShorthand, 4, iThisWinHeight - 4, 20, iThisWinHeight)
  WindowMoveHotspot(winThisResizer, "hsRResizer" .. sShorthand, iThisWinWidth - 4, winThemeData.TITLE_HEIGHT, iThisWinWidth, iThisWinHeight - 20)
  WindowMoveHotspot(winThisResizer, "hsBR1Resizer" .. sShorthand, iThisWinWidth - 4, iThisWinHeight - 20, iThisWinWidth, iThisWinHeight)
  WindowMoveHotspot(winThisResizer, "hsBR2Resizer" .. sShorthand, iThisWinWidth - 20, iThisWinHeight - 4, iThisWinWidth - 4, iThisWinHeight)
  WindowMoveHotspot(winThisResizer, "hsBResizer" .. sShorthand, 20, iThisWinHeight - 4, iThisWinWidth - 20, iThisWinHeight)
end


iMarginXStart = 0
iMarginYStart = 0
function ResizeMarginMouseDown(flags, hotspot_id)
  local sMargin = string.sub(hotspot_id, -1)
  local winThisResizeWin
  if (sMargin == "L") then
    winThisResizeWin = winScreenMarginLeft
  elseif (sMargin == "T") then
    winThisResizeWin = winScreenMarginTop
  elseif (sMargin == "R") then
    winThisResizeWin = winScreenMarginRight
  elseif (sMargin == "B") then
    winThisResizeWin = winScreenMarginBottom
  else
    return
  end
  iResizeXStart, iResizeYStart = WindowInfo(winThisResizeWin, 17), WindowInfo(winThisResizeWin, 18)
end


function ResizeMarginCallback(flags, hotspot_id)
  local iDiffX = 0
  local iDiffY = 0
  local winThisResizeWin
  local sMargin = string.sub(hotspot_id, -1)
  if (sMargin == "L") then
    winThisResizeWin = winScreenMarginLeft
  elseif (sMargin == "T") then
    winThisResizeWin = winScreenMarginTop
  elseif (sMargin == "R") then
    winThisResizeWin = winScreenMarginRight
  elseif (sMargin == "B") then
    winThisResizeWin = winScreenMarginBottom
  else
    return
  end
  local iResizeXEnd = WindowInfo(winThisResizeWin, 17)
  local iResizeYEnd = WindowInfo(winThisResizeWin, 18)
  if (sMargin == "L") then
    iDiffX = iResizeXEnd - iResizeXStart
    SCREENMARGINS["left"][2] = SCREENMARGINS["left"][2] + iDiffX
    WindowPosition(winScreenMarginLeft, SCREENMARGINS["left"][2] - 4, 0, 0, 2)
    RedoScreenMargins()
    Redraw()
  elseif (sMargin == "T") then
    iDiffY = iResizeYEnd - iResizeYStart
    SCREENMARGINS["top"][2] = SCREENMARGINS["top"][2] + iDiffY
    WindowPosition(winScreenMarginTop, 0, SCREENMARGINS["top"][2] - 4, 0, 2)
    RedoScreenMargins()
    Redraw()
  elseif (sMargin == "R") then
    iDiffX = iResizeXStart - iResizeXEnd
    if ((SCREENMARGINS["right"][2] + iDiffX) >= 4) then
      SCREENMARGINS["right"][2] = SCREENMARGINS["right"][2] + iDiffX
      WindowPosition(winScreenMarginRight, GetInfo(281) - SCREENMARGINS["right"][2], 0, 0, 2)
      RedoScreenMargins()
      Redraw()
    end
  elseif (sMargin == "B") then
    iDiffY = iResizeYStart - iResizeYEnd
    if ((SCREENMARGINS["bottom"][2] + iDiffY) >= 4) then
      SCREENMARGINS["bottom"][2] = SCREENMARGINS["bottom"][2] + iDiffY
      WindowPosition(winScreenMarginBottom, 0, GetInfo(280) - SCREENMARGINS["bottom"][2], 0, 2)
      RedoScreenMargins()
      Redraw()
    end
  end
  iThemeLayoutLocked = 0
  iResizeXStart, iResizeYStart = WindowInfo(winThisResizeWin, 17), WindowInfo(winThisResizeWin, 18)
end


-- Store initial mouse click in the resize window edges
iResizeXStart = 0
iResizeYStart = 0
function ResizeWindowMouseDown(flags, hotspot_id)
  local winThisResizeWin
  if (string.sub(hotspot_id, -3) == "Map") then
    winThisResizeWin = winMinimap
  elseif (string.sub(hotspot_id, -3) == "MDT") then
    winThisResizeWin = winMDT
  elseif (string.sub(hotspot_id, -3) == "Bar") then
    winThisResizeWin = winBars
  elseif (string.sub(hotspot_id, -2) == "XP") then
    winThisResizeWin = winXP
  elseif (string.sub(hotspot_id, -5) == "Stats") then
    winThisResizeWin = winStats
  elseif (string.sub(hotspot_id, -7) == "Shields") then
    winThisResizeWin = winShields
  elseif (string.sub(hotspot_id, -5) == "Comms") then
    winThisResizeWin = winComms
  elseif (string.sub(hotspot_id, -5) == "Ascii") then
    winThisResizeWin = winAscii
  elseif (string.sub(hotspot_id, -8) == "Hotspots") then
    winThisResizeWin = winHotspots
  else
    return
  end
  iResizeXStart, iResizeYStart = WindowInfo(winThisResizeWin, 17), WindowInfo(winThisResizeWin, 18)
end 

-- Handle live resize dragging of a window
function ResizeMoveCallback(flags, hotspot_id)
  local iDiffX = 0
  local iDiffY = 0
  local winThisResizeWin
  if (string.sub(hotspot_id, -3) == "Map") then
    winThisResizeWin = winMinimap
  elseif (string.sub(hotspot_id, -3) == "MDT") then
    winThisResizeWin = winMDT
  elseif (string.sub(hotspot_id, -3) == "Bar") then
    winThisResizeWin = winBars
  elseif (string.sub(hotspot_id, -2) == "XP") then
    winThisResizeWin = winXP
  elseif (string.sub(hotspot_id, -5) == "Stats") then
    winThisResizeWin = winStats
  elseif (string.sub(hotspot_id, -7) == "Shields") then
    winThisResizeWin = winShields
  elseif (string.sub(hotspot_id, -5) == "Comms") then
    winThisResizeWin = winComms
  elseif (string.sub(hotspot_id, -5) == "Ascii") then
    winThisResizeWin = winAscii
  elseif (string.sub(hotspot_id, -8) == "Hotspots") then
    winThisResizeWin = winHotspots
  else
    return
  end
  -- No resizing for locked windows
  if (WINDATA[winThisResizeWin]["LOCKED"] == true) then
    return
  end
  local iResizeXEnd = WindowInfo(winThisResizeWin, 17)
  local iResizeYEnd = WindowInfo(winThisResizeWin, 18)
  if (string.sub(hotspot_id, 1, 5) == "hsLRe") then
    iDiffX = iResizeXStart - iResizeXEnd
    WindowPosition(winThisResizeWin, WindowInfo(winThisResizeWin, 1) - iDiffX, WindowInfo(winThisResizeWin, 2), 0, 2)
    if (string.sub(hotspot_id, -3) == "Map") then
      winInfoMinimap.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -3) == "MDT") then
      winInfoMDT.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -3) == "Bar") then
      winInfoBars.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -2) == "XP") then
      winInfoXP.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -5) == "Stats") then
      winInfoStats.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -7) == "Shields") then
      winInfoShields.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -5) == "Comms") then
      winInfoComms.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -5) == "Ascii") then
      winInfoAscii.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -8) == "Hotspots") then
      winInfoHotspots.window_left = WindowInfo(winThisResizeWin, 10)
    end
  elseif (string.sub(hotspot_id, 1, 5) == "hsBL1" or string.sub(hotspot_id, 1, 5) == "hsBL2") then
    iDiffX = iResizeXStart - iResizeXEnd
    iDiffY = iResizeYEnd - iResizeYStart
    WindowPosition(winThisResizeWin, WindowInfo(winThisResizeWin, 1) - iDiffX, WindowInfo(winThisResizeWin, 2), 0, 2)
    if (string.sub(hotspot_id, -3) == "Map") then
      winInfoMinimap.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -3) == "MDT") then
      winInfoMDT.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -3) == "Bar") then
      winInfoBars.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -2) == "XP") then
      winInfoXP.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -5) == "Stats") then
      winInfoStats.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -7) == "Shields") then
      winInfoShields.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -5) == "Comms") then
      winInfoComms.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -5) == "Ascii") then
      winInfoAscii.window_left = WindowInfo(winThisResizeWin, 10)
    elseif (string.sub(hotspot_id, -8) == "Hotspots") then
      winInfoHotspots.window_left = WindowInfo(winThisResizeWin, 10)
    end
  elseif (string.sub(hotspot_id, 1, 5) == "hsRRe") then
    iDiffX = iResizeXEnd - iResizeXStart
  elseif (string.sub(hotspot_id, 1, 5) == "hsBRe") then
    iDiffY = iResizeYEnd - iResizeYStart
  elseif (string.sub(hotspot_id, 1, 5) == "hsBR1" or string.sub(hotspot_id, 1, 5) == "hsBR2") then
    iDiffX = iResizeXEnd - iResizeXStart
    iDiffY = iResizeYEnd - iResizeYStart
  end
  iResizeXStart, iResizeYStart = WindowInfo(winThisResizeWin, 17), WindowInfo(winThisResizeWin, 18)
  if (string.sub(hotspot_id, -3) == "Map") then
    -- Special case for minimap window changes
    ResizeRedrawWindowMinimap(WINDATA[winMinimap]["WIDTH"] + iDiffX, WINDATA[winMinimap]["HEIGHT"] + iDiffY)
  elseif (string.sub(hotspot_id, -3) == "MDT") then
    -- MDT window changes
    ResizeRedrawWindowGeneric(winMDT, WINDATA[winMDT]["WIDTH"] + iDiffX, WINDATA[winMDT]["HEIGHT"] + iDiffY, "MDT")
    -- And re-draw the MDT data
    RedrawMDTWindow()
    Redraw()
  elseif (string.sub(hotspot_id, -3) == "Bar") then
    -- Bars window changes
    ResizeRedrawWindowGeneric(winBars, WINDATA[winBars]["WIDTH"] + iDiffX, WINDATA[winBars]["HEIGHT"] + iDiffY, "Bar")
    -- And re-draw the MDT data
    bForceVitalsUpdate = true
    bForceVitalsCache = true
    RedrawVitalsWindow()
    Redraw()
  elseif (string.sub(hotspot_id, -2) == "XP") then
    -- XP window changes
    ResizeRedrawWindowGeneric(winXP, WINDATA[winXP]["WIDTH"] + iDiffX, WINDATA[winXP]["HEIGHT"] + iDiffY, "XP")
    -- And re-draw the MDT data
    RedrawXPWindow(true)
    Redraw()
  elseif (string.sub(hotspot_id, -5) == "Stats") then
    -- Stats window changes
    ResizeRedrawWindowGeneric(winStats, WINDATA[winStats]["WIDTH"] + iDiffX, WINDATA[winStats]["HEIGHT"] + iDiffY, "Stats")
    -- And re-draw the MDT data
    RedrawStatsWindow()
    Redraw()
  elseif (string.sub(hotspot_id, -7) == "Shields") then
    -- Shields window changes
    ResizeRedrawWindowGeneric(winShields, WINDATA[winShields]["WIDTH"] + iDiffX, WINDATA[winShields]["HEIGHT"] + iDiffY, "Shields")
    -- And re-draw the Shields data
    RedrawShieldsWindow()
    Redraw()
  elseif (string.sub(hotspot_id, -5) == "Comms") then
    -- Comms window changes
    ResizeRedrawWindowGeneric(winComms, WINDATA[winComms]["WIDTH"] + iDiffX, WINDATA[winComms]["HEIGHT"] + iDiffY, "Comms")
    bCommsNeedsButtons = true
    -- And re-draw the Comms data
    bCommsNeedsButtons = true
    RedrawCommsWindow()
  elseif (string.sub(hotspot_id, -5) == "Ascii") then
    -- Ascii-Map window changes
    ResizeRedrawWindowGeneric(winAscii, WINDATA[winAscii]["WIDTH"] + iDiffX, WINDATA[winAscii]["HEIGHT"] + iDiffY, "Ascii")
    -- And re-draw the Ascii data
    RedrawAsciiWindow()
    Redraw()
  elseif (string.sub(hotspot_id, -8) == "Hotspots") then
    -- Hotspots window changes
    ResizeRedrawWindowGeneric(winHotspots, WINDATA[winHotspots]["WIDTH"] + iDiffX, WINDATA[winHotspots]["HEIGHT"] + iDiffY, "Hotspots")
    -- And re-draw the Hotspots data
    RedrawHotspotsWindow()
    Redraw()
  end
  iThemeLayoutLocked = 0
end 

-- Re-draw generic windows with global drag handlers again
function ResizeRedrawWindowGeneric(winNewSize, iNewSizeX, iNewSizeY, sShortcut)
  WINDATA[winNewSize]["WIDTH"] = iNewSizeX
  WINDATA[winNewSize]["HEIGHT"] = iNewSizeY
  WindowResize(winNewSize, WINDATA[winNewSize]["WIDTH"], WINDATA[winNewSize]["HEIGHT"], iCOLOUR.black)
  -- Change the drag-area hotspot
  if (winNewSize ~= winComms) then
    WindowMoveHotspot(winNewSize, "zz_mw_" .. winNewSize .. "_movewindow_hotspot", 0, 0, WINDATA[winNewSize]["WIDTH"], WINDATA[winNewSize]["HEIGHT"])
  else
    WindowMoveHotspot(winComms, "zz_mw_" .. winComms .. "_movewindow_hotspot", 0, iTopCommsWindow, WINDATA[winComms]["WIDTH"], WINDATA[winComms]["HEIGHT"])
    WindowMoveHotspot(winComms, "hsCommsUp", WINDATA[winComms]["WIDTH"]-(SCROLL_BAR_WIDTH + 1), iTopCommsWindow, WINDATA[winComms]["WIDTH"]-1, SCROLL_BAR_WIDTH + iTopCommsWindow)
    WindowMoveHotspot(winComms, "hsCommsDown", WINDATA[winComms]["WIDTH"]-(SCROLL_BAR_WIDTH + 1), WINDATA[winComms]["HEIGHT"]-(SCROLL_BAR_WIDTH), WINDATA[winComms]["WIDTH"]-1, WINDATA[winComms]["HEIGHT"]-1)
    WindowMoveHotspot(winComms, "hsChatTabs", 0, 0, WINDATA[winComms]["WIDTH"], iTopCommsWindow)
  end
  -- And now update the window-edge areas
  UpdateResizableWindow(winNewSize, sShortcut, WINDATA[winNewSize]["WIDTH"], WINDATA[winNewSize]["HEIGHT"])
end


-- Re-draw the minimap window a new size
function ResizeRedrawWindowMinimap(iNewSizeX, iNewSizeY)
  WINDATA[winMinimap]["WIDTH"] = iNewSizeX
  WINDATA[winMinimap]["HEIGHT"] = iNewSizeY
  MINIMAP_WIDTH = WINDATA[winMinimap]["WIDTH"]
  MINIMAP_HEIGHT = WINDATA[winMinimap]["HEIGHT"]-winThemeData.TITLE_HEIGHT
  WindowResize(winMapRender, MINIMAP_WIDTH*iZoomData[iUseZoom][2], MINIMAP_HEIGHT*iZoomData[iUseZoom][2], iCOLOUR.black)
  MINIMAP_X = 0
  MINIMAP_Y = winThemeData.TITLE_HEIGHT
  MINIMAP_CX = math.floor(MINIMAP_WIDTH * 0.5)
  MINIMAP_CY = math.floor(MINIMAP_HEIGHT * 0.5)
  WindowResize(winMinimap, WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"], iCOLOUR.black)
  -- Change the drag-area hotspot
  WindowMoveHotspot(winMinimap, "zz_mw_" .. winMinimap .. "_movewindow_hotspot", 0, 0, WINDATA[winMinimap]["WIDTH"], winThemeData.TITLE_HEIGHT)
  -- Change the main map-area click area
  WindowMoveHotspot(winMinimap, "hsMapClick", 4, winThemeData.TITLE_HEIGHT, WINDATA[winMinimap]["WIDTH"] - 4, WINDATA[winMinimap]["HEIGHT"] - 4)
  -- And now update the window-edge areas
  UpdateResizableWindow(winMinimap, "Map", WINDATA[winMinimap]["WIDTH"], WINDATA[winMinimap]["HEIGHT"])
  -- Re-do the window title
  if (sQuowMapfiles[iCurMap] ~= nil) then
    RetitleWindow(winMinimap, sQuowMapfiles[iCurMap][2])
  else
    RetitleWindow(winMinimap, "Graphical Minimap")
  end
  -- Redraw the map
  RedrawMap()
end


-- Enabling the plugin
function OnPluginEnable()
  -- Always enable the map window
  local bAnyWindows = false
  if (WINDATA[winMinimap]["SHOW"] == true) then
    WindowShow(winMinimap, true)
    ClearMinimapWindow()
    RedrawMap()
    bAnyWindows = true
  else
    bMinimapHidden = true
  end
  -- Optional MDT window
  if (WINDATA[winMDT]["SHOW"] == true) then
    WindowShow(winMDT, true)
    RedrawMDTWindow()
    bAnyWindows = true
  end
  -- Optional vitals window
  if (WINDATA[winBars]["SHOW"] == true) then
    WindowShow(winBars, true)
    RedrawVitalsWindow()
    bAnyWindows = true
  end
  -- Optional XP window
  if (WINDATA[winXP]["SHOW"] == true) then
    WindowShow(winXP, true)
    RedrawXPWindow(true)
    bAnyWindows = true
  end
  -- Stats window
  if (WINDATA[winStats]["SHOW"] == true) then
    WindowShow(winStats, true)
    RedrawStatsWindow()
    bAnyWindows = true
  end
  -- Shields window
  if (WINDATA[winShields]["SHOW"] == true) then
    WindowShow(winShields, true)
    RedrawShieldsWindow()
    bAnyWindows = true
  end
  -- Ascii-Map window
  if (WINDATA[winAscii]["SHOW"] == true) then
    WindowShow(winAscii, true)
    RedrawAsciiWindow()
    bAnyWindows = true
  end
  -- Hotspots window
  if (WINDATA[winHotspots]["SHOW"] == true) then
    WindowShow(winHotspots, true)
    RedrawHotspotsWindow()
    bAnyWindows = true
  end
  -- Comms window
  if (WINDATA[winComms]["SHOW"] == true) then
    WindowShow(winComms, true)
    bCommsNeedsButtons = true
    RedrawCommsWindow()
    bAnyWindows = true
  end
  if (bAnyWindows == false) then
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar is running, but you have all windows set to hidden!")
    ColourNote(sCOLOUR.orange, "", "You can use '", sCOLOUR.cyan, "", "minimap show", sCOLOUR.orange, "", "' or '", sCOLOUR.cyan, "", "minimap reset", sCOLOUR.orange, "", "' to show the main window or reset all core windows.")
  elseif (WINDATA[winMinimap]["SHOW"] == false) then
    ColourNote(sCOLOUR.orange, "", "You have the main minimap window hidden.  Use '", sCOLOUR.cyan, "", "minimap show", sCOLOUR.orange, "", "' to display again.")
    ColourNote(sCOLOUR.silver, "", "Note:  MANY options and features of Cow Bar are controlled through the minimap window menu!")
  end
  Redraw()
end -- function OnPluginEnable


-- Disabling the plugin
function OnPluginDisable()
  -- Always hide all windows so we don't leave a mess on the screen
  WindowShow(winMinimap, false)
  WindowShow(winMDT, false)
  WindowShow(winBars, false)
  WindowShow(winXP, false)
  WindowShow(winStats, false)
  WindowShow(winShields, false)
  WindowShow(winComms, false)
  WindowShow(winAscii, false)
  WindowShow(winHotspots, false)
end -- function OnPluginDisable


-- Closing the plugin
function OnPluginClose()
  -- Called on plugin reinstalls, world close, mushclient exit
  -- Record combat stats
  if (iCurrentCombatStatSet ~= 0) then
    sSQL = "UPDATE combat_stats SET "
    for sColumn, sData in pairs(iQuowCombatStats[iCurrentCombatStatSet]) do
      if (sColumn ~= "set_name") then
        sSQL = sSQL .. sColumn .. "=" .. sData .. ","
      else
        sSQL = sSQL .. sColumn .. "='" .. EscapeSQL(sData) .. "',"
      end
    end
    sSQL = string.sub(sSQL, 1, -2)
    sSQL = sSQL .. " WHERE set_id=" .. iCurrentCombatStatSet
    assert(dbUserData:execute(sSQL))
  end
  -- Save your hotspot last-seen and notified values
  for iHotspotID, objHotspot in pairs(sHotspotData) do
    assert(dbUserData:execute("UPDATE user_hotspots SET time_seen=" .. objHotspot["time_seen"] .. ", notified=" .. objHotspot["notified"] .. " WHERE hotspot_id=" .. iHotspotID))
  end
  -- Save all the user variables
  SetAllSQLVariables()
  -- Close the database
  dbMap:close()
  dbUserData:close()
  -- If this plugin is currently enabled, call the disable cleanup function
  if GetPluginInfo (sMinimapID, 17) then
    OnPluginDisable()
  end -- if enabled
  -- Reset text rectangle
  TextRectangle(iOldTextRectangleData[1], iOldTextRectangleData[2], iOldTextRectangleData[3], iOldTextRectangleData[4], 1, 0, 0, 0, 0)
end -- function OnPluginClose


function OnPluginSaveState()
  -- Do not do database stuff here, as OnPluginClose is called FIRST!
  SetVariable ("enabled", tostring(GetPluginInfo(sMinimapID, 17)))
  -- Core state variables
  SetVariable("sQuowMapPath", tostring(sQuowMapPath))
  SetVariable("bDebugMode", tostring(bDebugMode))
end -- function OnPluginSaveState


-- Delete the minimap window and wipe it clean
function ClearMinimapWindow()
  WindowRectOp(winMinimap, miniwin.rect_fill, MINIMAP_X, MINIMAP_Y, MINIMAP_WIDTH, WINDATA[winMinimap]["HEIGHT"], iCOLOUR.black)
  if (sQuowMapfiles[iCurMap] ~= nil) then
    RetitleWindow(winMinimap, sQuowMapfiles[iCurMap][2])
  else
    RetitleWindow(winMinimap, "Graphical Minimap")
  end
end


-- Redraw the title bar and then write some text on it
function RetitleWindow(winTitlethis, sTitleBar)
  if (sTitleBar == nil) then
    if (bDebugMode == true) then
      Note("Tried to retitle a window to a nil value?")
    end
    sTitleBar = "Graphical Minimap"
  end
  -- Title bar
  DrawThemed3DRect(winTitlethis, 0, 0, WINDATA[winTitlethis]["WIDTH"], winThemeData.TITLE_HEIGHT)
  -- Title text
  local iFWidth = WindowTextWidth(winTitlethis, "titlefont"..winMinimap, sTitleBar)
  local iIndent = (WINDATA[winTitlethis]["WIDTH"] * 0.5) - (iFWidth * 0.5)
  WindowText(winTitlethis, "titlefont"..winMinimap, sTitleBar, iIndent, (winThemeData.TITLE_HEIGHT-iFontSizes[winMinimap]["lineheight"]) * 0.5, WINDATA[winTitlethis]["WIDTH"], winThemeData.TITLE_HEIGHT, winThemeData.ONFACE, false)
  -- Let mushclient know we need a non-urgent redraw of the windows because of this change
  Redraw()
end


-- Convert the long-descriptions table into triggers
for iKey, sLongLocation in ipairs(sQuowLocationsByLong) do
  local sShort, sLong, iThisFlags = tostring(sLongLocation[1]), tostring(sLongLocation[2]), 33
  AddTriggerEx(tostring(sShort), tostring(sLong), "", iThisFlags, -1, 0, "", "MapLongHandler", 12, 5)
  SetTriggerOption(sShort, "group", "module_minimap")
  if (sLongLocation[3] ~= nil and sLongLocation[3] == true) then
    SetTriggerOption(sShort, "multi_line", "y")
  end
end


-- **********************************************************
-- ***** Combat Line Regex Builder/Manipulator/CowTools *****
-- **********************************************************
iCustomCombatLinesNormal = 0
iCustomCombatLinesFailNormal = 0
iCustomCombatLinesSpecial = 0
iTotalCombatTriggers = 0

function CombatRegexBuilder()
  -- These are the primary texts that will be chopped up, thrown together, and turned into large regexes
  local sCombatTexts = {
    -- Normal attacks
      -- Blunt hits 1
    {"^<attacker> swings at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> taps <victim> in the <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> hits <victim> in the <bodypart> with <weapon>\\.$", false, 3},
    {"^<attacker> bruises <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> hits <victim> hard in the <bodypart> with <weapon>\\.$", false, 5},
    {"^<attacker> smashes <victim> in the <bodypart> with <weapon>\\.$", false, 6},
    {"^<attacker> crushes <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 7},
    {"^<attacker> mashes <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 8},
    -- Tentacle
    {"^<attacker> slaps at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> slaps at <victim> with <weapon>, (?>(?:(?>producing |creating |making |emitting |causing )(?>an audible wet |an amusing wet |a meaty wet |a loud wet )(?>sound|noise))|leaving a slimy stain|squirting slime onto (?>him|her|them|it) in the process|spraying slime all around)\\.$", false, 1},
    {"^<attacker> slaps <victim> in the <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> slaps <victim> in the <bodypart> with <weapon>, (?>(?:(?>producing |creating |making |emitting |causing )(?>an audible wet |an amusing wet |a meaty wet |a loud wet )(?>sound|noise))|leaving a slimy stain|squirting slime onto (?>him|her|them|it) in the process|spraying slime all around)\\.$", false, 2},
    {"^<attacker> violently slaps <victim> in the <bodypart> with <weapon>\\.$", false, 3},
    {"^<attacker> violently slaps <victim> in the <bodypart> with <weapon>, (?>(?:(?>producing |creating |making |emitting |causing )(?>an audible wet |an amusing wet |a meaty wet |a loud wet )(?>sound|noise))|leaving a slimy stain|squirting slime onto (?>him|her|them|it) in the process|spraying slime all around)\\.$", false, 3},
    {"^<attacker> delivers an eye-watering slap to <victim> in the <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> delivers an eye-watering slap to <victim> in the <bodypart> with <weapon>, (?>(?:(?>producing |creating |making |emitting |causing )(?>an audible wet |an amusing wet |a meaty wet |a loud wet )(?>sound|noise))|leaving a slimy stain|squirting slime onto (?>him|her|them|it) in the process|spraying slime all around)\\.$", false, 4},
    {"^<attacker> bashes <victim> hard in the <bodypart> with <weapon>\\.$", false, 5},
    {"^<attacker> bashes <victim> hard in the <bodypart> with <weapon>, (?>(?:(?>producing |creating |making |emitting |causing )(?>an audible wet |an amusing wet |a meaty wet |a loud wet )(?>sound|noise))|leaving a slimy stain|squirting slime onto (?>him|her|them|it) in the process|spraying slime all around)\\.$", false, 5},
    {"^<attacker> slams <victim> in the <bodypart> repeatedly with <weapon>\\.$", false, 6},
    {"^<attacker> slams <victim> in the <bodypart> repeatedly with <weapon>, (?>(?:(?>producing |creating |making |emitting |causing )(?>an audible wet |an amusing wet |a meaty wet |a loud wet )(?>sound|noise))|leaving a slimy stain|squirting slime onto (?>him|her|them|it) in the process|spraying slime all around)\\.$", false, 6},
    {"^<attacker> crushes <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 7},
    {"^<attacker> crushes <victim><vic_pl> <bodypart> with <weapon>, (?>(?:(?>producing |creating |making |emitting |causing )(?>an audible wet |an amusing wet |a meaty wet |a loud wet )(?>sound|noise))|leaving a slimy stain|squirting slime onto (?>him|her|them|it) in the process|spraying slime all around)\\.$", false, 7},
    -- Blunt hits 2
    {"^<attacker> strikes at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> taps <victim> in the <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> knocks <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 3},
    {"^<attacker> bruises <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> bashes <victim> in the <bodypart> with <weapon>\\.$", false, 5},
    {"^<attacker> beats <victim> in the <bodypart> with <weapon>\\.$", false, 6},
    {"^<attacker> smashes <weapon> into <victim><vic_pl> <bodypart>\\.$", false, 7},
    {"^<attacker> smashes <victim> in the <bodypart> with <weapon>\\.$", false, 8},
    -- Blunt hits 3
    {"^<attacker> strikes at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> taps <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> knocks <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 3},
    {"^<attacker> strikes <victim> lightly in the <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> strikes <victim> in the <bodypart> with <weapon>\\.$", false, 5},
    {"^<attacker> strikes <victim> hard in the <bodypart> with <weapon>\\.$", false, 6},
    {"^<attacker> batters <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 7},
    {"^<attacker> bludgeons <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 8},
    -- Urumis
    {"^<attacker> swings <weapon> at <victim>, nicking <v_his> <bodypart>\\.$", false, 2},
    {"^<attacker> swings <weapon> at <victim>, inflicting multiple nicks on <v_his> <bodypart>\\.$", false, 2},
    {"^<attacker> swings <weapon> at <victim>, cutting <v_his> <bodypart>\\.$", false, 3},
    {"^<attacker> swings <weapon> at <victim>, inflicting several cuts to <v_his> <bodypart>\\.$", false, 3},
    {"^<attacker> swings <weapon> at <victim>, slicing <v_his> <bodypart>\\.$", false, 4},
    {"^<attacker> swings <weapon> at <victim>, repeatedly slicing <v_his> <bodypart>\\.$", false, 4},
    {"^<attacker> swings <weapon> at <victim>, slashing <v_his> <bodypart>\\.$", false, 5},
    {"^<attacker> swings <weapon> at <victim>, inflicting several slashes to <v_his> <bodypart>\\.$", false, 5},
    {"^<attacker> swings <weapon> at <victim>, lacerating <v_his> <bodypart>\\.$", false, 6},
    {"^<attacker> swings <weapon> at <victim>, repeatedly lacerating <v_his> <bodypart>\\.$", false, 6},
    {"^<attacker> swings <weapon> at <victim> in a blur, tearing <v_his> <bodypart> into ribbons\\.$", false, 7},
    {"^<attacker> swings <weapon> at <victim> in a writhing blur of blades, mutilating <v_his> <bodypart>\\.$", false, 7},
    {"^<attacker> swings <weapon> at <victim> in a blur, maiming <v_his> <bodypart>\\.$", false, 8},
    {"^<attacker> swings <weapon> at <victim> in a blur of threshing blades, leaving <v_his> <bodypart> a maimed mess\\.$", false, 8},
    -- Rolling pins
    {"^<attacker> swipes at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> belts <victim> on the <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> wallops <victim> neatly on the <bodypart> with <weapon>\\.$", false, 3},
    {"^<attacker> smashes <victim> on the <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> batters <victim> on the <bodypart> with <weapon>\\.$", false, 5},
    {"^<attacker> smashes <victim> heavily on the <bodypart> with <weapon>\\.$", false, 6},
    -- Frying pan
    {"^<attacker> enthusiastically swings at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> swipes <victim> lightly on the <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> dings <victim> smartly on the <bodypart> with <weapon>\\.$", false, 3},
    {"^<attacker> belts <victim> hard on the <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> thumps <victim> heavily on the <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> winds up and mashes <victim> heavily on the <bodypart> with <weapon>\\.$", false, 5},
    -- Ornate Warhammer
    {"^<attacker> attempts to bash <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> attempts to smash <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> attempts to bludgeon <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> bashes <weapon> into <victim><vic_pl> <bodypart>\\.$", false, 2},
    {"^<attacker> bashes <victim><vic_pl> <bodypart> with <weapon>, knocking <v_him> back a step\\.$", false, 2},
    {"^<attacker> smashes <weapon> into <victim><vic_pl> <bodypart> with an audible crack\\.$", false, 3},
    {"^<attacker> smashes <weapon> into <victim>, eliciting a loud crack from <v_his> <bodypart>\\.$", false, 4},
    {"^<attacker> bludgeons <victim> with <weapon>, causing blood to spray from <v_his> <bodypart>\\.$", false, 5},
    {"^<attacker> bludgeons <victim> with <weapon>, leaving a bloody weal on <v_his> <bodypart>\\.$", false, 5},
    {"^<attacker> bludgeons <victim> with <weapon>, causing a sudden spurt of blood from <v_his> <bodypart>\\.$", false, 6},
    {"^<attacker> bludgeons <victim> with <weapon>, causing blood to splatter all over the area\\.$", false, 6},
    {"^<attacker> bludgeons <victim> with <weapon>, causing blood to flood out of <v_his> body\\.$", false, 7},
    {"^<attacker> bludgeons <victim> with <weapon>, making blood trickle out of <v_his> <bodypart>\\.$", false, 8},
    {"^<attacker> smashes <weapon> into <victim><vic_pl> <bodypart>, producing a series of unpleasant cracking noises\\.$", false, 7},
    {"^<attacker> bashes <victim><vic_pl> <bodypart> with <weapon>; you can hear the sound of breaking bones\\.$", false, 8},
    {"^<attacker> bashes <victim> with <weapon>; you can hear the sound of splintering bones\\.$", false, 8},
    {"^<attacker> smashes <weapon> into <victim><vic_pl> <bodypart> so hard that you can hear the sound of bones breaking\\.$", false, 8},
    -- Ukuleles
    {"^<attacker> attempts to hit <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> hits <victim><vic_pl> <bodypart> with <weapon> delivering a terrible sounding (?>C|A|F) (?>flat|sharp)\\.$", false, 2},
    {"^<attacker> hits <victim><vic_pl> <bodypart> with <weapon> producing a cheerful ukulele-solo\\.$", false, 4},
    {"^<attacker> hits <victim><vic_pl> <bodypart> with <weapon> producing an abstract A\\.$", false, 5},
    {"^<attacker> hits <victim><vic_pl> <bodypart> hard with <weapon> producing a nice A\\.$", false, 5},
    {"^<attacker> smacks <weapon> into <victim><vic_pl> <bodypart> causing a vibrating and fascinating sound\\.$", false, 5},
    {"^<attacker> mashes <victim><vic_pl> <bodypart> with <weapon>, generating a glass-shattering symphony in (?>E flat|C sharp) of Woe\\.$", false, 6},
    {"^<attacker> slams <weapon> repeatedly in <victim><vic_pl> <bodypart> performing an impressive aria of glass-shattering tones\\.$", false, 8},
    -- Whips
    {"^<attacker> flicks at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> flails at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> flicks <victim><vic_pl> <bodypart> gently with <weapon>\\.$", false, 2},
    {"^<attacker> lashes <victim><vic_pl> <bodypart> painfully with <weapon>\\.$", false, 3},
    {"^<attacker> raises a welt on <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> hit <victim><vic_pl> <bodypart> with <weapon>, causing a loud cracking noise\\.$", false, 5},
    {"^<attacker> flicks <weapon> expertly, cutting <victim><vic_pl> <bodypart> deeply\\.$", false, 6},
    {"^<attacker> causes a deep gash, striking <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 6},
    {"^<attacker> catches a tender spot on <victim><vic_pl> <bodypart> with <weapon>, leaving a flaming line of agony\\.$", false, 7},
    {"^<attacker> flay <victim><vic_pl> <bodypart> to tatters with <weapon>\\.$", false, 8},
    -- Seafoam whip
    {"^<attacker> flicks <weapon> at <victim>\\.$", false, 1},
    {"^<attacker> brushes <victim><vic_pl> <bodypart> gently with <weapon>, dampening .+ slightly\\.$", false, 2},
    {"^<attacker> raises a welt on <victim><vic_pl> <bodypart> with <weapon>, making .+ rather wet\\.$", false, 3},
    {"^<attacker> lashes <victim><vic_pl> <bodypart> painfully with <weapon>, leaving stinging wet .+\\.$", false, 4},
    {"^<attacker> snaps <victim><vic_pl> <bodypart> with <weapon>, leaving .+ slightly bruised and a little wet\\.$", false, 5},
    {"^<attacker> tears flesh off <victim><vic_pl> <bodypart> with <weapon>, leaving .+ bloody and soaked\\.$", false, 6},
    -- Holy Water Whips
    {"^<attacker> flicks at <victim> with <weapon>, sprinkling water everywhere\\.$", false, 1},
    {"^<attacker> raises a welt on <victim><vic_pl> <bodypart> with <weapon>, infusing the welt with water\\.$", false, 4},
    {"^<attacker> flay <victim><vic_pl> <bodypart> to tatters with <weapon>, spraying water everywhere\\.$", false, 8},
    -- Hooter of death
    {"^<attacker> bonks <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> honks at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> smacks <weapon> at <victim> causing their head to vibrate\\.$", false, 2},
    {"^<attacker> honks <weapon> at <victim> causing their head to vibrate\\.$", false, 3},
    {"^<attacker> honks at <victim> with <weapon>, making a deafening HONKKK\\.$", false, 4},
    {"^<attacker> mashes <victim> with <weapon>, making it emit a loud honk\\.$", false, 5},
    -- Dictionary of cussing
    --Bobby pokes fun of your relationships with goats.  You blush furiously but you deftly dodge out of the way.
    --Bobby exclaims  "Er... Bloody hell???"  You barely notice but you dodge out of the way.
    -- Yellow duster
    --You flap your yellow duster in such a way that the old farmer is momentarily blinded by the dust thrown into the air.
    --You flap your yellow duster in the old farmer's face but, although unable to defend, he somehow avoids the attack.
    --{"^<attacker> flaps <a_his> <weapon> in <victim> <victim><vic_pl> <bodypart>\\.$", false, 1},
    --{"^<attacker> flaps <a_his> <weapon> in such a way that <victim> is momentarily blinded by the dust thrown into the air\\.$", false, 2},
    -- Metal dragon
    {"^<attacker> brushes <victim> with a swing of <a_his> tail\\.$", true, 1},
    -- Conkers
    {"^<attacker> cracks <weapon> across <victim><vic_pl> knuckles\\.$", false, 2},
    {"^<attacker> whacks <weapon> between <victim><vic_pl> eyes\\.$", false, 3},
    {"^<attacker> smacks <victim> upside the head with <weapon>\\.$", false, 4},
    -- Antlers
    {"^<attacker> touches <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> prods at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> jabs at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> thrusts at <victim> with a pointy bit of <weapon>\\.$", false, 2},
    {"^<attacker> stabs <victim> in the <bodypart> with a pointy bit of <weapon>\\.$", false, 3},
    -- Escrow werewolves
    {"^<attacker> tears at <victim><vic_pl> <bodypart> with its claws\\.$", false, 1},
    {"^<attacker> bites at <victim><vic_pl> <bodypart>\\.$", false, 1},
    -- Monsters
    {"^<attacker> oozes at <victim>\\.$", false, 1},
    -- Jellies
    {"^<attacker> splatters <victim> with .+? slime\\.$", false, 1},
    -- Metal dragons
    {"^<attacker> taps <victim> with both of its wings\\.$", false, 1},
    {"^<attacker> claws lightly at <victim> with its claws\\.$", false, 1},
    -- Will o the wisp
    {"^<attacker> flickers at <victim>\\.$", false, 1},
    -- Eggplants
    {"^<attacker> kicks at <victim> with its little feet\\.$", false, 1},
    -- Moose
    -- Lit Torch
    {"^<attacker> attempts to burn <victim>\\.$", false, 1},
    {"^<attacker> smokes <victim>\\.$", false, 1},
    {"^<attacker> singes <victim>\\.$", false, 2},
    {"^<attacker> crisps <victim>\\.$", false, 3},
    {"^<attacker> scorches <victim>\\.$", false, 3},
    {"^<attacker> toasts <victim>\\.$", false, 4},
    {"^<attacker> chars <victim>\\.$", false, 4},
    {"^<attacker> burns <victim>\\.$", false, 5},
    {"^<attacker> fries <victim>\\.$", false, 5},
    {"^<attacker> roasts <victim>\\.$", false, 6},
    {"^<attacker> melts (?!in )<victim>\\.$", false, 6},
    {"^<attacker> incinerates <victim>\\.$", false, 7},
    {"^<attacker> cremates <victim>\\.$", false, 7},
    {"^<attacker> vapourises <victim>\\.$", false, 8},
    -- Holy weapon
    {"^<attacker> attempts to burn <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> touches <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 2},
    {"^<attacker> singes <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 3},
    {"^<attacker> gently scorches <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 4},
    {"^<attacker> scorches <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 4},
    {"^<attacker> burns <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 5},
    {"^<attacker> gives <victim><vic_pl> <bodypart> a painful burn with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 5},
    {"^<attacker> crisps <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 6},
    {"^<attacker> chars <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 6},
    {"^<attacker> sears <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 7},
    {"^<attacker> fries <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 7},
    {"^<attacker> roasts <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 8},
    {"^<attacker> incinerates <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 8},
    {"^<attacker> cremates <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 9},    
    {"^<attacker> vaporises <victim><vic_pl> <bodypart> with the (?>faint|pale|steady|flickering|bright|intense|incandescent) (?>lilac|violet|lavender|jade|chartreuse|emerald|saffron|amber|silver|ash grey|azure|cerulean|sapphire|tangerine|orange|crimson|ruby|vermilion) holy (?>light|flames) surrounding <weapon>\\.$", false, 9},   
    -- Slash hits 1
    {"^<attacker> slashes at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> snicks <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> scratches <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 3},
    {"^<attacker> nicks <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> cuts <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 5},
    {"^<attacker> slices <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 6},
    {"^<attacker> hacks <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 7},
    {"^<attacker> chops up <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 8},
    -- Slash hits 2
    {"^<attacker> slices at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> just manages to slice <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> slices <weapon> across <victim><vic_pl> <bodypart>\\.$", false, 3},
    {"^<attacker> shreds <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> slices <weapon> into <victim><vic_pl> <bodypart>\\.$", false, 5},
    {"^<attacker> takes a sliver off <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 6},
    {"^<attacker> slices <weapon> deeply into <victim><vic_pl> <bodypart>\\.$", false, 7},
    {"^<attacker> neatly fillets <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 8},
    -- Headless rider
    {"^<attacker> slices at <victim> with <weapon> leaving a trail of sparks in the air\\.$", false, 1},
    -- Missing = 2-5
    {"^<attacker> takes a sliver off <victim><vic_pl> <bodypart> with <weapon>, scorching the flesh underneath\\.$", false, 6},
    {"^<attacker> slices <weapon> deeply into <victim><vic_pl> <bodypart> leaving a bloody and charred mess\\.$", false, 7},
    {"^<attacker> neatly fillets <victim><vic_pl> <bodypart> with <weapon>, the sheer heat from the blade cauterising the wound instantly\\.$", false, 8},
    -- Axe hits 1
    {"^<attacker> swings <weapon> at (?!the torch as it falls)<victim>\\.$", false, 1},
    {"^<attacker> attempts to chop <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> chops at <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 3},
    {"^<attacker> chops <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> chops <weapon> into <victim><vic_pl> <bodypart>\\.$", false, 5},
    {"^<attacker> hacks into <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 6},
    {"^<attacker> chops <weapon> deeply into <victim><vic_pl> <bodypart>\\.$", false, 7},
    {"^<attacker> chops <victim><vic_pl> <bodypart> into pieces with <weapon>\\.$", false, 8},
    -- Pierce hits 1
    {"^<attacker> thrusts at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> barely hits <victim> in the <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> jabs <weapon> into <victim><vic_pl> <bodypart>\\.$", false, 3},
    {"^<attacker> pierces <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> pricks <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 5},
    {"^<attacker> impales <victim><vic_pl> <bodypart> on <weapon>\\.$", false, 6},
    {"^<attacker> skewers <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 7},
    {"^<attacker> runs <victim> through the <bodypart> with <weapon>\\.$", false, 8},
    {"^<attacker> makes a kebab of <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 9},
    -- Pierce hits 2
    {"^<attacker> swings at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> barely hits <victim> in the <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> jabs <weapon> into <victim><vic_pl> <bodypart>\\.$", false, 3},
    {"^<attacker> spikes <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> impales <victim><vic_pl> <bodypart> on <weapon>\\.$", false, 5},
    {"^<attacker> ventilates <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 6},
    {"^<attacker> exsanguinates <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 7},
    {"^<attacker> perforates <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 8},
    {"^<attacker> makes a mess of <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 9},
    -- Pierce hits 3
    {"^<attacker> thrusts at <victim> with <weapon>\\.$", false, 1},
    {"^<attacker> barely stabs <victim> in the <bodypart> with <weapon>\\.$", false, 2},
    {"^<attacker> stabs <victim> in the <bodypart> with <weapon>\\.$", false, 3},
    {"^<attacker> messily stabs <victim> in the <bodypart> with <weapon>\\.$", false, 4},
    {"^<attacker> stabs <victim> deeply in the <bodypart> with <weapon>\\.$", false, 5},
    {"^<attacker> perforates <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 6},
    {"^<attacker> pierces <victim><vic_pl> <bodypart> with <weapon>\\.$", false, 7},
    {"^<attacker> stabs <weapon> right through <victim><vic_pl> <bodypart>\\.$", false, 8},
    -- Unarmed blunt damage?
    {"^<attacker> swings at <victim>\\.$", false, 1},
    {"^<attacker> taps <victim> in the <bodypart>\\.$", false, 2},
    {"^<attacker> hits <victim> in the <bodypart>\\.$", false, 3},
    {"^<attacker> bruises <victim><vic_pl> <bodypart>\\.$", false, 4},
    {"^<attacker> hits <victim> hard in the <bodypart>\\.$", false, 5},
    {"^<attacker> smashes <victim> in the <bodypart>\\.$", false, 6},
    {"^<attacker> crushes <victim><vic_pl> <bodypart>\\.$", false, 7},
    {"^<attacker> mashes <victim><vic_pl> <bodypart>\\.$", false, 8},
    -- Punching unarmed
    {"^<attacker> punches at <victim>\\.$", false, 1},
    {"^<attacker> pokes <victim> in the <bodypart>\\.$", false, 2},
    {"^<attacker> tickles <victim> in the <bodypart>\\.$", false, 3},
    {"^<attacker> jabs <victim> in the <bodypart>\\.$", false, 4},
    {"^<attacker> hits <victim> in the <bodypart> with an uppercut\\.$", false, 5},
    {"^<attacker> hits <victim> in the <bodypart> with a cross\\.$", false, 6},
    {"^<attacker> hits <victim> in the <bodypart> with a vicious hook\\.$", false, 7},
    {"^<attacker> beats <victim><vic_pl> <bodypart> to a pulp\\.$", false, 8},
    -- Kicking unarmed
    {"^<attacker> kicks at <victim>\\.$", false, 1},
    {"^<attacker> kicks out at <victim>\\.$", false, 1},
    {"^<attacker> pokes (?!(?>his|her|its) tongue out|at a )<victim>\\.$", false, 2},
    {"^<attacker> tickles <victim> in the <bodypart> with <a_his> toes\\.$", false, 3},
    {"^<attacker> pokes <victim> with <a_his> foot\\.$", false, 2},
    {"^<attacker> kicks <victim> in the <bodypart>\\.$", false, 4},
    {"^<attacker> viciously boots <victim> in the <bodypart>\\.$", false, 5},
    {"^<attacker> kicks <victim> in the <bodypart>\\.$", false, 6},
    {"^<attacker> viciously kicks <victim> in the <bodypart>\\.$", false, 7},
    {"^<attacker> kicks <victim><vic_pl> <bodypart> into a bloody mess\\.$", false, 8},
    -- Newer special flying knee unarmed stuff
    {"^<attacker> lifts <a_his> knee at <victim>\\.$", false, 1},
    {"^<attacker> deals <victim> a glancing blow to the <bodypart> with <a_his> knee\\.$", false, 2},
    {"^<attacker> knees <victim> painfully in the <bodypart>\\.$", false, 3},
    {"^<attacker> violently knees <victim> in the <bodypart>\\.$", false, 4},
    {"^<attacker> crunches <a_his> knee into <victim><vic_pl> <bodypart>\\.$", false, 5},
    {"^<attacker> pounds <victim> in the <bodypart> with a straight knee strike\\.$", false, 6},
    {"^<attacker> leaps at <victim> smashing .+? <bodypart> with a flying knee attack\\.$", false, 7},
    -- Throwing weapons
    {"^<attacker> pierces <victim><vic_pl> <bodypart>\\.$", false, 2},
    -- Creeping Doom
    {"^<attacker> bugs attempt to converge on <victim>\\.$", true, 1},
    {"^<attacker> cloud attempts to smother <victim>\\.$", true, 1},
    {"^<attacker> cloud moves hungrily toward <victim><vic_pl> tasty flesh\\.$", true, 1},
    {"^<attacker> bugs converges on <victim>\\.$", true, 2},
    {"^<attacker> bugs pass over <victim>, their bites raising many welts\\.$", true, 3},
    {"^<attacker> bugs cover <victim>, biting and raising angry red welts\\.$", true, 4},
    {"^<attacker> swirl around <victim>, biting and stinging <v_him> painfully\\.$", true, 5},
    {"^<attacker> whirl around <victim>, their bites leaving small marks\\.$", true, 6},
    {"^<attacker> of insects descend upon <victim>, smothering with their bodies\\.$", true, 7},
    {"^<attacker> of insects traps <victim> snacking on the <wild><vic_pl> flesh\\.$", true, 7},
    {"^<attacker> cloud smothers <victim>\\.$", true, 2},
    {"^<attacker> cloud lands, biting <victim>\\.$", true, 3},
    {"^<attacker> cloud fills <victim><vic_pl> <bodypart>\\.$", true, 3},
    {"^<attacker> cloud nibbles, gnawing at <victim><vic_pl> <bodypart>\\.$", true, 4},
    {"^<attacker> cloud nibbles, biting <victim><vic_pl> <bodypart>\\.$", true, 4},
    {"^<attacker> cloud twirls around <victim>, biting again and again\\.$", true, 5},
    {"^<attacker> cloud spins around <victim>, buzzing as the insects bite\\.$", true, 6},
    {"^<attacker> cloud nibbles, chewing nastily at <victim><vic_pl> <bodypart>\\.$", true, 7},
    {"^<attacker> cloud lands, biting <victim><vic_pl> <bodypart> again and again\\.$", true, 8},
    {"^<attacker> cloud covers <victim><vic_pl> <bodypart> with humming, buzzing bodies\\.$", true, 9},
    {"^<attacker> cloud lands, biting <victim> and leaving bloody wounds\\.$", true, 9},
    {"^<attacker> cloud smothers <victim>, humming bodies making it hard to breathe\\.$", true, 9},
    {"^<attacker> cloud bites <victim> all over, drawing blood again and again\\.$", true, 9},
    -- Rat king
    {"^<attacker> pounces at <victim>\\.$", true, 1},
    -- Badger
    {"^<attacker> bites <victim> with <a_his> pointy teeth\\.$", true, 1},
    -- Stone palm
    {"^<attacker> attempts to prod <victim> with one of its fronds\\.$", true, 1},
    {"^<attacker> attempts to drop a stone nut on <victim>\\.$", true, 1},
    -- Basilisk
    {"^<attacker> flakes some of <victim><vic_pl> <bodypart> off with its slime\\.$", true, 1},
    -- Special "fighter" NPC moves
    {"^<attacker> tries to headbutt <victim>\\.$", true, 1},
    {"^<attacker> tries to poke <victim> in the eye\\.$", true, 1},
    {"^<attacker> extends a finger and pokes <victim> in the eye with a SPLOINK\\.$", true, 1},
    {"^<attacker> grabs <victim> roughly and headbutts <v_him> with a sharp CRACK\\.$", true, 1},
    -- Wrestling
    {"^<attacker> grabs for <victim>\\.$", false, 1},
    {"^<attacker> grapples with <victim>\\.$", false, 2},
    {"^<attacker> catches <victim> in an arm lock\\.$", false, 3},
    {"^<attacker> grabs <victim> around the neck\\.$", false, 4},
    {"^<attacker> pokes <victim> in the face\\.$", false, 5},
    {"^<attacker> throws <victim> to the ground\\.$", false, 6},
    {"^<attacker> flings <victim> over <a_his> shoulder\\.$", false, 7},
    {"^<attacker> punches <victim> in the stomach\\.$", false, 8},
    {"^<attacker> twists <victim><vic_pl> arm painfully\\.$", false, 9},
    {"^<attacker> thumps <victim><vic_pl> head hard\\.$", false, 10},
    {"^<attacker> kicks <victim> in the back\\.$", false, 11},
    {"^<attacker> jumps up and down on <victim>\\.$", false, 12},
    {"^<attacker> slams <victim><vic_pl> head against the ground\\.$", false, 13},
    -- Scorpion stingers (scorpions)
    {"^<attacker> stings <victim><vic_pl> <bodypart>\\.$", true, 1},
    -- Priesty Whirlwinds
    --The colossal whirlwind of pebbles chokes the bandit with pebbles.
    {"^<attacker> attempts to whip <victim> with some debris\\.$", true, 1},
    {"^<attacker> attempts to caress <victim> with some dirty air\\.$", true, 1},
    {"^<attacker> attempts to choke <victim> in its dust\\.$", true, 1},
    {"^<attacker> nudges <victim> with some debris\\.$", true, 2},
    {"^<attacker> blows on <victim> causing <v_him> to stumble\\.$", true, 2},
    {"^<attacker> swirls around <victim> making <victim><vic_pl> <bodypart> hurt\\.$", true, 2},
    {"^<attacker><att_pl> swirling winds spin <victim> in circles\\.$", true, 3},
    {"^<attacker> swirls some dirt into <victim><vic_pl> <bodypart>\\.$", true, 4},
    {"^<attacker> whips <victim><vic_pl> <bodypart> with some debris\\.$", true, 4},
    {"^<attacker> chokes <victim> with dust\\.$", true, 4},
    {"^<attacker> debris whips around <victim>, pummelling <v_him>\\.$", true, 4},
    {"^<attacker><att_pl> huge gusts knocks <victim> to the ground\\.$", true, 4},
    {"^<attacker> shoves a large chunk of debris down <victim><vic_pl> throat\\.$", true, 4},
    {"^<attacker> whips up a really nice piece of debris and slams <victim> with it\\.$", true, 5},
    {"^<attacker> pummels <victim> with strong winds\\.$", true, 5},
    {"^<attacker> summons an extremely huge wind\\.  The wind pulverises <victim>\\.$", true, 5},
    -- Snakey coily animals (anaconda)
    {"^<attacker> attempts to wrap <a_himself> around <victim><vic_pl> <bodypart>\\.$", true, 1},
    {"^<attacker> wraps <a_himself> around <victim><vic_pl> <bodypart> and squeezes\\.$", true, 2},
    -- Evil cabbage frongs
    {"^<attacker> swishes at <victim><vic_pl> <bodypart> with a frond\\.$", true, 1},
    {"^<attacker> slashes <victim><vic_pl> <bodypart> with <a_his> fronds\\.$", true, 2},
    {"^<attacker> climbs onto <victim> and cuts <v_his> <bodypart> with a sharp frond\\.$", true, 3},
    {"^<attacker> lacerates <victim><vic_pl> <bodypart> with a frond\\.$", true, 4},
    -- Hind-leg hoofies (giraffes)
    {"^<attacker> lashes out at <victim> with <a_his> hind legs\\.$", true, 1},
    {"^<attacker> lashes out with <a_his> hind legs, shattering <victim><vic_pl> <bodypart>\\.$", true, 2},
    -- Tusked animals (warthogs)
    {"^<attacker> scratches at <victim><vic_pl> <bodypart> with one tusk\\.$", true, 1},
    {"^<attacker> furrows <victim><vic_pl> <bodypart> with one slavering tusk\\.$", true, 2}, 
    {"^<attacker> slashes at <victim><vic_pl> <bodypart> with <a_his> dripping tusks\\.$", true, 3},
    {"^<attacker> gouges <victim><vic_pl> <bodypart> with <a_his> slavering tusks\\.$", true, 4},
    {"^<attacker> tears <victim><vic_pl> <bodypart> open with <a_his> filthy tusks\\.$", true, 5},
    -- Hippo
    {"^<attacker> attempts to grab <victim> in <a_his> jaws\\.$", true, 1},
    {"^<attacker> attempts to charge into <victim>\\.$", true, 1},
    -- Bull elephant charging
    {"^<attacker> charges at <victim>\\.$", true, 1},
    {"^<attacker> stands on <a_his> hind legs and attempts to crash down on <victim>\\.$", true, 1},
    {"^<attacker> charges <victim> and strikes <v_him>\\.$", true, 2},
    {"^<attacker> swings <a_his> trunk at <victim>, hitting <v_his> <bodypart> hard\\.$", true, 3},
    --Tail whipping
    {"^<attacker> swings <a_his> tail at <victim>\\.$", true, 1},
    {"^<attacker> taps <victim> in the <bodypart> with <a_his> tail\\.$", true, 2},
    {"^<attacker> slaps <victim> in the <bodypart> with <a_his> tail\\.$", true, 2},
    {"^<attacker> bruises <victim><vic_pl> <bodypart> with <a_his> tail\\.$", true, 2},
    {"^<attacker> hits <victim> hard in the <bodypart> with <a_his> tail\\.$", true, 2},
    {"^<attacker> bashes <victim> in the <bodypart> with <a_his> tail\\.$", true, 2},
    {"^<attacker> smashes <a_his> tail into <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> sends <victim> reeling with a powerful blow to the <bodypart> with <a_his> tail\\.$", true, 2},
    -- T-Rex Attacks
    {"^<attacker> nips at <victim> with teeth the length of a child's forearm\\.$", true, 1},
    {"^<attacker> rakes at <victim> with one big foot\\.$", true, 1},
    {"^<attacker> slashes <victim><vic_pl> <bodypart> to shreds with one powerful clawed foot\\.$", true, 3},
    {"^<attacker> grabs <victim><vic_pl> <bodypart> with <a_his> enormous jaws and shakes vigorously\\.$", true, 4},
    {"^<attacker> lowers <a_his> massive head and delicately bites <victim> in half\\.$", true, 5},
    -- More animals with a hoofie, like a... MOO COW
    {"^<attacker> kicks out at <victim>\\.$", true, 1},
    {"^<attacker> taps <victim> in the <bodypart> with <a_his> hoof\\.$", true, 2},
    {"^<attacker> kicks <victim> in the <bodypart> with <a_his> hoof\\.$", true, 2},
    {"^<attacker> bruises <victim><vic_pl> <bodypart> with <a_his> hoof\\.$", true, 2},
    {"^<attacker> hits <victim> hard in the <bodypart> with <a_his> hoof\\.$", true, 2},
    {"^<attacker> smashes <victim> in the <bodypart> with <a_his> hoof\\.$", true, 2},
    {"^<attacker> crushes <a_his> hoof into <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> mashes <victim><vic_pl> <bodypart> with <a_his> hoof\\.$", true, 2},
    -- Horny animals
    {"^<attacker> attempts to gore <victim> with <a_his> horns\\.$", true, 1},
    {"^<attacker> prods <victim> in the <bodypart> with <a_his> horns\\.$", true, 2},
    {"^<attacker> pokes <victim> in the <bodypart> with <a_his> horns\\.$", true, 2},
    {"^<attacker> butts <victim> in the <bodypart> with <a_his> horns\\.$", true, 2},
    {"^<attacker> pierces <victim> deeply in the <bodypart> with <a_his> horns\\.$", true, 2},
    {"^<attacker> rams <victim> in the <bodypart> with <a_his> horns\\.$", true, 2},
    {"^<attacker> gores <victim><vic_pl> <bodypart> with <a_his> horns\\.$", true, 2},
    {"^<attacker> impales <victim><vic_pl> <bodypart> on <a_his> horns\\.$", true, 2},
    -- Naughty tusk animals
    {"^<attacker> attempts to gore <victim> with <a_his> tusks\\.$", true, 1},
    {"^<attacker> prods <victim><vic_pl> <bodypart> with <a_his> tusks\\.$", true, 2},
    {"^<attacker> pokes <victim> in the <bodypart> with <a_his> tusks\\.$", true, 2},
    {"^<attacker> jabs <a_his> tusks into <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> pierces <victim><vic_pl> <bodypart> with <a_his> tusks\\.$", true, 2},
    {"^<attacker> stabs <a_his> tusks deeply into <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> gores <victim><vic_pl> <bodypart> with <a_his> tusks\\.$", true, 2},
    {"^<attacker> impales <victim><vic_pl> <bodypart> on <a_his> tusks\\.$", true, 2},
    -- Lion paws
    --You claw the city guard's stomach.
    --You rake at Joe Corrola with your claws but he just dodges out of the way.
    --You claw the muscular soldier's right arm but her large metal shield absorbs some of the blow.

    -- Clawed animals
    {"^<attacker> rakes at <victim> with <a_his> claws\\.$", false, 1},
    {"^<attacker> snicks <victim><vic_pl> <bodypart> with <a_his> claws\\.$", false, 2},
    {"^<attacker> scratches <victim><vic_pl> <bodypart> with <a_his> claws\\.$", false, 2},
    {"^<attacker> nicks <victim><vic_pl> <bodypart> with <a_his> claws\\.$", false, 2},
    {"^<attacker> claws <victim><vic_pl> <bodypart>\\.$", false, 2},
    {"^<attacker> slices <victim><vic_pl> <bodypart> up with <a_his> claws\\.$", false, 2},
    {"^<attacker> hacks <victim><vic_pl> <bodypart> up with <a_his> claws\\.$", false, 2},
    {"^<attacker> cuts <victim><vic_pl> <bodypart> into small pieces with <a_his> claws\\.$", false, 2},
    -- Bitey animals
    {"^<attacker> bites at <victim>\\.$", true, 1},
    {"^<attacker> chews on <victim><vic_pl> (?!cud|cat|keyboard|code|nose|frog|toe|ankles|finger|bones)<bodypart>\\.$", true, 2},
    {"^<attacker> munches on <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> gashes <victim><vic_pl> <bodypart> with <a_his> teeth\\.$", true, 2},
    {"^<attacker> rips flesh off <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> tears deeply into <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> rips <victim><vic_pl> <bodypart> to pieces with <a_his> teeth\\.$", true, 2},
    {"^<attacker> rends huge chunks of flesh from <victim><vic_pl> <bodypart>\\.$", true, 2},
    -- Pecky bird animals
    {"^<attacker> pecks at <victim> with <a_his> beak\\.$", true, 1},
    {"^<attacker> snicks <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> scratches <victim><vic_pl> <bodypart> with <a_his> beak\\.$", true, 2},
    {"^<attacker> pecks <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> viciously pecks <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> gouges a hole in <victim><vic_pl> <bodypart> with <a_his> beak\\.$", true, 2},
    {"^<attacker> slices <victim><vic_pl> <bodypart> with <a_his> beak\\.$", true, 2},
    {"^<attacker> slices <victim><vic_pl> <bodypart> into small bits with <a_his> beak\\.$", true, 2},
    -- Nippy nasty bitey animals
    {"^<attacker> attempts to bite <victim>\\.$", true, 1},
    {"^<attacker> nips <victim> in the <bodypart>\\.$", true, 2},
    {"^<attacker> nibbles at <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> bites <victim> in the <bodypart>\\.$", true, 2},
    {"^<attacker> sinks <a_his> teeth into <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> bites into <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> sinks <a_his> teeth deep into <victim><vic_pl> <bodypart>\\.$", true, 2},
    {"^<attacker> bites deeply into <victim><vic_pl> <bodypart>, splintering <v_his> bones\\.$", true, 2},
    -- Or fang equivalent
    {"^<attacker> sinks <a_his> fangs deeply into <victim>\\.$", true, 2},
    -- Special attacks
    -- Ramming weapons
    {"^<attacker> (?>very weakly |weakly |very lightly |lightly |firmly |painfully |forcefully |stingingly |ferociously |brutally |devastatingly )ramming <weapon> into <victim><vic_pl> <bodypart>\\.$", false, 1, true},
    {"^<attacker> ramming <weapon> into <victim><vic_pl> <bodypart>(?> very weakly| weakly| very lightly| lightly| firmly| painfully| forcefully| stingingly| ferociously| brutally| devastatingly)?\\.$", false, 1, true},
    {"^<attacker> ramming <weapon> right through <victim><vic_pl> <bodypart>(?> very weakly| weakly| very lightly| lightly| firmly| painfully| forcefully| stingingly| ferociously| brutally| devastatingly)?\\.$", false, 1, true},
    -- Special kicks
    {"^<attacker> swinging <a_his> foot upward to kick <victim> (?>very weakly |weakly |very lightly |lightly |firmly |painfully |forcefully |stingingly |ferociously |brutally |devastatingly )?in the <bodypart>\\.$", false, 1, true},
    {"^<attacker> raising <a_his> leg and stamping down (?>very weakly |weakly |very lightly |lightly |firmly |painfully |forcefully |stingingly |ferociously |brutally |devastatingly )?on <victim><vic_pl> <bodypart>\\.$", false, 1, true},
    {"^<attacker> lifting <a_his> foot and stomping (?>very weakly |weakly |very lightly |lightly |firmly |painfully |forcefully |stingingly |ferociously |brutally |devastatingly )?on <victim><vic_pl> <bodypart>\\.$", false, 1, true},
    {"^<attacker> swinging <a_his> foot to kick <victim> (?>very weakly |weakly |very lightly |lightly |firmly |painfully |forcefully |stingingly |ferociously |brutally |devastatingly )?in the <bodypart>\\.$", false, 1, true},
    {"^<attacker> spinning and landing a (?>very weak |weak |very light |light |firm |painful |forceful |stinging |ferocious |brutal |devastating )?side kick on <victim><vic_pl> <bodypart>\\.", false, 1, true},
    -- Special punches
    {"^<attacker> ducking to drive <a_his> fist (?>very weakly |weakly |very lightly |lightly |firmly |painfully |forcefully |stingingly |ferociously |brutally |devastatingly )?into <victim><vic_pl> <bodypart>\\.$", false, 1, true},
    {"^<attacker> giving <victim> a (?>very weak |weak |very light |light |firm |painful |forceful |stinging |ferocious |brutal |devastating )?punch to <v_his> <bodypart>\\.$", false, 1, true},
    {"^<attacker> giving <victim> a (?>very weak |weak |very light |light |firm |painful |forceful |stinging |ferocious |brutal |devastating )?jab to the <bodypart>\\.$", false, 1, true},
    {"^<attacker> catching <victim> with a (?>very weak |weak |very light |light |firm |painful |forceful |stinging |ferocious |brutal |devastating )?combination punch, delivered to the <bodypart>\\.$", false, 1, true},
    {"^<attacker> delivering a (?>very weak |weak |very light |light |firm |painful |forceful |stinging |ferocious |brutal |devastating )?punch to <victim><vic_pl> <bodypart>\\.$", false, 1, true},
    {"^<attacker> punching <victim> (?>very weakly |weakly |very lightly |lightly |firmly |painfully |forcefully |stingingly |ferociously |brutally |devastatingly )?in the <bodypart>\\.$", false, 1, true},
    {"^<attacker> catching <victim> with a (?>very weak |weak |very light |light |firm |painful |forceful |stinging |ferocious |brutal |devastating )?uppercut\\.$", false, 1, true},
    {"^<attacker> hitting <victim> with a (?>very weak |weak |very light |light |firm |painful |forceful |stinging |ferocious |brutal |devastating )?roundhouse punch to the <bodypart>\\.$", false, 1, true},
    -- Combo or punch/kick moves
    {"^<attacker> driving <a_his> (?>fist|foot) (?>very weakly |weakly |very lightly |lightly |firmly |painfully |forcefully |stingingly |ferociously |brutally |devastatingly )?into <victim><vic_pl> <bodypart>\\.$", false, 1, true},
    {"^<attacker> delivering a (?>very weak |weak |very light |light |firm |painful |forceful |stinging |ferocious |brutal |devastating )?(?>jab|snap kick) to <victim><vic_pl> <bodypart>\\.$", false, 1, true},
    {"^<attacker> landing a (?>very weak |weak |weak |very light |light |firm |painful |forceful |stinging |ferocious |brutal |devastating )?(?>punch in|kick on) <victim><vic_pl> <bodypart>\\.$", false, 1, true},
    {"^<attacker> hitting the side of <victim><vic_pl> <bodypart> (?>very weakly |weakly |very lightly |lightly |firmly |painfully |forcefully |stingingly |ferociously |brutally |devastatingly )?with a (?>roundhouse kick|cross)\\.$", false, 1, true},
    {"^<attacker> hitting <victim> (?>in|on) the <bodypart> with a (?>very weak |weak |very light |light |firm |painful |forceful |stinging |ferocious |brutal |devastating )?(?>punch|kick|roundhouse kick)\\.$", false, 1, true},
  }

  -- No fancy regexing for these, just need converting to incoming, outgoing, and third party
  local sStandaloneTexts = {
    -- Ukulele
    {"<WEAPON2> makes a dull sound through the air towards <victim>", 2, true},
    {"You hear a clear C as <attacker> bash(es)? <victim><vic_pl> <bodypart> with <weapon>", 2},
    -- Special hooter messages
    {"<WEAPON2> produces such a loud noise, that <victim><vic_pl> eyes bulge out of <v_his> head", 2},
    -- Worm sword, true at the end means it's a line that CAN be defended
    {"<WEAPON2> slithers at <victim>", 2, true},
    {"<WEAPON2> wobbles at <victim>", 2, true},
    {"<WEAPON2> wiggles at <victim>", 2, true},
    {"<WEAPON2> tentatively strokes <victim>", 2, true},
    {"<WEAPON2> tickles <victim><vic_pl> <bodypart>", 2},
    {"<WEAPON2> gently strokes <victim><vic_pl> <bodypart>", 2},
    {"<WEAPON2> probes around in <victim><vic_pl> throat, looking for <v_his> tonsils", 2},
    {"<WEAPON2> thrusts itself down <victim><vic_pl> throat, making it difficult for <v_him> to breathe", 2},
    {"<WEAPON2> forces itself down <victim><vic_pl> throat and into <v_his> stomach", 2},
    {"<WEAPON2> jams itself down <victim><vic_pl> throat, decimating <v_his> small intestine", 2},
    {"<WEAPON2> wiggles through the air, wraps itself round <victim><vic_pl> <bodypart> and irritates <v_his> bits", 2},
    {"<WEAPON2> wiggles through the air, wraps itself round <victim><vic_pl> <bodypart> and pulls <v_him> apart", 2},
    {"<WEAPON2> whacks <victim> in the <bodypart>", 2},
    {"<WEAPON2> lovingly wraps itself around <victim> and throttles <v_him>", 2},
    {"<WEAPON2> enthusiastically wraps itself around <victim>, crushing <v_him>", 2},
    {"<WEAPON2> wraps itself around <victim> and crushes the life out of <v_him>", 2},
    {"<WEAPON2> jumps down <victim><vic_pl> <bodypart>, suffocating <v_him> with nauseating slime", 2},
    {"<WEAPON2> slithers over <victim><vic_pl> <bodypart>, leaving behind some disgusting slime", 2},
    {"<WEAPON2> slithers (?>disgustingly|painfully) all over <victim><vic_pl> <bodypart>, (?>melting into|searing|burning|dripping slime on) <v_him>(?: with (?:acidic slime|its slimy bits))?", 2},
    {"<WEAPON2> slithers (?>disgustingly|painfully) all over <victim><vic_pl> <bodypart>, scorching deep holes in <v_his> <bodypart> with acidic slime", 2},
    {"<WEAPON2> twists itself into a wobbly arcane symbol\\.  A dozen (?>small|tiny) worms pop their heads out of the ground and titter at <victim>", 2, true},
    {"<WEAPON2> twists itself into an arcane symbol\\.  A hundred small worms pop their heads out of the ground and attack <victim><vic_pl><bodypart>", 2},
    {"<WEAPON2> twists itself into an arcane symbol\\.  A few thousand (?>large|tumescent) worms jump out of the ground and gnaw on <victim>", 2},
    {"<WEAPON2> twists itself into an arcane symbol\\.  A million and one HUGE worms jump out of the ground, swarm all over <victim>, and eat <v_him> alive", 2},
    -- Below here are "Specials" (the 1 at the end), it means they count for special stats and CANNOT be defended atm (without some code change)
    -- Sabre flicks
    {"<ATTACKER> flicks? the point of <weapon> at <victim>, scoring a hit on", 1},
    -- Feint
    {"<ATTACKER> moves? as though about to launch a powerful attack on <victim>\\.  <VICTIM> falls? for <a_his> feint, leaving <v_him> (?>momentarily )?off balance", 1},
    {"<ATTACKER> moves? towards? <victim> as though about to launch a powerful attack\\.  <VICTIM> prepares? to defend and, realising too late that it was just a feint, <v_is> left off balance", 1},
    -- Shoves and trips
    {"<ATTACKER> (?>shoves?|trips?) <victim>, (?>causing <v_him> to stumble(?: slightly)?|sending <v_him> crashing to the ground)", 1},
    -- Crushing death specials
    {"With a brutal swipe of <weapon2>, <victim> is mashed to the ground\\.  <V_HIS> death throes are, unsurprisingly, short-lived", 1},
    {"A final blow from <weapon2> tears <victim><vic_pl> jaw from <v_his> skull\\.  Perhaps a closed casket would be best", 1},
    {"<VICTIM><vic_pl> skull explodes beneath a powerful blow from <weapon2>, flinging blood, bone and brain several feet through the air, coating the area in gore and leaving a convulsing corpse on the ground\\.  This is why <attacker2> never gets? hired as an interior decorator", 1},
    {"<ATTACKER><at_pl> final blow with <weapon> hits <victim> with a sickening crunch as bones shatter, sending <v_him> sprawling lifelessly", 1},
    {"As <victim> absorbs a blow from <weapon2>, <v_his> body gives way and folds like an accordion\\.  Perhaps a skilled musician could play a triumphant jig on it", 1},
    {"<WEAPON2> collides with <victim><vic_pl> body at such a speed that it reduces <v_his> carcass to a pulp of tissue, limbs and indeterminate organs\\.  All that remain are\\.\\.\\. remains", 1},
    {"<VICTIM> suffers the full brunt of a blow from <weapon2>, reducing <v_his> resulting cadaver to something more resembling a drawing by an angry child than anything once alive", 1},
    {"Chunks of flesh are hurled into the air by the force of <attacker><at_pl> final swing of <weapon>, leaving <victim> in several bloody pieces on the ground\\.  The gravedigger isn't going to be best pleased", 1},
    {"As <weapon2> smash(es)? into <victim><vic_pl> stomach, <v_he> doubles over\\.  The one thing learned from <v_his> death is that <v_he> had a kebab for supper", 1},
    {"<ATTACKER> launch(es)? a powerful attack with <weapon>\\.  Something between a squelch and a crunch emanates from <victim> as <v_his> corpse collapses in a graceless heap", 1},
    {"<ATTACKER> turns? <victim><vic_pl> <bodypart> into a pulpy mess of flesh and bone with a powerful swing of <weapon>, killing <v_him> outright", 1},
    {"<ATTACKER> launch(es)? a powerful attack with <weapon>\\.  <victim> succumbs to <a_his> battery and dies, concave in all the wrong places", 1},
    {"<ATTACKER> slams? <weapon> into <victim> with enough force to lift <v_him> a foot off the ground, spinning in a slow circle before <v_he> lands in a messy, bloodied heap", 1},
    {"A series of sharp but muffled cracks can be heard as <victim><vic_pl> ribcage is pulverised by a crushing blow from <weapon2>", 1},
    {"The top of <victim><vic_pl> skull collapses in on itself as <attacker> crush(es)? it with <weapon>, sending chunks of brain and bone splattering about", 1},
    {"As <weapon2> connects, <victim> watch(es)? <v_his> ribs splinter and cave in, puncturing <v_his> lungs and other organs before <v_he> collapses? with a gurgle, flecks of bloody foam on <v_his> lips", 1},
    {"<VICTIM> stumbles? as a colossal lump of stone is torn loose from <v_his> frame by <weapon2>\\.  There is a long moment where nothing happens before <v_he> collapses? into a mound of rubble", 1},
    {"<VICTIM> suddenly finds? <v_himself> much shorter \\(and significantly more dead\\) as <attacker> slams? <weapon> down on <v_his> <bodypart>", 1},
    -- Impale death specials
    {"As <attacker> drives? <weapon> into <victim><vic_pl> <bodypart> and yanks? it free, the wound spurts blood relentlessly, draining <v_his> last drops of life\\.  Clean-up on aisle ", 1},
    {"<ATTACKER> salutes? <victim> with <weapon> before driving it into <v_his> <bodypart> with a flick of <a_his> wrist", 1},
    {"As <attacker> skewers? <v_him>, <victim> struggles? against <weapon> briefly, until gravity catches up to <v_him>, dragging <v_him> to the ground and off the weapon", 1},
    {"<ATTACKER> fatally impales? <victim> on <weapon>, <v_his> lifeblood gushing from the wound as <a_he> withdraws? <a_his> weapon", 1},
    {"<ATTACKER> runs? <weapon> right through <victim>, and <v_he> stands?, bleeding profusely, for a few seconds before collapsing lifelessly", 1},
    {"<ATTACKER> skewers? <victim><vic_pl> <bodypart> with <weapon>, causing several jets of blood to spray out, covering the area in a fine red mist\\.  In another medium, this might qualify as abstract art", 1},
    {"<ATTACKER> shoves? <weapon> right through <victim><vic_pl> <bodypart>, the bloodied weapon bursting messily out the other side", 1},
    {"<ATTACKER> bur(?>y|ies) <weapon> in <victim><vic_pl> <bodypart>, then pulls? it free with a pop like a cork escaping a bottle of champagne\\.  However, instead of bubbly, a tide of gore erupts\\.  Cheers", 1},
    {"<ATTACKER> impales? <victim><vic_pl> <bodypart> with <weapon>, twisting it inside <v_him> before yanking it free\\.  Un-skewered, <v_his> corpse slumps to the ground", 1},
    {"<ATTACKER> launch(es)? a powerful attack with <weapon>\\.  <victim> staggers? around, trying desperately to plug the hole in <v_his> <bodypart>\\.  Maybe in <v_his> next life, <v_he>'ll make sure that <v_he> knows where <v_his> towel is", 1},
    {"<ATTACKER> sheaths? <weapon> in <victim><vic_pl> eye\\.  As <v_he> falls? to the ground, <a_he> withdraws? the weapon, wiping it clean before looking around for another opponent", 1},
    {"<V_HIS> <bodypart> pierced by <weapon2>, <victim> hops? around briefly\\.  Cradling <v_his> bleeding extremity, <v_he> falls? over, <v_his> screams ending as <v_he> collapses? to the ground", 1},
    {"<ATTACKER> launch(es)? a powerful attack with <weapon>\\.  For a moment, <attacker2> and <victim> stare at each other, before <victim2> collapses?, a gaping hole in <v_his> torso", 1},
    {"<ATTACKER> plunges? <weapon> into <victim>\\.  As it is withdrawn, <v_he> examines? the place where <v_his> <bodypart> used to be before slumping over lifelessly", 1},
    {"As <victim> is impaled on <weapon2>, <v_his> innards burst from <v_his> body like grisly fireworks\\.  At least <v_he> made an impression on the way out", 1},
    {"<WEAPON2> travels halfway through <victim> before getting stuck in the stone\\.  <VICTIM2> looks? triumphant, but only for a moment before <v_he> cracks? into (?>two|three|four|five|six|seven|eight|nine|ten) pieces", 1},
    {"Managing to find a crack in <victim><vic_pl> skin, <attacker> plunges? <weapon> right into <v_him>, fatally wounding <v_him>", 1},
    {"<ATTACKER> drives? <weapon> into <victim><vic_pl> trunk\\.  The bark around <v_him> splinters and snaps\\.  <VICTIM2> freezes? for a moment, looking far less animate as <v_he> dies?", 1},
    {"With a flourish, <attacker> draws? back <weapon> and drives? it into <victim><vic_pl> <bodypart>", 1},
    {"<ATTACKER> drives? <weapon> into <victim><vic_pl> <bodypart>, impaling <v_his> vital organs before it bursts out the other side in a shower of gore", 1},
    {"<ATTACKER> steps? towards? <victim>, running <v_him> through with <weapon> in a single motion", 1},
    {"<VICTIM> looks? down at <weapon3> protruding from <v_his> <bodypart> in horrified surprise, then back up at <attacker>, before the consequences catch up to <v_him> and <v_he> slumps? lifelessly to the ground", 1},
    {"<ATTACKER> launch(es)? a powerful attack with <weapon>\\.  <VICTIM> attempts? to say some last words as <weapon4> drives through <v_his> <bodypart>: ", 1},
  }
  -- Non-player animal/monster body part possibilities
  local sAnimalParts = 
  {
    "lower back", "upper back", "dorsal fin", "abdomen", "body", "breast", "thorax", "trunk", "tail", "branches",
    "right rear paw", "left rear paw", "right rear foot", "left rear foot", "right front hoof", "left front hoof",
    "right rear hoof", "left rear hoof", "right rear leg", "left rear leg", "right claw", "left claw",
    "right back leg", "left back leg", "right front leg", "left front leg", "right petral fin", "left petral fin",
    "right wing", "left wing", "right middle leg", "left middle leg", "right front paw", "left front paw",
  }
  local sAnimalBodyParts = ""
  for iN, sPartname in ipairs(sAnimalParts) do
    sAnimalBodyParts = sAnimalBodyParts .. sPartname .. "|"
  end
  sAnimalBodyParts = string.sub(sAnimalBodyParts, 0, -2)
  -- And standard human body part possibilities
  local sHumanParts = 
  {
    "head", "skull", "face", "neck", "jaw", "chest", "back", "left arm", "guts", "left hand", "stomach", "shoulder", 
    "right arm", "right hand", "left leg", "left foot", "right leg", "right foot", "side", "ribs", "ribcage", 
    "left kneecap", "right kneecap", "solar plexus", "right leg's muscles", "left leg's muscles", "right arm's muscles", "left arm's muscles",
  }
  local sHumanBodyParts = ""
  for iN, sPartname in ipairs(sHumanParts) do
    sHumanBodyParts = sHumanBodyParts .. sPartname .. "|"
  end
  sHumanBodyParts = string.sub(sHumanBodyParts, 0, -2)

  -- Fastest wildcard so far:
  local sWild = "(?:\\w+\\b\\W*?){1,8}"
  local sWildLong = "(?:\\w+\\b\\W*?){1,14}"

  local iFlags = trigger_flag.Enabled + trigger_flag.RegularExpression

  local bDebugTriggers = false

  local sCatRegex
  local sAttackStart
  local sAttackEnding
  local sAttackWeapon
  local sAttackWeaponShort
  local sAttackVictim
  local sDefenseStart
  local sDefenseEnding
  local sDefenseWeapon
  local sDefenseVictim
  local sSpecialStart
  local sSpecialEnding
  local sSpecialWeapon
  local sSpecialVictim
  local iCategory
  local sTempCut
  local iVictim
  local iBodypart
  local sStringPart
  local sTriggerName
  local sTriggerFunction
  local sTriggerColour
  local sDefenseFunction
  local sDefenseTrigger
  local sBodyParts
  for iIncOrOut = 1, 3 do
    sCatRegex = {
      [1] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [2] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [3] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [4] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [5] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [6] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [7] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
    -- Special defense builders
      [8] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [9] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [10] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [11] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [12] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [13] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [14] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
      [15] = {
          [1] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [2] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [3] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
          [4] = {["string"] = "", ["words"] = {}, ["optional"] = false, ["count"] = 0, },
        },
    }
    for iKey, sData in ipairs(sCombatTexts) do
      -- Convert the string properly
      if (sData[2] == false or iIncOrOut ~= 1) then
        iCategory = 0
        sTempCut = string.sub(sData[1], 12)
        sTempCut = string.gsub(sTempCut, "<wild>", sWild)
        if (iIncOrOut == 1) then
          -- You (first person) are the attacker
          sTempCut = string.gsub(sTempCut, "<vic_pl>", "'s?")
          sTempCut = string.gsub(sTempCut, "<att_pl>", "r")
          sTempCut = string.gsub(sTempCut, "<a_his>", "your")
          sTempCut = string.gsub(sTempCut, "<a_himself>", "yourself")
          sTempCut = string.gsub(sTempCut, "<v_his>", "(?>his|her|its)")
          sTempCut = string.gsub(sTempCut, "<v_him>", "(?>him|her|it)")
          sTempCut = string.gsub(sTempCut, "<v_himself>", "(?>himself|herself|itself)")
        elseif (iIncOrOut == 2) then
          -- You (first person) are the victim
          sTempCut = string.gsub(sTempCut, "<vic_pl>", "r")
          sTempCut = string.gsub(sTempCut, "<att_pl>", "'s?")
          sTempCut = string.gsub(sTempCut, "<a_his>", "(?>his|her|its)")
          sTempCut = string.gsub(sTempCut, "<a_himself>", "(?>himself|herself|itself)")
          sTempCut = string.gsub(sTempCut, "<v_his>", "your")
          sTempCut = string.gsub(sTempCut, "<v_him>", "you")
          sTempCut = string.gsub(sTempCut, "<v_himself>", "yourself")
        elseif (iIncOrOut == 3) then
          -- You are not involved at all
          sTempCut = string.gsub(sTempCut, "<vic_pl>", "'s?")
          sTempCut = string.gsub(sTempCut, "<att_pl>", "'s?")
          sTempCut = string.gsub(sTempCut, "<a_his>", "(?>his|her|its)")
          sTempCut = string.gsub(sTempCut, "<a_himself>", "(?>himself|herself|itself)")
          sTempCut = string.gsub(sTempCut, "<v_his>", "(?>his|her|its)")
          sTempCut = string.gsub(sTempCut, "<v_him>", "(?>him|her|it)")
          sTempCut = string.gsub(sTempCut, "<v_himself>", "(?>himself|herself|itself)")
        end
        iVictim = string.find(sTempCut, "<victim>", 1, true)
        iBodypart = string.find(sTempCut, "<bodypart>", 1, true)
        iWeapon = string.find(sTempCut, "<weapon>", 1, true)
        sStringPart = {}
        if (iBodypart ~= nil and iWeapon ~= nil and iVictim < iBodypart and iBodypart < iWeapon) then
          iCategory = 1
          sStringPart[1] = string.sub(sTempCut, 0, iVictim - 1)
          sStringPart[2] = string.sub(sTempCut, iVictim + 8, iBodypart -1)
          sStringPart[3] = string.sub(sTempCut, iBodypart + 10, iWeapon -1)
          sStringPart[4] = string.sub(sTempCut, iWeapon + 8, -4)
        elseif (iBodypart ~= nil and iWeapon ~= nil and iWeapon < iVictim and iVictim < iBodypart) then
          iCategory = 2
          sStringPart[1] = string.sub(sTempCut, 0, iWeapon -1)
          sStringPart[2] = string.sub(sTempCut, iWeapon + 8, iVictim -1)
          sStringPart[3] = string.sub(sTempCut, iVictim + 8, iBodypart -1)
          sStringPart[4] = string.sub(sTempCut, iBodypart + 10, -4)
        elseif (iBodypart == nil and iWeapon ~= nil and iVictim < iWeapon) then
          iCategory = 6
          sStringPart[1] = string.sub(sTempCut, 0, iVictim -1)
          sStringPart[2] = string.sub(sTempCut, iVictim + 8, iWeapon -1)
          sStringPart[3] = string.sub(sTempCut, iWeapon + 8, -4)
        elseif (iWeapon == nil and iBodypart ~= nil and iVictim < iBodypart) then
          iCategory = 3
          sStringPart[1] = string.sub(sTempCut, 0, iVictim -1)
          sStringPart[2] = string.sub(sTempCut, iVictim + 8, iBodypart -1)
          sStringPart[3] = string.sub(sTempCut, iBodypart + 10, -4)
        elseif (iWeapon ~= nil and iBodypart == nil and iWeapon < iVictim) then
          iCategory = 7
          sStringPart[1] = string.sub(sTempCut, 0, iWeapon -1)
          sStringPart[2] = string.sub(sTempCut, iWeapon + 8, iVictim -1)
          sStringPart[3] = string.sub(sTempCut, iVictim + 8, -4)
        elseif (iWeapon == nil and iBodypart == nil and iVictim < (string.len(sTempCut) - 10)) then
          iCategory = 4
          sStringPart[1] = string.sub(sTempCut, 0, iVictim -1)
          sStringPart[2] = string.sub(sTempCut, iVictim + 8, -4)
        else
          iCategory = 5
          sStringPart[1] = string.sub(sTempCut, 0, iVictim -1)
          sStringPart[2] = string.sub(sTempCut, iVictim + 8, -4)
        end
        if (iCategory == 0) then
          Note("FATAL COWBAR COMBAT MESSAGE ERROR:")
          Note("Failed to make a category for this line;")
          Note(sTempCut)
          Note("Victim=" .. tostring(iVictim))
          Note("Bodypart=" .. tostring(iBodypart))
          Note("Weapon=" .. tostring(iWeapon))
        end
        if (iIncOrOut == 1) then
          -- Replace ies and hes to y and h... eg "parries"="parry", "crunches"="crunch", "tries"="try"
          sStringPart[1] = string.gsub(sStringPart[1], "ies ", "y ")
          sStringPart[1] = string.gsub(sStringPart[1], "hes ", "h ")
          -- Remove S's at the end of a string but NOT if it's "ss" or "us", eg "mess" or "ferocious"... unpluralises them
          sStringPart[1], iMatches = string.gsub(sStringPart[1], "([^su])s ", "%1 ")
        end
        -- Recover the force-preserved S's
        --[[
        for iPart = 1, 4 do
          if (sStringPart[iPart] ~= nil) then
            sStringPart[iPart], iCount = string.gsub(sStringPart[iPart], "s$ ", "s ")
          end
        end
        --]]

        if (sData[4] == nil or sData[4] == false) then
          for iPart = 1, 4 do
            if (sStringPart[iPart] ~= nil) then
              if (sCatRegex[iCategory][iPart]["words"][sStringPart[iPart]] == nil) then
                sCatRegex[iCategory][iPart]["words"][sStringPart[iPart]] = sStringPart[iPart]
                sCatRegex[iCategory][iPart]["count"] = sCatRegex[iCategory][iPart]["count"] + 1
                if (sStringPart[iPart] == "") then
                  sCatRegex[iCategory][iPart]["optional"] = true
                else
                  sCatRegex[iCategory][iPart]["string"] = sCatRegex[iCategory][iPart]["string"] .. sStringPart[iPart] .. "|"
                end
              end
            end
          end
        end

        -- Special texts
        if (sData[4] ~= nil and sData[4] == true) then
          local iSpecialCategory = 0
          if (iCategory == 3) then
            iSpecialCategory = 13
          elseif (iCategory == 4) then
            iSpecialCategory = 14
          elseif (iCategory == 2) then
            iSpecialCategory = 15
          else
            Note("Error missing category for SPECIAL=" .. iCategory .. " changed to " .. iSpecialCategory .. "=" .. sData[1])
          end
          for iPart = 1, 4 do
            if (sStringPart[iPart] ~= nil) then
              if (sCatRegex[iSpecialCategory][iPart]["words"][sStringPart[iPart]] == nil) then
                sCatRegex[iSpecialCategory][iPart]["words"][sStringPart[iPart]] = sStringPart[iPart]
                sCatRegex[iSpecialCategory][iPart]["count"] = sCatRegex[iSpecialCategory][iPart]["count"] + 1
                if (sStringPart[iPart] == "") then
                  sCatRegex[iSpecialCategory][iPart]["optional"] = true
                else
                  sCatRegex[iSpecialCategory][iPart]["string"] = sCatRegex[iSpecialCategory][iPart]["string"] .. sStringPart[iPart] .. "|"
                end
              end
            end
          end
        end

        -- Build defense lines for weak hits
        if (sData[3] == 1 and sData[4] == nil) then
          local iDefCategory = 0
          if (iCategory == 4) then
            iDefCategory = 8
          elseif (iCategory == 3) then
            iDefCategory = 9
          elseif (iCategory == 5) then
            iDefCategory = 10
          elseif (iCategory == 6) then
            iDefCategory = 11
          elseif (iCategory == 7) then
            iDefCategory = 12
          else
            --
            Note("Error missing category for def=" .. iCategory .. " changed to " .. iDefCategory .. "=" .. sData[1])
          end

          for iPart = 1, 4 do
            if (sStringPart[iPart] ~= nil) then
              if (sCatRegex[iDefCategory][iPart]["words"][sStringPart[iPart]] == nil) then
                sCatRegex[iDefCategory][iPart]["words"][sStringPart[iPart]] = sStringPart[iPart]
                sCatRegex[iDefCategory][iPart]["count"] = sCatRegex[iDefCategory][iPart]["count"] + 1
                if (sStringPart[iPart] == "") then
                  sCatRegex[iDefCategory][iPart]["optional"] = true
                else
                  sCatRegex[iDefCategory][iPart]["string"] = sCatRegex[iDefCategory][iPart]["string"] .. sStringPart[iPart] .. "|"
                end
              end
            end
          end
        end -- Defensive lines built

      end -- if not an animal line

    end -- Loop through all the "combattexts" table

    -- Finish up the strings
    for iCat, sCatData in ipairs(sCatRegex) do
      for iPart, sPartData in ipairs(sCatData) do
        if (sPartData["count"] > 1) then
          sCatRegex[iCat][iPart]["string"] = "(?:" .. string.sub(sCatRegex[iCat][iPart]["string"], 1, -2) .. ")"
        elseif (sPartData["count"] == 1) then
          sCatRegex[iCat][iPart]["string"] = string.sub(sCatRegex[iCat][iPart]["string"], 1, -2)
        end
        if (sCatRegex[iCat][iPart]["optional"] == true and sCatRegex[iCat][iPart]["string"] ~= "") then
          sCatRegex[iCat][iPart]["string"] = sCatRegex[iCat][iPart]["string"] .. "?"
        end
      end
    end
    if (iIncOrOut == 1) then
      -- Outgoing attack BY you
      sAttackSpecialStart = "^(?:> )?(?>You launch a powerful attack\\.  You|Launching a powerful attack with a wild swing of your weapon, you|Launching a powerful wildswing attack on your adversaries, you|Swinging your weapon around wildly to launch a powerful attack, you|Unleashing a whirlwind of attacks on your adversaries, you|You launch a powerful attack and swing your weapon wildly\\.  You|You spin your weapon in a wide arc and launch a powerful attack\\.  You)"
      sAttackStart = "^(?:> )?(?>You|(?>Exploiting (?>his|her|its) confusion|Catching (?>him|her|it) by surprise|Taking advantage of (?>his|her|its) surprise|Catching (?>him|her|it) off balance|Moving quickly|Quick as lightning|Moving too fast to see|In the blink of an eye|With a blur of speed|Striking like a cobra|Moving swiftly|With surprising speed|Repositioning yourself|With one last attack|Following through to the next opponent|Swinging your weapon around heavily|Continuing your wildswing attack|Continuing your attack|Using the momentum of your previous swing|Using your momentum to turn|Moving to your next target|In a final display of fighting power|Finishing your wildswing attack|With a final swing of your weapon|Turning to face your next opponent|Turning with the swing of your weapon|As you spin around), you)"
      sAttackEnding = "(?: as " .. sWild .. " leaps in at the last moment to protect " .. sWild .. ")?( but (?>his|her|its) " .. sWild .. " absorbs (?>some|most) of the (?>blow|impact))?\\.$"
      -- Removing "one of/your" for a black tentacle test
      sAttackWeapon = "(?:one of )?your (?:" .. sWild .. ")"
      sAttackWeaponShort = "(?:one of )?your (?:" .. sWild .. ")"
      -- Replacing
      --sAttackWeapon = "(?:one of )?(?>your |a )(?:" .. sWild .. ")"
      --sAttackWeaponShort = "(?:one of )?(?>your |a )(?:" .. sWild .. ")"

      sAttackVictim = "(?:(?!you |you,|your )" .. sWild .. ")"

      sDefenseSpecialStart = "^(?:> )?(?>You (?>attempt to launch|launch) a powerful attack\\.  You|Launching a powerful attack with a wild swing of your weapon, you|Launching a powerful wildswing attack on your adversaries, you|Swinging your weapon around wildly to launch a powerful attack, you|Unleashing a whirlwind of attacks on your adversaries, you|You launch a powerful attack and swing your weapon wildly\\.  You|You spin your weapon in a wide arc and launch a powerful attack\\.  You)"
      sDefenseStart = "^(?:> )?(?:" .. sWild .. " recovers from the surprise\\.  )?(?>You|(?>Exploiting (?>his|her|its) confusion|Catching (?>him|her|it) by surprise|Taking advantage of (?>his|her|its) surprise|Catching (?>him|her|it) off balance|Moving quickly|Moving too fast to see|Quick as lightning|In the blink of an eye|With a blur of speed|Striking like a cobra|Moving swiftly|With surprising speed|Repositioning yourself|With one last attack|Following through to the next opponent|Swinging your weapon around heavily|Continuing your wildswing attack|Continuing your attack|Using the momentum of your previous swing|Using your momentum to turn|Moving to your next target|In a final display of fighting power|Finishing your wildswing attack|With a final swing of your weapon|Turning to face your next opponent|Turning with the swing of your weapon|As you spin around), you)"
      sDefenseEnding = "( as " .. sWild .. " leaps in at the last moment to protect " .. sWild .. ")? but( |, although unable to defend, | despite the surprise )(?:(?:(?>her |his |its )(?P<shielding>" .. sWildLong .. ") (?>swoops in and )?absorbs? all of the (?>blow|impact))|(?P<focus>you cannot seem to reach the place you are focusing on)|(?:he|she|" .. sWild .. ")(?P<level> barely| just| easily| deftly)?(?P<type> dodges out of the way| parries the blow with (?>his|her|its) " .. sWild .. "| blocks the blow with (?>his|her|its) " .. sWild .. "| somehow avoids the attack| deflects your lunge))\\.$"
      sSpecialStart = "^(?:> )?You" .. " launch a powerful attack,"
      --sBodyParts = sHumanBodyParts .. "|" .. sAnimalBodyParts
      sBodyParts = "(?:\\w+\\b\\W*){1,4}"
      sTriggerName = "QuowMeleeSuccessOutCat"
      sTriggerFunction = "SuccessOutgoing"
      sTriggerColour = "darkgoldenrod"
    elseif (iIncOrOut == 2) then
      -- Incoming attack against you
      sAttackSpecialStart = "^(?:> )?(?!You )" .. sWild .. " launches a powerful attack\\.  " .. sWild .. ""
      -- This one might not be a hiephen off-balance?
      sAttackStart = "^(?:> )?(?>Exploiting your confusion, |Catching you by surprise, |Taking advantage of your surprise, |Catching you off-balance, |Moving quickly, |Moving too fast to see, |Quick as lightning, |In the blink of an eye, |With a blur of speed, |Striking like a cobra, |Moving swiftly, |With surprising speed, )?(?:(?!You |you |The fire )" .. sWild .. ")"
      sAttackEnding = "(?: as you leap in at the last moment to protect " .. sWild .. ")?(?: but your " .. sWild .. " absorbs (?>some|most) of the (?>blow|impact))?\\.$"
      -- Removing "one of/your" for a black tentacle test
      sAttackWeapon = "(?:one of )?(?>his|her|its) (?:" .. sWild .. ")"
      sAttackWeaponShort = "(?:one of )?(?>his|her|its) (?:" .. sWild .. ")"
      -- Replacing
      --sAttackWeapon = "(?:one of )?(?>his|her|its|a) (?:" .. sWild .. ")"
      --sAttackWeaponShort = "(?:one of )?(?>his|her|its|a) (?:" .. sWild .. ")"

      sAttackVictim = "you"
      sDefenseSpecialStart = "^(?:> )?(?!You )" .. sWild .. " (?>attempts to launch|launches) a powerful attack\\.  " .. sWild
      -- Note:  This one is definitely off-balance with a hiephen.
      sDefenseStart = "^(?:> )?(?:You recover from the surprise\\.  )?(?>Exploiting your confusion, |Catching you by surprise, |Taking advantage of your surprise, |Catching you off-balance, |Moving quickly, |Moving too fast to see, |Quick as lightning, |In the blink of an eye, |With a blur of speed, |Striking like a cobra, |Moving swiftly, |With surprising speed, )?(?:(?!You |you |The fire )" .. sWild .. ")"
      sDefenseEnding = "(?: as you leap in at the last moment to protect " .. sWild .. ")? but( |, although unable to defend, | despite the surprise )(?:(?:your (?P<shielding>" .. sWildLong .. ") (?>swoops in and )?absorbs? all of the (?>blow|impact))|(?P<focus>(?>he |she |it )?cannot seem to reach the place (?>he|she|it) is focusing on)|you(?P<level> barely| just| easily| deftly)?(?P<type> dodge out of the way| parry the blow with your " .. sWild .. "| block the blow with your " .. sWild .. "| somehow avoid the attack| deflect (?>his|her|its) lunge))\\.$"
      sSpecialStart = "^(?:> )?(?!You )" .. sWild .. " launches a powerful attack,"
      --sBodyParts = sHumanBodyParts
      sBodyParts = "(?:\\w+\\b\\W*){1,4}"
      sTriggerName = "QuowMeleeSuccessIncCat"
      sTriggerFunction = "SuccessIncoming"
      sTriggerColour = "maroon"
    elseif (iIncOrOut == 3) then
      -- Witnessing an attack not involving you
      sAttackSpecialStart = "^(?:> )?(?:Swinging (?>his|her|its) weapon around wildly to launch a powerful attack, (?!you )" .. sWild .. "|Launching a powerful attack with a wild swing of (?>his|her|its) weapon, (?!you )" .. sWild .. "|Launching a powerful wildswing attack, (?!you )" .. sWild .. "|Unleashing a whirlwind of attacks, (?!you )" .. sWild .. "|Spinning (?>his|her|its) weapon in a wide arc (?!you )" .. sWild .. " launches a powerful attack\\.  " .. sWild .. "|(?!You )" .. sWild .. " launches a powerful attack\\.  " .. sWild .. "|(?!You )" .. sWild .. " launches a powerful attack with a wild swing of (?>his|her|its) weapon\\.  " .. sWild .. ")"
      sAttackStart = "^(?:> )?(?>Exploiting (?>his|her|its) confusion, |Catching (?>him|her|it) by surprise, |Taking advantage of (?>his|her|its) surprise, |Catching (?>him|her|it) off balance, |Moving quickly, |Quick as lightning, |Moving too fast to see, |In the blink of an eye, |With a blur of speed, |Striking like a cobra, |Moving swiftly, |With surprising speed, |Repositioning (?>his|her|it)self, |With one last attack, |Following through to the next opponent, |Swinging (?>his|her|its) weapon around heavily, |Continuing (?>his|her|its) wildswing attack, |Continuing (?>his|her|its) attack, |Using the momentum of (?>his|her|its) previous swing, |Using (?>his|her|its) momentum to turn, |Moving to (?>his|her|its) next target, |In a final display of fighting power, |Finishing (?>his|her|its) wildswing attack, |With a final swing of (?>his|her|its) weapon, |Turning to face (?>his|her|its) next opponent, |Turning with the swing of (?>his|her|its) weapon, |As (?>he|she|it) spins around, )?(?:(?!You |you |The fire )" .. sWild .. ")"
      sAttackEnding = "(?: as " .. sWild .. " leaps in at the last moment to protect " .. sWild .. ")?( but (?>his|her|its) " .. sWild .. " absorbs (?>some|most) of the (?>blow|impact))?\\.$"
      -- Removing "one of/your" for a black tentacle test
      sAttackWeapon = "(?:one of )?(?>his|her|its) (?:" .. sWild .. ")"
      sAttackWeaponShort = "(?:one of )?(?>his|her|its) (?:" .. sWild .. ")"
      -- Replacing
      --sAttackWeapon = "(?:one of )?(?>his|her|its|a) (?:" .. sWild .. ")"
      --sAttackWeaponShort = "(?:one of )?(?>his|her|its|a) (?:" .. sWild .. ")"
      
      sAttackVictim = "(?:(?!you |you,|your )" .. sWild .. ")"
      sDefenseSpecialStart = "^(?:> )?(?:Swinging (?>his|her|its) weapon around wildly to launch a powerful attack, (?!you )" .. sWild .. "|Launching a powerful attack with a wild swing of (?>his|her|its) weapon, (?!you )" .. sWild .. "|Launching a powerful wildswing attack, (?!you )" .. sWild .. "|Unleashing a whirlwind of attacks, (?!you )" .. sWild .. "|Spinning (?>his|her|its) weapon in a wide arc (?!you )" .. sWild .. " launches a powerful attack\\.  " .. sWild .. "|(?!You )" .. sWild .. " (?>attempts to launch|launches) a powerful attack\\.  " .. sWild .. "|(?!You )" .. sWild .. " launches a powerful attack with a wild swing of (?>his|her|its) weapon\\.  " .. sWild .. ")"
      --sDefenseSpecialStart = "^(?:> )?(?!You )" .. sWild .. " (?>attempts to launch|launches) a powerful attack\\.  " .. sWild
      sDefenseStart = "^(?:> )?(?:" .. sWild .. " recovers from the surprise\\.  )?(?>Exploiting (?>his|her|its) confusion, |Catching (?>him|her|it) by surprise, |Taking advantage of (?>his|her|its) surprise, |Catching (?>him|her|it) off balance, |Moving quickly, |Quick as lightning, |Moving too fast to see, |In the blink of an eye, |With a blur of speed, |Striking like a cobra, |Moving swiftly, |With surprising speed, |Repositioning (?>his|her|it)self, |With one last attack, |Following through to the next opponent, |Swinging (?>his|her|its) weapon around heavily, |Continuing (?>his|her|its) wildswing attack, |Continuing (?>his|her|its) attack, |Using the momentum of (?>his|her|its) previous swing, |Using (?>his|her|its) momentum to turn, |Moving to (?>his|her|its) next target, |In a final display of fighting power, |Finishing (?>his|her|its) wildswing attack, |With a final swing of (?>his|her|its) weapon, |Turning to face (?>his|her|its) next opponent, |Turning with the swing of (?>his|her|its) weapon, |As (?>he|she|it) spins around, )?(?:(?!You |you |The fire )" .. sWild .. ")"
      sDefenseEnding = "( as " .. sWild .. " leaps in at the last moment to protect " .. sWild .. ")? but( |, although unable to defend, | despite the surprise )(?:(?:(?>her |his |its )(?P<shielding>" .. sWildLong .. ") (?>swoops in and )?absorbs? all of the (?>blow|impact))|(?P<focus>(?>he |she |it )?cannot seem to reach the place (?>he|she|it) is focusing on)|(?:he|she|" .. sWild .. ")(?P<level> barely| just| easily| deftly)?(?P<type> dodges out of the way| parries the blow with (?>his|her|its) " .. sWild .. "| blocks the blow with (?>his|her|its) " .. sWild .. "| somehow avoids the attack| deflects (?>his|her|its) lunge))\\.$"
      sSpecialStart = "^(?:> )?(?:(?!You )" .. sWild .. ") launches a powerful attack,"
      --sBodyParts = sHumanBodyParts .. "|" .. sAnimalBodyParts
      sBodyParts = "(?:\\w+\\b\\W*){1,4}"
      sTriggerName = "StatsMeleeSuccessThirdCat"
      sTriggerFunction = "" --"SuccessThird"
      sTriggerColour = "#3C4420"
    end
    local sThisTriggerText = ""
--[[
Priorities/sequences:
50: You - specialling stuff + it being defended
60: You - hitting stuff + it being defended
70: You - specialling stuff
80: You - hitting stuff

100: Enemy - specialling you + it being defended
110: Enemy - hitting you + it being defended
120: Enemy - specialling you
130: Enemy - hitting you

150: Others - specialling others + it being defended
160: Others - hitting others + it being defended
170: Others - specialling others
180: Others - hitting others
--]]

    local iUsePriority = 100
    local sUseTriggerName = ""
    local sUseTriggerFunction = ""
    for iThisCat = 1, 7 do
      for iThisSpecial = 1, 2 do
        if (iThisCat == 1) then
          sThisTriggerText = sCatRegex[1][1]["string"] .. sAttackVictim .. sCatRegex[1][2]["string"] .. "(?:" .. sBodyParts .. ")" .. sCatRegex[1][3]["string"] .. sAttackWeapon .. sCatRegex[1][4]["string"] .. sAttackEnding
        elseif (iThisCat == 2) then
          sThisTriggerText = sCatRegex[2][1]["string"] .. sAttackWeapon .. sCatRegex[2][2]["string"] .. sAttackVictim .. sCatRegex[2][3]["string"] .. "(?:" .. sBodyParts .. ")" .. sCatRegex[2][4]["string"] .. sAttackEnding
        elseif (iThisCat == 3) then
          sThisTriggerText = sCatRegex[3][1]["string"] .. sAttackVictim .. sCatRegex[3][2]["string"] .. "(?:" .. sBodyParts .. ")" .. sCatRegex[3][3]["string"] .. sAttackEnding
        elseif (iThisCat == 4) then
          sThisTriggerText = sCatRegex[4][1]["string"] .. sAttackVictim .. sCatRegex[4][2]["string"] .. sAttackEnding
        elseif (iThisCat == 5) then
          sTempCut = string.gsub(sCatRegex[5][2]["string"], "<weapon>", sAttackWeaponShort)
          sTempCut = string.gsub(sTempCut, "<bodypart>", sBodyParts)
          sThisTriggerText = sCatRegex[5][1]["string"] .. sAttackVictim .. sTempCut .. sAttackEnding
        elseif (iThisCat == 6) then
          sThisTriggerText = sCatRegex[6][1]["string"] .. sAttackVictim .. sCatRegex[6][2]["string"] .. sAttackWeapon .. sCatRegex[6][3]["string"] .. sAttackEnding
        elseif (iThisCat == 7) then
          sThisTriggerText = sCatRegex[7][1]["string"] .. sAttackWeapon .. sCatRegex[7][2]["string"] .. sAttackVictim .. sCatRegex[7][3]["string"] .. sAttackEnding
        end
        if (iThisSpecial == 1) then
          sThisTriggerText = sAttackSpecialStart .. sThisTriggerText
          sUseTriggerName = sTriggerName .. "Special" .. iThisCat
          if (sTriggerFunction ~= "") then
            sUseTriggerFunction = "StatsSpecial" .. sTriggerFunction
          else
            sUseTriggerFunction = ""
          end
        else
          sThisTriggerText = sAttackStart .. sThisTriggerText
          sUseTriggerName = sTriggerName .. iThisCat
          if (sTriggerFunction ~= "") then
            sUseTriggerFunction = "StatsMelee" .. sTriggerFunction
          else
            sUseTriggerFunction = ""
          end
        end
        iUsePriority = (50 * iIncOrOut) + 10 + (iThisSpecial * 10) + iThisCat
        iErrorCode = AddTriggerEx(tostring(sUseTriggerName), tostring(sThisTriggerText), "", iFlags, -1, 0, "", tostring(sUseTriggerFunction), 12, iUsePriority)
        if (iErrorCode ~= 0) then
          ColourNote(sCOLOUR.red,"","Fatal error adding combat trigger type-A:")
          Note(iErrorCode .. ": " .. sUseTriggerName .. "= " .. sThisTriggerText)
        end
        SetTriggerOption(tostring(sUseTriggerName), "group", "module_stats")
        iTotalCombatTriggers = iTotalCombatTriggers + 1
        SetTriggerOption(tostring(sUseTriggerName), "custom_colour", tostring(17))
        --SetTriggerOption(tostring(sUseTriggerName), "other_back_colour", "")
        SetTriggerOption(tostring(sUseTriggerName), "colour_change_type", "1") -- 0=both, 1=foreground, 2=background
        SetTriggerOption(tostring(sUseTriggerName), "other_text_colour", tostring(ColourNameToRGB(sTriggerColour)))
        if (bDebugTriggers == true) then
          ColourTell(sCOLOUR.orange, "", sUseTriggerName .. " pri " .. iUsePriority .. "= ")
          ColourNote(sTriggerColour, "", sThisTriggerText)
          Note("")
        end
      end
    end

    -- Defensive line generation
    if (iIncOrOut == 1) then
      sTriggerName = "QuowMeleeFailOutCat"
      sTriggerFunction = "FailOutgoing"
      sTriggerColour = "maroon"
    elseif (iIncOrOut == 2) then
      sTriggerName = "QuowMeleeFailIncCat"
      sTriggerFunction = "FailIncoming"
      sTriggerColour = "olivedrab"
    elseif (iIncOrOut == 3) then
      sTriggerName = "StatsMeleeFailThirdCat"
      sTriggerFunction = ""--"FailThird"
      sTriggerColour = "darkgoldenrod"
    end

    sUseTriggerName = ""
    sUseTriggerFunction = ""
    for iThisCat = 1, 5 do
      -- Category 1 defense lines are NOT used for you, because YOU cannot defend against YOURSELF!
      if (iThisCat > 1 or iIncOrOut > 1) then
        for iThisSpecial = 1, 2 do
          if (iThisCat == 1) then
            sThisTriggerText = sCatRegex[8][1]["string"] .. sAttackVictim .. sCatRegex[8][2]["string"] .. sDefenseEnding
          elseif (iThisCat == 2) then
            sThisTriggerText = sCatRegex[9][1]["string"] .. sAttackVictim .. sCatRegex[9][2]["string"] .. "(?:" .. sBodyParts .. ")" .. sCatRegex[9][3]["string"] .. sDefenseEnding
          elseif (iThisCat == 3) then
            sThisTriggerText2 = sCatRegex[10][1]["string"] .. sAttackVictim .. sDefenseEnding
            sTempCut = string.gsub(sCatRegex[10][2]["string"], "<weapon>", sAttackWeaponShort)
            sTempCut = string.gsub(sTempCut, "<bodypart>", sBodyParts)
            sThisTriggerText = sCatRegex[10][1]["string"] .. sAttackVictim .. sTempCut .. sDefenseEnding
          elseif (iThisCat == 4) then
            sThisTriggerText = sCatRegex[11][1]["string"] .. sAttackVictim .. sCatRegex[11][2]["string"] .. sAttackWeapon .. sCatRegex[11][3]["string"] .. sDefenseEnding
          elseif (iThisCat == 5) then
            sThisTriggerText = sCatRegex[12][1]["string"] .. sAttackWeapon .. sCatRegex[12][2]["string"] .. sAttackVictim .. sCatRegex[12][3]["string"] .. sDefenseEnding
          end
          if (iThisSpecial == 1) then
            sThisTriggerText = sDefenseSpecialStart .. sThisTriggerText
            sUseTriggerName = sTriggerName .. "Special" .. iThisCat
            if (sTriggerFunction ~= "") then
              sUseTriggerFunction = "StatsSpecial" .. sTriggerFunction
            else
              sUseTriggerFunction = ""
            end
          else
            sThisTriggerText = sDefenseStart .. sThisTriggerText
            sUseTriggerName = sTriggerName .. iThisCat
            if (sTriggerFunction ~= "") then
              sUseTriggerFunction = "StatsMelee" .. sTriggerFunction
            else
              sUseTriggerFunction = ""
            end
          end
          iUsePriority = (50 * iIncOrOut) + ((iThisSpecial - 1) * 10) + iThisCat
          iErrorCode = AddTriggerEx(tostring(sUseTriggerName), tostring(sThisTriggerText), "", iFlags, -1, 0, "", tostring(sUseTriggerFunction), 12, iUsePriority)
          if (iErrorCode ~= 0) then
            ColourNote(sCOLOUR.red,"","Fatal error adding combat trigger type-B:")
            Note(iErrorCode .. ": " .. sUseTriggerName .. "= " .. sThisTriggerText)
          end
          SetTriggerOption(tostring(sUseTriggerName), "group", "module_stats")
          iTotalCombatTriggers = iTotalCombatTriggers + 1
          SetTriggerOption(tostring(sUseTriggerName), "custom_colour", tostring(17))
          SetTriggerOption(tostring(sUseTriggerName), "colour_change_type", "1")
          SetTriggerOption(tostring(sUseTriggerName), "other_text_colour", tostring(ColourNameToRGB(sTriggerColour)))
          if (bDebugTriggers == true) then
            ColourTell(sCOLOUR.orange, "", sUseTriggerName .. " pri " .. iUsePriority .. "= ")
            ColourNote(sTriggerColour, "", sThisTriggerText)
            Note("")
          end
        end
      end
    end

    sUseTriggerFunction = ""
    -- Special attacks successful
    if (iIncOrOut == 1) then
      sTriggerName = "QuowSpecialSuccessOutCat"
      sTriggerFunction = "StatsSpecialSuccessOutgoing"
      sTriggerColour = "darkgoldenrod"
    elseif (iIncOrOut == 2) then
      sTriggerName = "QuowSpecialSuccessIncCat"
      sTriggerFunction = "StatsSpecialSuccessIncoming"
      sTriggerColour = "maroon"
    elseif (iIncOrOut == 3) then
      sTriggerName = "StatsSpecialSuccessThirdCat"
      sTriggerFunction = ""--"StatsSpecialSuccessThird"
      sTriggerColour = "#3C4420"
    end
    iUsePriority = (50 * iIncOrOut) + 20 + 1
    sThisTriggerText = sSpecialStart .. sCatRegex[13][1]["string"] .. sAttackVictim .. sCatRegex[13][2]["string"] .. "(?:" .. sBodyParts .. ")" .. sCatRegex[13][3]["string"] .. sAttackEnding
    AddTriggerEx(tostring(sTriggerName .. "1"), tostring(sThisTriggerText), "", iFlags, -1, 0, "", tostring(sTriggerFunction), 12, iUsePriority)
    SetTriggerOption(tostring(sTriggerName .. "1"), "group", "module_stats")
    iTotalCombatTriggers = iTotalCombatTriggers + 1
    SetTriggerOption(tostring(sTriggerName .. "1"), "custom_colour", tostring(17))
    SetTriggerOption(tostring(sTriggerName .. "1"), "colour_change_type", "1")
    SetTriggerOption(tostring(sTriggerName .. "1"), "other_text_colour", tostring(ColourNameToRGB(sTriggerColour)))
    if (bDebugTriggers == true) then
      ColourTell("magenta", "", sTriggerName .. "1 pri " .. iUsePriority .. "= ")
      ColourNote(sTriggerColour, "", sThisTriggerText)
      Note("")
    end
    iUsePriority = (50 * iIncOrOut) + 20 + 2
    sThisTriggerText = sSpecialStart .. sCatRegex[14][1]["string"] .. sAttackVictim .. sCatRegex[14][2]["string"] .. sAttackEnding
    AddTriggerEx(tostring(sTriggerName .. "2"), tostring(sThisTriggerText), "", iFlags, -1, 0, "", tostring(sTriggerFunction), 12, iUsePriority)
    SetTriggerOption(tostring(sTriggerName .. "2"), "group", "module_stats")
    iTotalCombatTriggers = iTotalCombatTriggers + 1
    SetTriggerOption(tostring(sTriggerName .. "2"), "custom_colour", tostring(17))
    SetTriggerOption(tostring(sTriggerName .. "2"), "colour_change_type", "1")
    SetTriggerOption(tostring(sTriggerName .. "2"), "other_text_colour", tostring(ColourNameToRGB(sTriggerColour)))
    if (bDebugTriggers == true) then
      ColourTell(sCOLOUR.orange, "", sTriggerName .. "2 pri " .. iUsePriority .. "= ")
      ColourNote(sTriggerColour, "", sThisTriggerText)
      Note("")
    end
    iUsePriority = (50 * iIncOrOut) + 20 + 3
    sThisTriggerText = sSpecialStart .. sCatRegex[15][1]["string"] .. sAttackWeapon .. sCatRegex[15][2]["string"] .. sAttackVictim .. sCatRegex[15][3]["string"] .. "(?:" .. sBodyParts .. ")" .. sAttackEnding
    AddTriggerEx(tostring(sTriggerName .. "3"), tostring(sThisTriggerText), "", iFlags, -1, 0, "", tostring(sTriggerFunction), 12, iUsePriority)
    SetTriggerOption(tostring(sTriggerName .. "3"), "group", "module_stats")
    iTotalCombatTriggers = iTotalCombatTriggers + 1
    SetTriggerOption(tostring(sTriggerName .. "3"), "custom_colour", tostring(17))
    SetTriggerOption(tostring(sTriggerName .. "3"), "colour_change_type", "1")
    SetTriggerOption(tostring(sTriggerName .. "3"), "other_text_colour", tostring(ColourNameToRGB(sTriggerColour)))
    if (bDebugTriggers == true) then
      ColourTell(sCOLOUR.orange, "", sTriggerName .. "3 pri " .. iUsePriority .. "= ")
      ColourNote(sTriggerColour, "", sThisTriggerText)
      Note("")
    end
    -- Special attacks failed
    if (iIncOrOut == 1) then
      sTriggerName = "QuowSpecialFailOutCat"
      sTriggerFunction = "StatsSpecialFailOutgoing"
      sTriggerColour = "maroon"
    elseif (iIncOrOut == 2) then
      sTriggerName = "QuowSpecialFailIncCat"
      sTriggerFunction = "StatsSpecialFailIncoming"
      sTriggerColour = "olivedrab"
    elseif (iIncOrOut == 3) then
      sTriggerName = "StatsSpecialFailThirdCat"
      sTriggerFunction = "" --"StatsSpecialFailThird"
      sTriggerColour = "darkgoldenrod"
    end
    iUsePriority = (50 * iIncOrOut) + 1
    -- Special defense generation
    sThisTriggerText = sSpecialStart .. sCatRegex[13][1]["string"] .. sAttackVictim .. sCatRegex[13][2]["string"] .. "(?:" .. sBodyParts .. ")" .. sCatRegex[13][3]["string"] .. sDefenseEnding
    AddTriggerEx(tostring(sTriggerName .. "1"), tostring(sThisTriggerText), "", iFlags, -1, 0, "", tostring(sTriggerFunction), 12, iUsePriority)
    SetTriggerOption(tostring(sTriggerName .. "1"), "group", "module_stats")
    iTotalCombatTriggers = iTotalCombatTriggers + 1
    SetTriggerOption(tostring(sTriggerName .. "1"), "custom_colour", tostring(17))
    SetTriggerOption(tostring(sTriggerName .. "1"), "colour_change_type", "1")
    SetTriggerOption(tostring(sTriggerName .. "1"), "other_text_colour", tostring(ColourNameToRGB(sTriggerColour)))
    if (bDebugTriggers == true) then
      ColourTell("magenta", "", sTriggerName .. "1 pri " .. iUsePriority .. "= ")
      ColourNote(sTriggerColour, "", sThisTriggerText)
      Note("")
    end
    iUsePriority = (50 * iIncOrOut) + 2
    sThisTriggerText = sSpecialStart .. sCatRegex[14][1]["string"] .. sAttackVictim .. sCatRegex[14][2]["string"] .. sDefenseEnding
    AddTriggerEx(tostring(sTriggerName .. "2"), tostring(sThisTriggerText), "", iFlags, -1, 0, "", tostring(sTriggerFunction), 12, iUsePriority)
    SetTriggerOption(tostring(sTriggerName .. "2"), "group", "module_stats")
    iTotalCombatTriggers = iTotalCombatTriggers + 1
    SetTriggerOption(tostring(sTriggerName .. "2"), "custom_colour", tostring(17))
    SetTriggerOption(tostring(sTriggerName .. "2"), "colour_change_type", "1")
    SetTriggerOption(tostring(sTriggerName .. "2"), "other_text_colour", tostring(ColourNameToRGB(sTriggerColour)))
    if (bDebugTriggers == true) then
      ColourTell(sCOLOUR.orange, "", sTriggerName .. "2 pri " .. iUsePriority .. "= ")
      ColourNote(sTriggerColour, "", sThisTriggerText)
      Note("")
    end
    iUsePriority = (50 * iIncOrOut) + 3
    sThisTriggerText = sSpecialStart .. sCatRegex[15][1]["string"] .. sAttackWeapon .. sCatRegex[15][2]["string"] .. sAttackVictim .. sCatRegex[15][3]["string"] .. "(?:" .. sBodyParts .. ")" .. sDefenseEnding
    AddTriggerEx(tostring(sTriggerName .. "3"), tostring(sThisTriggerText), "", iFlags, -1, 0, "", tostring(sTriggerFunction), 12, iUsePriority)
    SetTriggerOption(tostring(sTriggerName .. "3"), "group", "module_stats")
    iTotalCombatTriggers = iTotalCombatTriggers + 1
    SetTriggerOption(tostring(sTriggerName .. "3"), "custom_colour", tostring(17))
    SetTriggerOption(tostring(sTriggerName .. "3"), "colour_change_type", "1")
    SetTriggerOption(tostring(sTriggerName .. "3"), "other_text_colour", tostring(ColourNameToRGB(sTriggerColour)))
    if (bDebugTriggers == true) then
      ColourTell(sCOLOUR.orange, "", sTriggerName .. "3 pri " .. iUsePriority .. "= ")
      ColourNote(sTriggerColour, "", sThisTriggerText)
      Note("")
    end
  end
--[[
Priorities/sequences:
50: You - specialling stuff + it being defended
60: You - hitting stuff + it being defended
70: You - specialling stuff
80: You - hitting stuff

100: Enemy - specialling you + it being defended
110: Enemy - hitting you + it being defended
120: Enemy - specialling you
130: Enemy - hitting you

150: Others - specialling others + it being defended
160: Others - hitting others + it being defended
170: Others - specialling others
180: Others - hitting others
--]]

  -- Now loop through the "standalone" special texts
  --sBodyParts = "(?:" .. sHumanBodyParts .. "|" .. sAnimalBodyParts .. ")"
  sBodyParts = "(?:\\w+\\b\\W*){1,4}"
  for iIncOrOut = 1, 3 do
    iCustomCombatLinesNormal = 0
    iCustomCombatLinesSpecial = 0
    iCustomCombatLinesFailNormal = 0
    --ColourNote(sCOLOUR.red, "", "=================== " .. tostring(iIncOrOut) .. "==================")
    for iKey, sData in ipairs(sStandaloneTexts) do

      sTempCut = sData[1]
      if (iIncOrOut == 1) then
        -- You (first person) are the attacker
        sTempCut = string.gsub(sTempCut, "<ATTACKER>", "You")
        sTempCut = string.gsub(sTempCut, "<attacker>", "you")
        sTempCut = string.gsub(sTempCut, "<attacker2>", "you")
        sTempCut = string.gsub(sTempCut, "<at_pl>", "r")
        sTempCut = string.gsub(sTempCut, "<WEAPON>", "(?>One of your|Your) (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<weapon>", "(?:one of )?your (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<WEAPON2>", "(?>One of your|Your) (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<weapon2>", "(?:one of )?your (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<weapon3>", "(?:one of )?(?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<weapon4>", "(?:one of )?your (" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<VICTIM>", "(?:(?!You |You,|Your )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<victim>", "(?:(?!you |you,|your )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<VICTIM2>", "((?!You |You,|Your )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<victim2>", "((?!you |you,|your )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<vic_pl>", "'s?")
        sTempCut = string.gsub(sTempCut, "<a_his>", "your")
        sTempCut = string.gsub(sTempCut, "<a_he>", "you")
        sTempCut = string.gsub(sTempCut, "<a_himself>", "yourself")
        sTempCut = string.gsub(sTempCut, "<v_his>", "(?>his|her|its)")
        sTempCut = string.gsub(sTempCut, "<V_HIS>", "(?>His|Her|Its)")
        sTempCut = string.gsub(sTempCut, "<v_him>", "(?>him|her|it)")
        sTempCut = string.gsub(sTempCut, "<V_HE>", "(?>He|She|It)")
        sTempCut = string.gsub(sTempCut, "<v_he>", "(?>he|she|it)")
        sTempCut = string.gsub(sTempCut, "<v_is>", "is")
        sTempCut = string.gsub(sTempCut, "<v_himself>", "(?>himself|herself|itself)")
      elseif (iIncOrOut == 2) then
        -- You (first person) are the victim
        sTempCut = string.gsub(sTempCut, "<ATTACKER>", "(?:(?!You )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<attacker>", "(?:(?!you )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<attacker2>", "((?!you )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<at_pl>", "'s?")
        sTempCut = string.gsub(sTempCut, "<WEAPON>", "(?>One of (?>his|her|its)|His|Her|Its) (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<weapon>", "(?:one of )?(?>his|her|its) (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<WEAPON2>", "(?:One of )?(?:(?!Your )" .. sWild .. ")'s? (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<weapon2>", "(?:one of )?(?:(?!your )" .. sWild .. ")'s? (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<weapon3>", "(?:one of )?(?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<weapon4>", "(?:one of )?((?!your )" .. sWild .. ")'s? (" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<VICTIM>", "You")
        sTempCut = string.gsub(sTempCut, "<victim>", "you")
        sTempCut = string.gsub(sTempCut, "<victim2>", "you")
        sTempCut = string.gsub(sTempCut, "<VICTIM2>", "You")
        sTempCut = string.gsub(sTempCut, "<vic_pl>", "r")
        sTempCut = string.gsub(sTempCut, "<a_he>", "(?>he|she|it)")
        sTempCut = string.gsub(sTempCut, "<a_his>", "(?>his|her|its)")
        sTempCut = string.gsub(sTempCut, "<a_himself>", "(?>himself|herself|itself)")
        sTempCut = string.gsub(sTempCut, "<v_his>", "your")
        sTempCut = string.gsub(sTempCut, "<V_HIS>", "Your")
        sTempCut = string.gsub(sTempCut, "<v_him>", "you")
        sTempCut = string.gsub(sTempCut, "<V_HE>", "You")
        sTempCut = string.gsub(sTempCut, "<v_he>", "you")
        sTempCut = string.gsub(sTempCut, "<v_is>", "are")
        sTempCut = string.gsub(sTempCut, "<v_himself>", "yourself")
      elseif (iIncOrOut == 3) then
        -- You are not involved at all
        sTempCut = string.gsub(sTempCut, "<ATTACKER>", "(?:(?!You )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<attacker>", "(?:(?!you )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<attacker2>", "((?!you )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<at_pl>", "'s?")
        sTempCut = string.gsub(sTempCut, "<weapon>", "(?:one of )?(?>his|her|its) (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<WEAPON>", "(?>One of (?>his|her|its)|His|Her|Its) (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<WEAPON2>", "(?:One of )?(?:(?!Your )" .. sWild .. ")'s? (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<weapon2>", "(?:one of )?(?:(?!your )" .. sWild .. ")'s? (?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<weapon3>", "(?:one of )?(?:" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<weapon4>", "(?:one of )?((?!your )" .. sWild .. ")'s? (" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<VICTIM>", "(?:(?!You |You,|Your )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<victim>", "(?:(?!you |you,|your )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<VICTIM2>", "((?!You |You,|Your )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<victim2>", "((?!you |you,|your )" .. sWild .. ")")
        sTempCut = string.gsub(sTempCut, "<vic_pl>", "'s?")
        sTempCut = string.gsub(sTempCut, "<a_he>", "(?>he|she|it)")
        sTempCut = string.gsub(sTempCut, "<a_his>", "(?>his|her|its)")
        sTempCut = string.gsub(sTempCut, "<a_himself>", "(?>himself|herself|itself)")
        sTempCut = string.gsub(sTempCut, "<v_his>", "(?>his|her|its)")
        sTempCut = string.gsub(sTempCut, "<V_HIS>", "(?>His|Her|Its)")
        sTempCut = string.gsub(sTempCut, "<v_him>", "(?>him|her|it)")
        sTempCut = string.gsub(sTempCut, "<V_HE>", "(?>He|She|It)")
        sTempCut = string.gsub(sTempCut, "<v_he>", "(?>he|she|it)")
        sTempCut = string.gsub(sTempCut, "<v_is>", "is")
        sTempCut = string.gsub(sTempCut, "<v_himself>", "(?>himself|herself|itself)")
      end
      sTempCut = string.gsub(sTempCut, "<bodypart>", sBodyParts)
      sTempCut = "^(?:> )?" .. sTempCut
      -- Special attacks succeeded
      if (sData[2] == 1) then
        iCustomCombatLinesSpecial = iCustomCombatLinesSpecial + 1
        if (iIncOrOut == 1) then
          sTriggerName = "QuowSpecialSuccessOutS" .. iCustomCombatLinesSpecial
          sTriggerFunction = "StatsSpecialSuccessOutgoing"
          sTriggerColour = "darkgoldenrod"
        elseif (iIncOrOut == 2) then
          sTriggerName = "QuowSpecialSuccessIncS" .. iCustomCombatLinesSpecial
          sTriggerFunction = "StatsSpecialSuccessIncoming"
          sTriggerColour = "maroon"
        elseif (iIncOrOut == 3) then
          sTriggerName = "StatsSpecialSuccessThirdS" .. iCustomCombatLinesSpecial
          sTriggerFunction = ""--"StatsSpecialSuccessThird"
          sTriggerColour = "#3C4420"
        end
        -- No other types here yet?
      elseif (sData[2] == 2) then
        iCustomCombatLinesNormal = iCustomCombatLinesNormal + 1
        if (iIncOrOut == 1) then
          sTriggerName = "QuowMeleeSuccessOutCat_Custom" .. iCustomCombatLinesNormal
          sTriggerFunction = "StatsMeleeSuccessOutgoing"
          sTriggerColour = "darkgoldenrod"
        elseif (iIncOrOut == 2) then
          sTriggerName = "QuowMeleeSuccessIncCat_Custom" .. iCustomCombatLinesNormal
          sTriggerFunction = "StatsMeleeSuccessIncoming"
          sTriggerColour = "maroon"
        elseif (iIncOrOut == 3) then
          sTriggerName = "StatsMeleeSuccessThirdCat_Custom" .. iCustomCombatLinesNormal
          sTriggerFunction = "StatsMeleeSuccessThird"
          sTriggerColour = "#3C4420"
        end
      end
      -- Defensive parts to the custom line
      if (sData[3] ~= nil and sData[3] == true) then
        iCustomCombatLinesFailNormal = iCustomCombatLinesFailNormal + 1
        if (iIncOrOut == 1) then
          sDefenseEnding = ".*( as " .. sWild .. " leaps in at the last moment to protect " .. sWild .. ")? but( |, although unable to defend, | despite the surprise )(?:(?:(?>her |his |its )(?P<shielding>" .. sWildLong .. ") (?:swoops in and )?absorbs? all of the (?>blow|impact))|(?P<focus>you cannot seem to reach the place you are focusing on)|(?:he|she|" .. sWild .. ")(?P<level> barely| just| easily| deftly)?(?P<type> dodges out of the way| parries the blow with (?>his|her|its) " .. sWild .. "| blocks the blow with (?>his|her|its) " .. sWild .. "| somehow avoids the attack| deflects your lunge))\\.$"
          sDefenseFunction = "StatsMeleeFailOutgoing"
          sDefenseTrigger = "QuowMeleeFailOutCat_Custom" .. iCustomCombatLinesFailNormal
        elseif (iIncOrOut == 2) then
          sDefenseEnding = ".*(?: as you leap in at the last moment to protect " .. sWild .. ")? but( |, although unable to defend, | despite the surprise )(?:(?:your (?P<shielding>" .. sWildLong .. ") (?:swoops in and )?absorbs? all of the (?>blow|impact))|(?P<focus>(?>he |she |it )?cannot seem to reach the place (?>he|she|it) is focusing on)|you(?P<level> barely| just| easily| deftly)?(?P<type> dodge out of the way| parry the blow with your " .. sWild .. "| block the blow with your " .. sWild .. "| somehow avoid the attack| deflect (?>his|her|its) lunge))\\.$"
          sDefenseFunction = "StatsMeleeFailIncoming"
          sDefenseTrigger = "QuowMeleeFailIncCat_Custom" .. iCustomCombatLinesFailNormal
        elseif (iIncOrOut == 3) then
          sDefenseEnding = ".*( as " .. sWild .. " leaps in at the last moment to protect " .. sWild .. ")? but( |, although unable to defend, | despite the surprise )(?:(?:(?>her |his |its )(?P<shielding>" .. sWildLong .. ") (?:swoops in and )?absorbs? all of the (?>blow|impact))|(?P<focus>(?>he |she |it )?cannot seem to reach the place (?>he|she|it) is focusing on)|(?:he|she|" .. sWild .. ")(?P<level> barely| just| easily| deftly)?(?P<type> dodges out of the way| parries the blow with (?>his|her|its) " .. sWild .. "| blocks the blow with (?>his|her|its) " .. sWild .. "| somehow avoids the attack| deflects (?>his|her|its) lunge))\\.$"
          sDefenseFunction = "StatsMeleeFailThird"
          sDefenseTrigger = "StatsMeleeFailThirdCat_Custom" .. iCustomCombatLinesFailNormal
        end
        iUsePriority = 150 + (50 * iIncOrOut)
        AddTriggerEx(tostring(sDefenseTrigger), tostring(sTempCut .. sDefenseEnding), "", iFlags, -1, 0, "", tostring(sDefenseFunction), 12, iUsePriority)
        SetTriggerOption(tostring(sDefenseTrigger), "group", "module_stats")
        iTotalCombatTriggers = iTotalCombatTriggers + 1
        SetTriggerOption(tostring(sDefenseTrigger), "custom_colour", tostring(17))
        SetTriggerOption(tostring(sDefenseTrigger), "colour_change_type", "1")
        SetTriggerOption(tostring(sDefenseTrigger), "other_text_colour", tostring(ColourNameToRGB(sTriggerColour)))
        if (bDebugTriggers == true) then
          ColourTell(sCOLOUR.orange, "", sDefenseTrigger .. " pri " .. iUsePriority .. "= ")
          ColourNote(sTriggerColour, "", sTempCut .. sDefenseEnding)
          Note("")
        end
      end
      -- Special custom line
      iUsePriority = 150 + (50 * iIncOrOut) + 20
      AddTriggerEx(tostring(sTriggerName), tostring(sTempCut .. ".+?$"), "", iFlags, -1, 0, "", tostring(sTriggerFunction), 12, iUsePriority)
      SetTriggerOption(tostring(sTriggerName), "group", "module_stats")
      iTotalCombatTriggers = iTotalCombatTriggers + 1
      SetTriggerOption(tostring(sTriggerName), "custom_colour", tostring(17))
      SetTriggerOption(tostring(sTriggerName), "colour_change_type", "1")
      SetTriggerOption(tostring(sTriggerName), "other_text_colour", tostring(ColourNameToRGB(sTriggerColour)))
      if (bDebugTriggers == true) then
        ColourTell(sCOLOUR.orange, "", sTriggerName .. " pri " .. iUsePriority .. "= ")
        ColourNote(sTriggerColour, "", sTempCut)
        Note("")
      end
    end -- Loop through standalone specials
  end -- In or out 1-3
end



-- Experimental future idea to check which is faster to process - tonnes of if-checks and string commands, or giant piles of regex
-- Also this is risky for "false-positives", eg souls and such??  And without colour-matching, would have to run on EVERY line??
function AnalyseCombatLine(sName, sLine, wildcards, objStyles)
  local sThisAttacker, sVictim = "", ""
  for iN, objThisStyle in pairs(objStyles) do
    Note(tostring(iN) .. ": style=" .. tostring(objThisStyle["style"]) .. " text=" .. tostring(objThisStyle["text"]))
    -- and objThisStyle["length"] > 0
    --[[
    if (objThisStyle ~= nil and objThisStyle["style"] ~= nil and objThisStyle["style"] == 2) then
       sThisAttacker = objThisStyle["text"]
      break
    end
    --]]
  end
end

sQuowDefenseTypes = {
  [0] = {"", "UNKNOWN ERROR?"},
  [1] = {"defended_dodged", "Dodge"},
  [2] = {"defended_parried", "Parry"},
  [3] = {"defended_blocked", "Block"},
  [4] = {"armoured", "Armour"},
  [5] = {"tpa", "TPA"},
  [6] = {"bugs", "Bug Shield"},
  [7] = {"major", "Major Shield"},
  [8] = {"ccc", "CCC"},
  [9] = {"eff", "EFF"},
}
sQuowDefenseLevels = {
  [0] = {"", "UNKNOWN ERROR?"},
  [1] = {"barely", "Bad"},
  [2] = {"normal", "Normal"},
  [3] = {"deftly", "Good"},
  [4] = {"somehow", "Somehow Avoids"},
}
sQuowAbsorbTypes = {
  ["magical shielding"] = 5,
  ["wall of dust"] = 7,
  ["cloak of fog"] = 7,
  ["layer of fluff"] = 7,
  ["feathery skin"] = 7,
  ["slimy cloak"] = 7,
  ["holy olive wool vestment"] = 7,
  ["flaming barrier"] = 7,
  ["cloud of banners"] = 7,
  ["shimmering flames"] = 7,
  ["layer of waves"] = 7,
  ["chalky skin"] = 8, 
  ["elastic skin"] = 8, 
  ["metallic skin"] = 8,
 }

-- Convert the trigger into defensive types and levels
function GetDefensiveType(sDefenseWildcard, sLevelWildcard, sShieldingWildcard)
  if (sDefenseWildcard == nil) then
    sDefenseWildcard = ""
  end
  if (sShieldingWildcard == nil) then
    sShieldingWildcard = ""
  end
  if (sLevelWildcard == nil) then
    sLevelWildcard = ""
  end
  local iLevel = 0
  local iDefense = 0
  --Note("Shielding='" .. sShieldingWildcard .. "', Defensing='" .. sDefenseWildcard .. "', Level='" .. sLevelWildcard .. "'")
  if (string.sub(sDefenseWildcard, 1, 6) == " dodge") then
    iDefense = 1
    iLevel = 2
  elseif (string.sub(sDefenseWildcard, 1, 5) == " parr" or string.sub(sDefenseWildcard, 1, 8) == " deflect") then
    iDefense = 2
    iLevel = 2
  elseif (string.sub(sDefenseWildcard, 1, 6) == " block") then
    iDefense = 3
    iLevel = 2
  elseif (string.sub(sDefenseWildcard, 1, 14) == " somehow avoid") then
    iDefense = 1
    iLevel = 4
  elseif (string.sub(sShieldingWildcard, 1, 9) == "floating ") then
    -- Wizard or Witch EFF
    iDefense = 9
  elseif (sQuowAbsorbTypes[sShieldingWildcard] ~= nil) then
    -- TPA, Major Shields, CCC
    iDefense = sQuowAbsorbTypes[sShieldingWildcard]
  elseif (string.sub(sShieldingWildcard, 1, 11) == "handful of " or string.sub(sShieldingWildcard, 1, 9) == "cloud of " or string.sub(sShieldingWildcard, 1, 15) == "small swarm of " or string.sub(sShieldingWildcard, 1, 15) == "large swarm of " or string.sub(sShieldingWildcard, 1, 14) == "vast swarm of " or string.sub(sShieldingWildcard, 1, 10) == "plague of ") then
    -- Witch bug shield
    iDefense = 6
  elseif (sShieldingWildcard ~= "") then
    -- Anything else is treated as physical armour (even if it's a combo, eg minor shield + security blanket)
    iDefense = 4
  end
  if (sLevelWildcard == " just" or sLevelWildcard == " barely") then
    iLevel = 1
  elseif (sLevelWildcard == " easily" or sLevelWildcard == " deftly" or sLevelWildcard == " quickly" or sLevelWildcard == " swiftly") then
    iLevel = 3
  end
  return iDefense, iLevel
end

function StatAddDefenseCalcIncoming(wildcards)
  -- Was this a zonefail, or some other kind of defense maybe
  if (wildcards.focus ~= nil and wildcards.focus ~= "") then
    iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] + 1
    iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_zonefail"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_zonefail"] + 1
  elseif ((wildcards.type ~= nil and wildcards.type ~= "") or (wildcards.shielding ~= nil and wildcards.shielding ~= "")) then
    iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] + 1
    local iThisDefense = 0
    local iThisLevel = 0
    iThisDefense, iThisLevel = GetDefensiveType(wildcards.type, wildcards.level, wildcards.shielding)
    local sThisStat = "hits_inc_" .. sQuowDefenseTypes[iThisDefense][1]
    iQuowCombatStats[iCurrentCombatStatSet][sThisStat] = iQuowCombatStats[iCurrentCombatStatSet][sThisStat] + 1
    if (iThisLevel > 0) then
      sThisStat = sThisStat .. "_" .. sQuowDefenseLevels[iThisLevel][1]
      iQuowCombatStats[iCurrentCombatStatSet][sThisStat] = iQuowCombatStats[iCurrentCombatStatSet][sThisStat] + 1
    end
  else
    iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_defended"] + 1
  end
end
function StatAddDefenseCalcOutgoing(wildcards)
  -- Was this a zonefail, or some other kind of defense maybe
  if (wildcards.focus ~= nil and wildcards.focus ~= "") then
    iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] + 1
    iQuowCombatStats[iCurrentCombatStatSet]["hits_out_zonefail"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_out_zonefail"] + 1
  elseif ((wildcards.type ~= nil and wildcards.type ~= "") or (wildcards.shielding ~= nil and wildcards.shielding ~= "")) then
    iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] + 1
    local iThisDefense = 0
    local iThisLevel = 0
    iThisDefense, iThisLevel = GetDefensiveType(wildcards.type, wildcards.level, wildcards.shielding)
    local sThisStat = "hits_out_" .. sQuowDefenseTypes[iThisDefense][1]
    iQuowCombatStats[iCurrentCombatStatSet][sThisStat] = iQuowCombatStats[iCurrentCombatStatSet][sThisStat] + 1
    if (iThisLevel > 0) then
      sThisStat = sThisStat .. "_" .. sQuowDefenseLevels[iThisLevel][1]
      iQuowCombatStats[iCurrentCombatStatSet][sThisStat] = iQuowCombatStats[iCurrentCombatStatSet][sThisStat] + 1
    end
  else
    iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_out_defended"] + 1
  end
end

-- OUTGOING:  A DEFENDED/BLOCKED hit
function StatsMeleeFailOutgoing(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] + 1
  StatAddDefenseCalcOutgoing(wildcards)
  --RedrawStatsWindow()
end
-- INCOMING:  A DEFENDED/BLOCKED hit
function StatsMeleeFailIncoming(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] + 1
  StatAddDefenseCalcIncoming(wildcards)
  --RedrawStatsWindow()
end
-- Third-Party:  A DEFENDED/BLOCKED hit
function StatsMeleeFailThird(sName, sLine, wildcards)
  -- Function currently disabled in regex generation
end


-- OUTGOING:  A DEFENDED Special
function StatsSpecialFailOutgoing(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] + 1
  iQuowCombatStats[iCurrentCombatStatSet]["special_out_defended"] = iQuowCombatStats[iCurrentCombatStatSet]["special_out_defended"] + 1
  StatAddDefenseCalcOutgoing(wildcards)
  --RedrawStatsWindow()
end
-- INCOMING:  A DEFENDED Special 
function StatsSpecialFailIncoming(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] + 1
  iQuowCombatStats[iCurrentCombatStatSet]["special_inc_defended"] = iQuowCombatStats[iCurrentCombatStatSet]["special_inc_defended"] + 1
  StatAddDefenseCalcIncoming(wildcards)
  --RedrawStatsWindow()
end
-- Third-Party:  A DEFENDED Special
function StatsSpecialFailThird(sName, sLine, wildcards)
  -- Function currently disabled in regex generation
end

-- OUTGOING:  A SUCCESFUL hit (did not get dodged, blocked, parried, or fully absorbed - partial hits count as successful hits!)
function StatsMeleeSuccessOutgoing(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] + 1
  iQuowCombatStats[iCurrentCombatStatSet]["hits_out_landed"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_out_landed"] + 1
  --RedrawStatsWindow()
end
-- INCOMING:  A SUCCESFUL hit (did not get dodged, blocked, parried, or fully absorbed - partial hits count as successful hits!)
function StatsMeleeSuccessIncoming(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] + 1
  iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_landed"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_landed"] + 1
  --RedrawStatsWindow()
end
-- Third-Party:  A SUCCESFUL hit (did not get dodged, blocked, parried, or fully absorbed - partial hits count as successful hits!)
function StatsMeleeSuccessThird(sName, sLine, wildcards)
  -- Function currently disabled in regex generation
end

-- OUTGOING:  A SUCCESFUL Special
function StatsSpecialSuccessOutgoing(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_out_total"] + 1
  iQuowCombatStats[iCurrentCombatStatSet]["hits_out_landed"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_out_landed"] + 1
  iQuowCombatStats[iCurrentCombatStatSet]["special_out_landed"] = iQuowCombatStats[iCurrentCombatStatSet]["special_out_landed"] + 1
  --RedrawStatsWindow()
end
-- INCOMING:  A SUCCESFUL Special 
function StatsSpecialSuccessIncoming(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_total"] + 1
  iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_landed"] = iQuowCombatStats[iCurrentCombatStatSet]["hits_inc_landed"] + 1
  iQuowCombatStats[iCurrentCombatStatSet]["special_inc_landed"] = iQuowCombatStats[iCurrentCombatStatSet]["special_inc_landed"] + 1
  --RedrawStatsWindow()
end
-- Third-Party:  A SUCCESFUL Special
function StatsSpecialSuccessThird(sName, sLine, wildcards)
  -- Function currently disabled in regex generation
end

-- OUTGOING:  A SUCCESFUL Special, but no hits
function StatsSpecialSuccessNoHitOutgoing(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["special_out_landed"] = iQuowCombatStats[iCurrentCombatStatSet]["special_out_landed"] + 1
  --RedrawStatsWindow()
end
-- INCOMING:  A SUCCESFUL Special, but no hits
function StatsSpecialSuccessNoHitIncoming(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["special_inc_landed"] = iQuowCombatStats[iCurrentCombatStatSet]["special_inc_landed"] + 1
  --RedrawStatsWindow()
end
-- Third-Party:  A SUCCESFUL Special, but no hits
function StatsSpecialSuccessNoHitThird(sName, sLine, wildcards)
  -- Function currently disabled in regex generation
end
-- OUTGOING:  A DEFENDED Special, but no hits
function StatsSpecialFailNoHitOutgoing(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["special_out_defended"] = iQuowCombatStats[iCurrentCombatStatSet]["special_out_defended"] + 1
  --RedrawStatsWindow()
end
-- INCOMING:  A DEFENDED Special, but no hits
function StatsSpecialFailNoHitIncoming(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["special_inc_defended"] = iQuowCombatStats[iCurrentCombatStatSet]["special_inc_defended"] + 1
  --RedrawStatsWindow()
end
-- Third-Party:  A DEFENDED Special, but no hits
function StatsSpecialFailNoHitThird(sName, sLine, wildcards)
  -- Function currently disabled in regex generation
end

-- You (player) failed to prepare a special.
function StatsSpecialPrepareFail(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["special_out_failprepared"] = iQuowCombatStats[iCurrentCombatStatSet]["special_out_failprepared"] + 1
  --RedrawStatsWindow()
end

-- You (player) preparing a special.
function StatsSpecialPrepareSuccess(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["special_out_prepared"] = iQuowCombatStats[iCurrentCombatStatSet]["special_out_prepared"] + 1
  --RedrawStatsWindow()
end

-- You killed something
function StatsKillStatOutgoing(sName, sLine, wildcards)
  -- Temporary group kill stat
  if (sGroupMembers[sMyPlayerName] ~= nil) then
    sGroupMembers[sMyPlayerName]["Kills"] = sGroupMembers[sMyPlayerName]["Kills"] + 1
  end
  -- Main stat
  iQuowCombatStats[iCurrentCombatStatSet]["kills_total"] = iQuowCombatStats[iCurrentCombatStatSet]["kills_total"] + 1
  RedrawStatsWindow()
end

-- You got killed by something
function StatsKillStatIncoming(sName, sLine, wildcards)
  iQuowCombatStats[iCurrentCombatStatSet]["deaths_total"] = iQuowCombatStats[iCurrentCombatStatSet]["deaths_total"] + 1
  RedrawStatsWindow()
end

-- Third party killing something else
function StatsKillStatThird(sName, sLine, wildcards)
  -- Group kill stats
  sUsePlayerName = FilterPlayerName(wildcards.att)
  if (sUsePlayerName ~= nil) then
    sGroupMembers[sUsePlayerName]["Kills"] = sGroupMembers[sUsePlayerName]["Kills"] + 1
  end
end


-- ******************************
-- ***** Auto GP Regenerate *****
-- ******************************
-- Update the user's GP bar each heartbeat
function UpdateGPGeneration()
  if (iCharVitals["gp"] < iCharVitals["maxgp"] and iQuowCombatStats[iCurrentCombatStatSet]["gp_regen"] > 0) then
    iCharVitals["gp"] = iCharVitals["gp"] + iQuowCombatStats[iCurrentCombatStatSet]["gp_regen"]
    if (iCharVitals["gp"] > iCharVitals["maxgp"]) then
      iCharVitals["gp"] = iCharVitals["maxgp"]
    end
    bForceVitalsUpdate = true
    RedrawVitalsWindow()
    Redraw()
  end
end


-- Watching for players logging on, so we can switch combat sets automatically if desired
function HandleLoginNotificationTrigger(sName, sLine, wildcards)
  if (iQuowSetNameID[wildcards.login] ~= nil) then
    HandleLoginCharacter(wildcards.login)
  end
end
function HandleLoginCharacter(sThisPlayerName)
  if (iQuowSetNameID[sThisPlayerName] ~= nil and iQuowSetNameID[sThisPlayerName] ~= iCurrentCombatStatSet) then
    QuowSwitchStatSet(iQuowSetNameID[sThisPlayerName], true)
    ColourNote(sCOLOUR.orange, "", "Quow's Cow Bar automatically switching to combat set " .. iCurrentCombatStatSet .. " ['" .. sThisPlayerName .. "']")
  end
end

-- Filter through possible titles and family names finding a valid group member name, or return nil if none found
function FilterPlayerName(sPlayerName)
  sPlayerName = string.gsub (sPlayerName, "%f[%a].", string.upper)
  -- Check we don't already have a perfectly valid name without any edits
  if (sGroupMembers[sPlayerName] ~= nil) then
    return sPlayerName
  end
  -- Loop through the individual words, and find one that matches a group member
  for sCutName in string.gmatch(sPlayerName, "%w+") do
    if (sGroupMembers[sCutName] ~= nil) then
      return sCutName
    end
  end
  return nil
end

      
-- Found your name and exact stats for the group
function HandleGroupStatusMe(sName, sLine, wildcards)
  -- wildcards.player
  --sMyPlayerName = wildcards.player
  if (sGroupMembers[sMyPlayerName] == nil) then
    sGroupMembers[sMyPlayerName] = {["HP"] = sGroupMembers["You"]["HP"], ["GP"] = sGroupMembers["You"]["GP"], ["TPA"] = sGroupMembers["You"]["TPA"], ["CCC"] = sGroupMembers["You"]["CCC"], ["EFF"] = sGroupMembers["You"]["EFF"], ["BUG"] = sGroupMembers["You"]["BUG"], ["MS"] = sGroupMembers["You"]["MS"], ["MemberSince"] = OST(), ["Kills"] = 0}
  else
    sGroupMembers[sMyPlayerName]["HP"] = sGroupMembers["You"]["HP"]
    sGroupMembers[sMyPlayerName]["GP"] = sGroupMembers["You"]["GP"]
  end
  RedrawShieldsWindow()
  Redraw()
end

sStatusHP = {
  ["unhurt"] = 100,
  ["almost unhurt"] = 95,
  ["scratched"] = 90,
  ["slightly hurt"] = 80,
  ["slightly injured"] = 70,
  ["injured"] = 60,
  ["slightly wounded"] = 50,
  ["wounded"] = 40,
  ["badly wounded"] = 30,
  ["heavily wounded"] = 20,
  ["seriously wounded"] = 15,
  ["critically wounded"] = 10,
  ["near death"] = 5,
}
sStatusGP = {
  ["refreshed"] = 100,
  ["clear of mind"] = 90,
  ["concentrated"] = 80,
  ["slightly confused"] = 70,
  ["confused"] = 60,
  ["slightly fatigued"] = 50,
  ["fatigued"] = 40,
  ["very fatigued"] = 30,
  ["highly fatigued"] = 20,
  ["severely fatigued"] = 10,
  ["near unconscious"] = 5,
}

-- Name, rough health status and rough GP status of another group member
function HandleGroupStatusOther(sName, sLine, wildcards)
  local iHP = 0
  local iGP = 0
  if (sStatusHP[wildcards.hp] ~= nil) then
    iHP = sStatusHP[wildcards.hp]
  end
  if (sStatusGP[wildcards.gp] ~= nil) then
    iGP = sStatusGP[wildcards.gp]
  end 
  if (sGroupMembers[wildcards.player] == nil) then
    sGroupMembers[wildcards.player] = {["HP"] = iHP, ["GP"] = iGP, ["TPA"] = 0, ["CCC"] = 0, ["EFF"] = 0, ["BUG"] = 0, ["MS"] = 0, ["MemberSince"] = OST(), ["Kills"] = 0}
  else
    sGroupMembers[wildcards.player]["HP"] = iHP
    sGroupMembers[wildcards.player]["GP"] = iGP
  end
  RedrawShieldsWindow()
  Redraw()
end

-- You join a group
function HandleGroupJoinMe(sName, sLine, wildcards)
  -- wildcards.groupname
end
-- You leave a group
function HandleGroupLeaveMe(sName, sLine, wildcards)
  -- wildcards.groupname
  for sCharacterName, sGroupData in pairs(sGroupMembers) do
    if (sCharacterName ~= "You") then
      sGroupMembers[sCharacterName] = nil
    end
  end
  RedrawShieldsWindow()
  Redraw()
end
-- Someone joins your group
function HandleGroupJoinOther(sName, sLine, wildcards)
  -- wildcards.groupname
  -- wildcards.player
  wildcards.player = string.gsub(wildcards.player, "%f[%a].", string.upper)
  if (sGroupMembers[wildcards.player] == nil) then
    sGroupMembers[wildcards.player] = {["HP"] = 0, ["GP"] = 0, ["TPA"] = 0, ["CCC"] = 0, ["EFF"] = 0, ["BUG"] = 0, ["MS"] = 0, ["MemberSince"] = OST(), ["Kills"] = 0}
    RedrawShieldsWindow()
    Redraw()
  end
end
-- Someone leaves your group
function HandleGroupLeaveOther(sName, sLine, wildcards)
  -- wildcards.groupname
  -- wildcards.player
  wildcards.player = string.gsub(wildcards.player, "%f[%a].", string.upper)
  if (sGroupMembers[wildcards.player] ~= nil) then
    sGroupMembers[wildcards.player] = nil
    RedrawShieldsWindow()
    Redraw()
  end
end


-- Recording your own personal shields
function HandleArcaneTriggerMe(sName, sLine, wildcards)
  iArcaneGatherLastSaw = OST()
  sArcaneGatherPlayerSeen = "You"
  sGroupMembers[sArcaneGatherPlayerSeen]["TPA"] = 0
  sGroupMembers[sArcaneGatherPlayerSeen]["CCC"] = 0
  sGroupMembers[sArcaneGatherPlayerSeen]["EFF"] = 0
  sGroupMembers[sArcaneGatherPlayerSeen]["BUG"] = 0
  sGroupMembers[sArcaneGatherPlayerSeen]["MS"] = 0
  -- If we're part of a group, then record this as a group thing
  if (sGroupMembers[sMyPlayerName] ~= nil) then
    sArcaneGatherPlayerSeen = sMyPlayerName
    sGroupMembers[sArcaneGatherPlayerSeen]["TPA"] = 0
    sGroupMembers[sArcaneGatherPlayerSeen]["CCC"] = 0
    sGroupMembers[sArcaneGatherPlayerSeen]["EFF"] = 0
    sGroupMembers[sArcaneGatherPlayerSeen]["BUG"] = 0
    sGroupMembers[sArcaneGatherPlayerSeen]["MS"] = 0
  end
end


-- Recording a players arcane shields
sArcaneGatherPlayerSeen = ""
iArcaneGatherLastSaw = 0
function HandleArcaneTriggerOther(sName, sLine, wildcards)
  if (wildcards.player ~= nil and wildcards.player ~= "") then
    wildcards.player = string.gsub(wildcards.player, "%f[%a].", string.upper)
    iArcaneGatherLastSaw = OST()
    sArcaneGatherPlayerSeen = wildcards.player
    if (sGroupMembers[sArcaneGatherPlayerSeen] == nil) then
      sGroupMembers[sArcaneGatherPlayerSeen] = {["HP"] = 0, ["GP"] = 0, ["TPA"] = 0, ["CCC"] = 0, ["EFF"] = 0, ["BUG"] = 0, ["MS"] = 0, ["MemberSince"] = OST(), ["Kills"] = 0}
    else
      sGroupMembers[sArcaneGatherPlayerSeen]["TPA"] = 0
      sGroupMembers[sArcaneGatherPlayerSeen]["CCC"] = 0
      sGroupMembers[sArcaneGatherPlayerSeen]["EFF"] = 0
      sGroupMembers[sArcaneGatherPlayerSeen]["BUG"] = 0
      sGroupMembers[sArcaneGatherPlayerSeen]["MS"] = 0
      if (sArcaneGatherPlayerSeen == sMyPlayerName) then
        sGroupMembers["You"]["TPA"] = 0
        sGroupMembers["You"]["CCC"] = 0
        sGroupMembers["You"]["EFF"] = 0
        sGroupMembers["You"]["BUG"] = 0
        sGroupMembers["You"]["MS"] = 0
      end
    end
    RedrawShieldsWindow()
    Redraw()
  end
end


-- Recording a shield type
function HandleShieldData(sName, sLine, wildcards)
  local bNeedUpdate = false
  local sMessageType = string.sub(sName, -7, -5)
  local sShieldType = string.sub(sName, -3)
  -- Major shield string is shorter
  if (sShieldType == "_MS") then
    sShieldType = "MS"
  end
  -- Make sure we've got a valid playername that was seen in the last few moments if appropriate
  local sUsePlayerName
  if (sMessageType == "YNU") then
    -- You, shield up
    bNeedUpdate = true
    sGroupMembers["You"][sShieldType] = 100
    if (sGroupMembers[sMyPlayerName] ~= nil) then
      sGroupMembers[sMyPlayerName][sShieldType] = 100
    end
  elseif (sMessageType == "YND") then
    -- You, shield down
    if (bSoundPlayShields["self_" .. string.lower(sShieldType)] == true and objSoundPlayShields["self_" .. string.lower(sShieldType)] ~= nil) then
      local iSoundError = PlaySoundMemory(0, objSoundPlayShields["self_" .. string.lower(sShieldType)], false, -6, 0)
      if (iSoundError ~= 0) then
        ColourNote(sCOLOUR.orange, "", "(Cow Bar just failed to play shield break sound self_" .. string.lower(sShieldType) .. ": MUSH error code " .. iSoundError .. ")")
      end
    end
    -- Chat alerts
    if (bSelfShieldChats == true) then
      local sShieldMessage = "Your " .. sShieldType .. " shield has failed!"
      HandleCommsMessage("CommLog_Tells_In", sShieldMessage, "", {[1] = {["textcolour"] = iCOLOUR.red, ["backcolour"] = iCOLOUR.black, ["text"] = sShieldMessage, ["length"] = string.len(sShieldMessage)}})
    end
    -- Update miniwindows
    bNeedUpdate = true
    sGroupMembers["You"][sShieldType] = 0
    if (sGroupMembers[sMyPlayerName] ~= nil) then
      sGroupMembers[sMyPlayerName][sShieldType] = 0
    end
  elseif (sMessageType == "ONU") then
    -- Other person, shield ups
    sUsePlayerName = FilterPlayerName(wildcards.player)
    if (sUsePlayerName == nil) then
      return
    end
    if (sGroupMembers[sUsePlayerName] ~= nil) then
      bNeedUpdate = true
      sGroupMembers[sUsePlayerName][sShieldType] = 100
    end
  elseif (sMessageType == "OND") then
    -- Other person, shield down
    sUsePlayerName = FilterPlayerName(wildcards.player)
    if (sUsePlayerName == nil) then
      return
    end
    if (sGroupMembers[sUsePlayerName] ~= nil) then
      -- Group member, shield down
      if (bSoundPlayShields["group_" .. string.lower(sShieldType)] == true and objSoundPlayShields["group_" .. string.lower(sShieldType)] ~= nil) then
        local iSoundError = PlaySoundMemory(0, objSoundPlayShields["group_" .. string.lower(sShieldType)], false, -6, 0)
        if (iSoundError ~= 0) then
          ColourNote(sCOLOUR.orange, "", "(Cow Bar just failed to play shield break sound group_" .. string.lower(sShieldType) .. ": MUSH error code " .. iSoundError .. ")")
        end
      end
      -- Chat alerts
      if (bSelfShieldChats == true) then
        local sShieldMessage = sUsePlayerName .. " " .. sShieldType .. " shield has failed!"
        HandleCommsMessage("CommLog_Tells_In", sShieldMessage, "", {[1] = {["textcolour"] = iCOLOUR.red, ["backcolour"] = iCOLOUR.black, ["text"] = sShieldMessage, ["length"] = string.len(sShieldMessage)}})
      end
      bNeedUpdate = true
      sGroupMembers[sUsePlayerName][sShieldType] = 0
    end
  elseif (sArcaneGatherPlayerSeen ~= "" and OST() - iArcaneGatherLastSaw < 2) then
    sGroupMembers[sArcaneGatherPlayerSeen][sShieldType] = 100
    if (sArcaneGatherPlayerSeen == sMyPlayerName) then
      sGroupMembers["You"][sShieldType] = 100
    end
    bNeedUpdate = true
  end
  if (bNeedUpdate == true) then
    RedrawShieldsWindow()
    Redraw()
  end
end


-- *******************************************************
-- ***** Timer profiler for debugging slow functions *****
-- *******************************************************

local objProfiler = loadfile((GetPluginInfo(sMinimapID, 20)) .. "_profiler_minimap.lua")
if (objProfiler ~= nil) then
  ColourNote(sCOLOUR.orange, "", "WARNING:  Debug-mode timer profiler loaded, this causes spam every time you do anything - for debug testing purposes only.")
  objProfiler()
end

-- Create triggers for any desired talker channels
for sKey, sData in pairs(objChatFilters) do
  if (sKey ~= "Tells_In" and sKey ~= "Tells_Out" and sKey ~= "Group_Say") then
    local iThisFlags = 33
    if (sData[3] == true) then
      iThisFlags = iThisFlags + 4
    end
    QuowAddTalkerTrigger(sKey)
  elseif (sKey == "Group_Say" and sData[3] == true) then
    SetTriggerOption("CommLog_Group_Say", "omit_from_output", "y")
  end
end

-- Create triggers for any already-loaded hotspots
for iHotspotID, objHotspot in pairs(sHotspotData) do
  QuowAddHotspotHandler(iHotspotID)
end
ReSortHotspots()


]]>
  </script>
  <!--  Triggers  -->
  <triggers>
    <!-- ASCII Map Redirection -->
    <trigger enabled="n" keep_evaluating="y" match="*" regexp="n" omit_from_output="n" sequence="1" name="AsciiMapPre" group="module_ascii" send_to="12">
      <send>
    if (GetLineInfo(GetLinesInBufferCount(), 1) == sAsciiMapString) then
      EnableTrigger("AsciiMapLine", true)
      EnableTrigger("AsciiMapPre", false)
    end
      </send>
    </trigger>
    <trigger enabled="n" keep_evaluating="y" match="*" regexp="n" omit_from_output="n" sequence="2" script="HandleAsciiMapRedirection" name="AsciiMapLine" group="module_ascii">
    </trigger>
    <!-- Outgoing tells, stops triggering anyting else by accident -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> |\] )?You (?:[A-z]+ )?(?>tell |exclaim to |ask ).+?: " regexp="y" sequence="1" script="HandleCommsMessage" name="CommLog_Tells_Out" group="module_comms">
    </trigger>
    <!-- Incoming tells, stops triggering anyting else by accident -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?:(?!You )[A-Za-z](?:\w+\b\W*?){1,9}) (?>tells|exclaims to|asks)(?>.+?you): " regexp="y" sequence="1" script="HandleCommsMessage" name="CommLog_Tells_In" group="module_comms">
    </trigger>
    <!-- Group Says, pretty much anything in square brackets followed by some letters -->
    <trigger enabled="y" keep_evaluating="y" match="^(?:> )?\[(?!say|tell|soul|/| \])(?P<channel>[^\]]+)\] [A-Za-z]{3,}" regexp="y" sequence="3" script="HandleCommsMessage" name="CommLog_Group_Say" group="module_comms">
    </trigger>
    <!-- For group-say syncing of hotspot timers -->
    <trigger enabled="y" keep_evaluating="y" match="^(?:> )?\[(?!say|tell|soul|/| \])(?P<channel>[^\]]+)\] ([A-Za-z]+?): CowBarHotspotSync:(.+)$" regexp="y" sequence="15" script="HandleHotspotSync" name="Hotspots_AutoSync" group="module_hotspots">
    </trigger>
    <!-- Login informs (disabled in Cow Bar 3.0, disabled trigger left here in case of future usage) -->
    <trigger enabled="n" keep_evaluating="n" match="^(?:> )?\[(?P<login>[A-Za-z]+) enters Discworld" regexp="y" sequence="3" script="HandleLoginNotificationTrigger">
    </trigger>
    <!-- You cre-tell -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" match="^You cre-tell:.+$" regexp="y" sequence="10" name="QuowOutgoingCreTell" script="QuowOutgoingCreTell">
    </trigger>
    <!-- You special-tell -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" match="^You special-tell:.+$" regexp="y" sequence="10" name="QuowOutgoingSpecialTell" script="QuowOutgoingSpecialTell">
    </trigger>
    <!-- You newbie-tell -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" match="^You newbie-tell:.+$" regexp="y" sequence="10" name="QuowOutgoingNewbieTell" script="QuowOutgoingNewbieTell">
    </trigger>
    <!-- Combat monitor and score-brief -->
    <!-- Custom prompts won't work! -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?Hp: (\d+) ?\((\d+)\) +(?:Gp\: (\d+) ?\((\d+)\)) +(?:Xp\: (\d+))(?:  Burden: (\d+)\%)?$" regexp="y" sequence="4" script="QuowHandleScoreBrief" group="module_vitals">
    </trigger>
    <!-- You have joined a group -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?\[(?P<groupname>[^\]]+)\] You have joined the group\.$" regexp="y" omit_from_output="n" sequence="9" script="HandleGroupJoinMe" name="GroupJoinYou" group="module_shields">
    </trigger>
    <!-- You have left a group -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?\[(?P<groupname>[^\]]+)\] You have left the group\.$" regexp="y" omit_from_output="n" sequence="9" script="HandleGroupLeaveMe" name="GroupLeaveYou" group="module_shields">
    </trigger>
    <!-- Another player has joined your group -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?\[(?P<groupname>[^\]]+)\] (?P<player>[A-Za-z]+) has joined the group\.$" regexp="y" omit_from_output="n" sequence="10" script="HandleGroupJoinOther" name="GroupJoinPlayer" group="module_shields">
    </trigger>
    <!-- Another player has left your group -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?\[(?P<groupname>[^\]]+)\] (?P<player>[A-Za-z]+) has left the group\.$" regexp="y" omit_from_output="n" sequence="10" script="HandleGroupLeaveOther" name="GroupLeavePlayer" group="module_shields">
    </trigger>
    <!-- Group Status Brief for YOU (grab your name too) -->
    <trigger enabled="y" keep_evaluating="y" match="^(?:> )?(?P<player>[A-Za-z]+); Hp: \d+/\d+ Gp: \d+/\d+\.$" ignore_case="y" regexp="y" sequence="10" script="HandleGroupStatusMe" name="GroupStatusMe" group="module_shields">
    </trigger>
    <!-- Group Status for other players -->
    <trigger enabled="y" keep_evaluating="y" match="^(?:> )?(?:   )?(?!(\[|>))(?P<player>[A-Za-z]+) is (?P<hp>unhurt|almost unhurt|scratched|slightly hurt|slightly injured|injured|slightly wounded|wounded|badly wounded|heavily wounded|seriously wounded|critically wounded|near death) and (?P<gp>refreshed|clear of mind|concentrated|slightly confused|confused|slightly fatigued|fatigued|very fatigued|highly fatigued|severely fatigued|near unconscious)\." regexp="y" sequence="11" script="HandleGroupStatusOther" name="GroupStatusOther" group="module_shields">
    </trigger>
    <!-- Group Status for DEAD other players -->
    <trigger enabled="y" keep_evaluating="y" match="^(?:> )?(?:   )?(?!(\[|>))(?P<player>[A-Za-z]+) is (?P<hp>perfectly healthy, for a ghost)(?P<gp>)\." regexp="y" sequence="11" script="HandleGroupStatusOther" name="GroupDeadOther" group="module_shields">
    </trigger>
    <!-- Start of Arcane line gathering for YOU -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?Arcane protection status:$" regexp="y" omit_from_output="n" sequence="11" script="HandleArcaneTriggerMe" name="ArcaneTriggerStartYou" group="module_shields">
    </trigger>
    <!-- CCC Type 1 for YOU -->
    <trigger enabled="y" keep_evaluating="n" match="^ \* Your skin (?>has been|has|is) (?>hardened to a rock-like form|hardened with numerous layers of a mineral-like substance|hardened with a chalk-like substance|covered with several layers of a chalk-like substance|covered with a thin layer of chalk|covered with a thick metal net|metal bands running all over it, forming a kind of net|covered with a thin metal net|covered with a thin, net-like metal coating|solidified into a rubberous form|made elastic with numerous layers of a rubber-like substance|treated with a latex-like substance|covered with several layers of a latex-like substance|covered with a thin layer of latex), although " regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YNA_CCC" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^ \* Tiny threads of metal run criss-cross all over your skin, although " regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield2_YNA_CCC" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?Your? (?>feel your skin become (?>rock hard|elastic as rubber)|skin (?>feels (?>even harder now|much more elastic now)|is now as (?>hard|elastic|thickly covered) as it can get))\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YNU_CCC" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?You feel your skin tingle as the metal powder fuses together into thin metal bands, forming a net-like shape\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield2_YNU_CCC" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?Your skin feels itchy; large pieces flake off as you scratch it\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YND_CCC" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?With a brief flash of magic, your (?>metallic|stony|elastic) skin falls away\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield2_YND_CCC" group="module_shields">
    </trigger>
    <!-- TPA for YOU -->
    <trigger enabled="y" keep_evaluating="y" match="^ \* You are surrounded by a (?P<colour>|dull red |bright red |wobbling orange |flickering yellow )magical impact shield\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YNA_TPA" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?With a noise that sounds like &quot;Plink!&quot;, everything around you flashes (?>yellow|red) for a moment\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YNU_TPA" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?There is a sudden white flash\.  Your magical shield has broken\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YND_TPA" group="module_shields">
    </trigger>
    <!-- Bugs for YOU -->
    <trigger enabled="y" keep_evaluating="n" match="^ \* You are surrounded by a (?>handful|cloud|small swarm|large swarm|vast swarm|plague) of" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YNA_BUG" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?>Buzzing drowsily, t|Buzzing loudly, t|Buzzing threateningly, t|Clicking and buzzing, t|Whirring gently, t|Rather clumsily, t|With a rasping noise, t|With a high-pitched whining noise, t|With a low, menacing buzzing, t|With a buzzing sound so loud and meaty it's almost like a dog growling, t|T)he (?>handful|cloud|small swarm|large swarm|vast swarm|plague) of (?>lacewings|stick insects|mayflies|praying mantids|butterflies|ladybirds|dragonflies|damselflies|moths|grasshoppers|winged termites|sandflies|mosquitoes|gnats|crickets|flying ants|locusts|horseflies|cicadas|bees|wasps|hornets|elephant beetles|assassin bugs) (?>flutters into a loosely-formed orbit around |forms a chaotic web of small white bodies around |starts to hover near |begins to circle |begins to circle around |begins to orbit |clusters haphazardly |begins to cluster around |begins to buzz erratically around |begins to buzz around |flutters into a chaotic formation around )you" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YNU_BUG" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?The (?>lacewings|stick insects|mayflies|praying mantids|butterflies|ladybirds|dragonflies|damselflies|moths|grasshoppers|winged termites|sandflies|mosquitoes|gnats|crickets|flying ants|locusts|horseflies|cicadas|bees|wasps|hornets|elephant beetles|assassin bugs) surrounding you scatter in different directions and fly off\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YND_BUG" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?The last of the injured (?>lacewings|stick insects|mayflies|praying mantids|butterflies|ladybirds|dragonflies|damselflies|moths|grasshoppers|winged termites|sandflies|mosquitoes|gnats|crickets|flying ants|locusts|horseflies|cicadas|bees|wasps|hornets|elephant beetles|assassin bugs) surrounding you crash to the ground\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield2_YND_BUG" group="module_shields">
    </trigger>
    <!-- Major for YOU -->
    <trigger enabled="y" keep_evaluating="n" match="^ \* You are (?>(?>barely |really |perfectly )?protected|shielded) by the (?>power |protective armour |grace )of (?>Pishe|Gufnork|Gapp|Sandelfon|Fish|Hat|Sek|Aegadon|Cubal|Reebox)\.  You will be protected for " regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YNA__MS" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?You are protected by the power of (?>Pishe|Gufnork|Gapp|Sandelfon|Fish|Hat|Sek|Aegadon|Cubal|Reebox)\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YNU__MS" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?Your divine protection expires\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YND__MS" group="module_shields">
    </trigger>
    <!-- EFF for YOU -->
    <trigger enabled="y" keep_evaluating="n" match="^ \* (?P<effitem>(?:\w+\b\W*?){1,6}) is floating around you\:$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YNA_EFF" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?P<effitem>(?:\w+\b\W*?){1,6}) begins to float around you\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YNU_EFF" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?In blocking the attack (?P<effitem>(?:\w+\b\W*?){1,6}) floating around you is knocked out of orbit\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield1_YND_EFF" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?You realise that (?P<effitem>(?:\w+\b\W*?){1,6}) is no longer floating around you\.$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield2_YND_EFF" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?P<effitem>(?:\w+\b\W*?){1,6}) floating around you breaks!$" regexp="y" sequence="12" script="HandleShieldData" name="ArcaneShield3_YND_EFF" group="module_shields">
    </trigger>
    <!-- No shields at all for YOU -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?You do not have any arcane(?: or divine)? protection\.$" regexp="y" sequence="11" script="HandleArcaneTriggerOther" name="ArcaneShieldNothingYou" group="module_shields">
    </trigger>
    <!-- Start of Arcane line gathering for OTHER players -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?Arcane protection for (?P<player>[A-Za-z]+):-$" regexp="y" omit_from_output="n" sequence="13" script="HandleArcaneTriggerOther" name="ArcaneTriggerStart" group="module_shields">
    </trigger>
    <!-- No shields at all for OTHER players -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?P<player>(?:\w+\b\W*?){1,8}) has no arcane(?: or divine)? protection\.$" regexp="y" sequence="13" script="HandleArcaneTriggerOther" name="ArcaneShieldNothing" group="module_shields">
    </trigger>
    <!-- CCC Type 1 for OTHER players -->
    <trigger enabled="y" keep_evaluating="n" match="^ \* (?>His|Her|Its) skin (?>has been|has|is) (?>hardened to a rock-like form|hardened with numerous layers of a mineral-like substance|hardened with a chalk-like substance|covered with several layers of a chalk-like substance|covered with a thin layer of chalk|covered with a thick metal net|metal bands running all over it, forming a kind of net|covered with a thin metal net|covered with a thin, net-like metal coating|solidified into a rubberous form|made elastic with numerous layers of a rubber-like substance|treated with a latex-like substance|covered with several layers of a latex-like substance|covered with a thin layer of latex), although " regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_ONA_CCC" group="module_shields">
    </trigger>
    <!-- CCC Type 2 for OTHER players -->
    <trigger enabled="y" keep_evaluating="n" match="^ \* Tiny threads of metal run criss-cross all over (?>her|his|its) skin, although " regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield2_ONA_CCC" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?P<player>(?:\w+\b\W*?){1,8})'s skin becomes (?>elastic as rubber|rock hard)\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_ONU_CCC" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?The metal powder fuses together into metal bands on (?P<player>(?:\w+\b\W*?){1,8})'s skin\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield2_ONU_CCC" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?P<player>(?:\w+\b\W*?){1,8})'s skin is now as (?>elastic|thickly covered|hard) as it can get\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield3_ONU_CCC" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?P<player>(?:\w+\b\W*?){1,8}) scratches (?>himself|herself|itself), and large pieces of skin flake off\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_OND_CCC" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?There is a brief flash of magic, and something falls away from (?P<player>(?:\w+\b\W*?){1,8})'s skin\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield2_OND_CCC" group="module_shields">
    </trigger>
    <!-- TPA for OTHER players -->
    <trigger enabled="y" keep_evaluating="y" match="^ \* (?>She|He|It) is surrounded by a (?P<colour>|dull red |bright red |wobbling orange |flickering yellow )magical impact shield\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_ONA_TPA" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?With a noise that sounds like &quot;Plink!&quot;, the air around (?P<player>(?:\w+\b\W*?){1,8}) flashes (?>yellow|red) for a moment\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_ONU_TPA" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?There is a sudden white flash around (?P<player>(?!a passing wizard)(?:\w+\b\W*?){1,8})\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_OND_TPA" group="module_shields">
    </trigger>
    <!-- Bugs for OTHER players -->
    <trigger enabled="y" keep_evaluating="n" match="^ \* (?>She|He|It) is surrounded by a (?>handful|cloud|small swarm|large swarm|vast swarm|plague) of " regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_ONA_BUG" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?>Buzzing drowsily, t|Buzzing loudly, t|Buzzing threateningly, t|Clicking and buzzing, t|Whirring gently, t|Rather clumsily, t|With a rasping noise, t|With a high-pitched whining noise, t|With a low, menacing buzzing, t|With a buzzing sound so loud and meaty it's almost like a dog growling, t|T)he (?>handful|cloud|small swarm|large swarm|vast swarm|plague) of (?>lacewings|stick insects|mayflies|praying mantids|butterflies|ladybirds|dragonflies|damselflies|moths|grasshoppers|winged termites|sandflies|mosquitoes|gnats|crickets|flying ants|locusts|horseflies|cicadas|bees|wasps|hornets|elephant beetles|assassin bugs) (?>flutters into a loosely-formed orbit around |forms a chaotic web of small white bodies around |starts to hover near |begins to circle |begins to circle around |begins to orbit |clusters haphazardly |begins to cluster around |begins to buzz erratically around |begins to buzz around |flutters into a chaotic formation around )(?P<player>(?:\w+\b\W*?){1,8})(?:| happily| slowly|, chirping gently|, buzzing hungrily)\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_ONU_BUG" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?The (?>lacewings|stick insects|mayflies|praying mantids|butterflies|ladybirds|dragonflies|damselflies|moths|grasshoppers|winged termites|sandflies|mosquitoes|gnats|crickets|flying ants|locusts|horseflies|cicadas|bees|wasps|hornets|elephant beetles|assassin bugs) surrounding (?P<player>(?:\w+\b\W*?){1,8}) scatter in different directions and fly off\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_OND_BUG" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?The last of the injured (?>lacewings|stick insects|mayflies|praying mantids|butterflies|ladybirds|dragonflies|damselflies|moths|grasshoppers|winged termites|sandflies|mosquitoes|gnats|crickets|flying ants|locusts|horseflies|cicadas|bees|wasps|hornets|elephant beetles|assassin bugs) surrounding (?P<player>(?:\w+\b\W*?){1,8}) crash to the ground\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield2_OND_BUG" group="module_shields">
    </trigger>
    <!-- Major for OTHER players -->
    <trigger enabled="y" keep_evaluating="n" match="^ \* (?>She|He|It) is (?>really )?protected by the power of (?>Pishe|Gufnork|Gapp|Sandelfon|Fish|Hat|Sek|Aegadon|Cubal|Reebox)" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_ONA__MS" group="module_shields">
    </trigger>
    <!-- EFF for OTHER players -->
    <trigger enabled="y" keep_evaluating="n" match="^ \* (?P<effitem>(?:\w+\b\W*?){1,6}) is floating around (?>him|her|it)\:$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_ONA_EFF" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?P<effitem>(?:\w+\b\W*?){1,6}) begins to float around (?P<player>(?:\w+\b\W*?){1,8})\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_ONU_EFF" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?In blocking the attack (?P<effitem>(?:\w+\b\W*?){1,6}) floating around (?P<player>(?:\w+\b\W*?){1,8}) is knocked out of orbit\.$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield1_OND_EFF" group="module_shields">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?P<effitem>(?:\w+\b\W*?){1,6}) floating around (?P<player>(?:\w+\b\W*?){1,8}) breaks!$" regexp="y" sequence="14" script="HandleShieldData" name="ArcaneShield2_OND_EFF" group="module_shields">
    </trigger>
    <!-- Map door text parse triggering -->
    <trigger enabled="y" keep_evaluating="n" match="he limit of your vision is.+here\.$" omit_from_output="y" regexp="y" sequence="39" script="ParseMDT" name="DoorTextFull" group="module_mdt">
    </trigger>
    <!-- Contemplate GP Triggers -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?With (?P<spellname>(?:\w+\b\W*?){1,8}) at the forefront of your mind, you enter a deep trance\.$" regexp="y" sequence="15" script="HandleContemplateStart" name="ContemplateStart">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^(?:> )?You emerge from your trance\.$" regexp="y" sequence="15" script="HandleContemplateEnd" name="ContemplateEnd">
    </trigger>
    <!-- Kill - outgoing -->
    <trigger enabled="y" keep_evaluating="y" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="deepskyblue" match="^(?:> )?You kill (?P<vic>(?:\w+\b\W*?){1,8})\.$" regexp="y" sequence="15" script="StatsKillStatOutgoing" name="QuowKillStatOut1">
    </trigger>
    <!-- Kills - third party -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="darkcyan" match="^(?:> )?(?P<att>(?!You )(?:\w+\b\W*?){1,8}) deals the death blow to (?P<vic>(?!you |you,)(?:\w+\b\W*?){1,8})\.$" regexp="y" sequence="16" script="StatsKillStatThird" name="StatsKillStatThird1">
    </trigger>
    <!-- Kills - incoming -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="red" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) deals the death blow to you\.$" regexp="y" sequence="17" script="StatsKillStatIncoming" name="QuowKillStatInc1">
    </trigger>
    <!-- Follow another player in a recognised direction -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?You (?:follow|pursue) [a-zA-Z](?:\w+\b\W*?){1,8} (north|northeast|east|southeast|south|southwest|west|northwest|left|right|forward|backward|up|down)\.$" regexp="y" script="FollowHandler" name="FollowHandle" sequence="10" group="module_minimap">
    </trigger>
    <!-- Movement is simply impossible in this direction -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?>What\?|That doesn't work\.|Try something else\.)$" regexp="y" script="MovementFailure" name="MoveFail" sequence="10" group="module_minimap">
    </trigger>
    <!-- Command queue cleared -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?>Removed queue\.|Thanks for playing\.  See you next time\.)$" regexp="y" script="MovementQueueClear" name="MoveClear" sequence="10" group="module_minimap">
    </trigger>
    <!-- Movement SHOULD be possible, but was intercepted by something -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?>The door swings shut in your face\.|The (?>north |northeast |east |southeast |south |southwest |west |northwest |warehouse )?(?>door|gate) is locked\.|(?>Free Sitting Birds|Nella|Jonas|Master Brimstone|Will|Thella|Nostos|Philip LeGrande) intercepts you\.|Try as you might, the sheep block any further progress south\.|(?:\w+\b\W*?){1,4} blocks the exit and prevents you from leaving (?>northeast|southeast|southwest|northwest|north|east|south|west)\.|That exit is creator-only for the moment\.|You do your best to get through the turnstiles, but the crowds are simply too thick and you make no headway\.  Better come back later, maybe they'll be more accessible then\.|A magic force prevents you from going that way\.|The bridge troll bars your way\.|The bridge troll is blocking the entire road very effectively, and you just can't sneak past him\.|The (?>north |northeast |east |southeast |south |southwest |west |northwest )?door slams shut in your face\.|Some unseen force grabs hold of you and pushes you back\.|Some sort of invisible field stops you from going that way at this point in time\.|A wooden barrier prevents your progress in this direction\.|A giant grabs you as you try to leave!|Four bandits leap out from hiding!|The (ceremonial)? (guard|sentry) blocks your way.|One of the guard thieves stops you from entering\.|A terrible sense of foreboding comes over you as you try to go .+\.|You need to climb in order to travel .+? from here\.|You just crawled\.  Give your arms a break!|You can't go that way - a vine trellis is totally blocking the path\.)$" regexp="y" script="MovementBlockage" name="MoveBlock" sequence="20" group="module_minimap">
    </trigger>
    <!-- Brief-look library warning! -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?The Library \[rt,lt,s\]\.$" regexp="y" script="HandleLibraryBriefLook" name="HandleLibraryBriefLook" sequence="10">
    </trigger>
    <!-- Watch exits until we know we are getting GMCP data for user reconnect warnings -->
    <trigger enabled="y" keep_evaluating="y" match="^There (?>are|is) (?:\w+\b\W*?){1,2} obvious exit" omit_from_output="n" sequence="15" script="QuowConfirmExitsSeen" regexp="y" name="RoomExitsSeenLong">
    </trigger>
    <!-- Same again but for other purposes, disabled by default -->
    <trigger enabled="n" keep_evaluating="y" match="^There (?>are|is) (\w+\b\W*?){1,2} obvious exit" omit_from_output="n" sequence="15" script="QuowRoomExitMapper" regexp="y" name="RoomExitMapping">
    </trigger>
    <trigger enabled="y" keep_evaluating="y" match="^[a-zA-Z].+ \[.+\]\.$" omit_from_output="n" sequence="15" script="QuowConfirmExitsSeen" regexp="y" name="RoomExitsSeenShort">
    </trigger>
    <!-- Distortion seen in the Library -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?There is a strange distortion in space and time (.+) you!$" regexp="y" script="UULibraryDistortion" sequence="15" group="module_minimap">
    </trigger>
    <!-- New distortion has formed in the room, caution! -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?(?>You notice an odd rippling in the air\.|The awful sound of nails being dragged down a blackboard fills the area briefly\.|A distortion in time and space is forming!)$" regexp="y" script="HandleDistortionFormed" name="NewDistortion" sequence="15">
    </trigger>
    <!-- Room returned to normal -->
    <trigger enabled="y" keep_evaluating="n" match="^(?:> )?The (?>distortion fades away|area seems more mundane than before)\.$" regexp="y" script="HandleDistortionVanish" name="DistortionVanish" sequence="15">
    </trigger>
    <!-- Escaped orbs in the room/library -->
    <trigger enabled="y" keep_evaluating="n" match="(?>a|A) (tiny speck|small point|moderately-sized ball|large orb|substantial sphere) of energy is tracing a (?:.+?) pattern in the air" regexp="y" script="HandleLibraryOrb" name="UULibraryOrbs" sequence="20" group="module_minimap">
    </trigger>
    <!-- Hide Speed-Walk Alias Changes as spam -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="y" match="^(?:> )?Changed alias &quot;MooMooQuowsRun&quot; from &quot;" regexp="y" name="QuowHideSpeedwalkChange" sequence="20" group="module_minimap">
    </trigger>
    <!-- Only used when recording shop data for database creation, off by default -->
    <trigger enabled="n" keep_evaluating="n" match="^   ([A-Z]{1,2}): (?>an |a |A |An )?(.+) for (.+?)( \((.+?) left\)){0,1}\.$" regexp="y" script="ShopStandardInventory" name="ShopStandardInventory" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^(?>The |An |A )?(.+?) is priced at (.+?) and looks like:$" regexp="y" script="ShopPrepareBrowse" name="ShopPrepareBrowse" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^You heft (?>the |an |a )?(.+?) and guess that (?>they |it |she |he )weighs? (.+)\.$" regexp="y" script="QuowItemWeight" name="QuowItemWeight" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^(?!You )(?>The |An |A |Some )(\w+\b\W*?){1,6} weighs? (.+)\.$" regexp="y" script="QuowAccurateItemWeight" name="QuowAccurateWeight" sequence="21">
    </trigger>
    <trigger enabled="n" keep_evaluating="y" match="*" regexp="n" script="ShopCaptureBrowse" name="ShopCaptureBrowse" sequence="1">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^    (?>an |a |An |A )?(.+?) {2,}(.+)$" regexp="y" script="ShopRestaurantInventory" name="ShopRestaurantInventory" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^(?:.+?) says to you(?> in (?>Djelian|Klatchian|Agatean|Ephebian|Brindisian|Uberwaldean))?(?> with .+? accent)?: I have the following items for sale:$" regexp="y" script="NPCShopItemPrimeList" name="NPCShopItemPrimeList" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^(?:.+?) says to you(?> in (?>Djelian|Klatchian|Agatean|Ephebian|Brindisian|Uberwaldean))?(?> with .+? accent)?: I have (?>a |an |the |one |two |three |four |five |six |seven |eight |nine |ten |eleven |twelve |thirteen |fourteen |fifteen |sixteen |seventeen |eighteen |nineteen |twenty )?(.+) for (?:.+)\.$" regexp="y" script="NPCShopItemGather" name="NPCShopItemGather" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^(?:.+?) says to you(?> in (?>Djelian|Klatchian|Agatean|Ephebian|Brindisian|Uberwaldean))?(?> with .+? accent)?: And finally I have (?>a |an |the |one |two |three |four |five |six |seven |eight |nine |ten |eleven |twelve |thirteen |fourteen |fifteen |sixteen |seventeen |eighteen |nineteen |twenty )?(.+) for (?:.+)\.$" regexp="y" script="NPCShopItemFinal" name="NPCShopItemFinal" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^(?:.+?) says to you(?> in (?>Djelian|Klatchian|Agatean|Ephebian|Brindisian|Uberwaldean))?(?> with .+? accent)?: You're interested in (?>The |An |A |the |an |a )?(.+?)\?  It is only (.+?), a top quality good\.$" regexp="y" script="NPCShopStockPrice" name="NPCShopStockPrice2" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^(?:.+?) says to you(?> in (?>Djelian|Klatchian|Agatean|Ephebian|Brindisian|Uberwaldean))?(?> with .+? accent)?: (?>The |An |A |the |an |a )?(.+?) is priced at (.+?)\.  Let me show it to you\.$" regexp="y" script="NPCShopStockPrice" name="NPCShopStockPrice" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^(?:.+?) whispers to you(?> in (?>Djelian|Klatchian|Agatean|Ephebian|Brindisian|Uberwaldean))?(?> with .+? accent)?: (?>The |An |A |the |an |a )?(.+?):$" regexp="y" script="NPCShopStockPrimeDescription" name="NPCShopStockPrimeDescription" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^You have a good look at the ground and scavenge (.+?) from (.+?)\.$" omit_from_output="n" sequence="15" regexp="y" script="QuowScavengeItem" name="QuowScavengeItem">
    </trigger>
    <trigger enabled="n" keep_evaluating="y" match="*" regexp="n" script="NPCShopStockDescription" name="NPCShopStockDescription" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" match="^(?>The |An |A |the |an |a )?(.+) costs (.+?), it looks like:$" regexp="y" script="ShopManualBrowsePrime" name="ShopManualBrowsePrime" sequence="20">
    </trigger>
    <trigger enabled="n" keep_evaluating="y" match="*" regexp="n" script="ShopManualBrowseGather" name="ShopManualBrowseGather" sequence="20">
    </trigger>
    <!-- Backstabbings - outgoing -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?You (?>skilfully |silently )?sneak around (?:\w+\b\W*?){1,8} without being spotted and manage to catch (?>him|her|it) by surprise\.$" regexp="y" script="StatsSpecialSuccessNoHitOutgoing" name="QuowSpecialBackstabSuccessOut" sequence="30" group="module_stats">
    </trigger>
    <!-- Ambushes - outgoing -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?You leap out on (?:\w+\b\W*?){1,8}, catching (?>him|her|it) by surprise\.$" regexp="y" script="StatsSpecialSuccessNoHitOutgoing" name="QuowSpecialAmbushSuccessOut" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?You are about to leap out on (?:\w+\b\W*?){1,8}, but (?>he|she|it) spots you!$" regexp="y" script="StatsSpecialFailNoHitOutgoing" name="QuowSpecialAmbushFailOut" sequence="30" group="module_stats">
    </trigger>
    <!-- Absconds - outgoing -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?You quickly slip behind (?:\w+\b\W*?){1,8} and, before (?>he|she|it) can react, you head towards the (?:.+) exit\.$" regexp="y" script="StatsSpecialSuccessNoHitOutgoing" name="QuowSpecialAbscondSuccessOut" sequence="30" group="module_stats">
    </trigger>
    <!-- Backstabs Incoming -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) attacks you from behind\.  You recall (?>him|her|it) standing right in front of you just a second ago\.$" regexp="y" script="StatsSpecialSuccessNoHitIncoming" name="QuowSpecialBackstabSuccessInc" sequence="31" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?You suddenly (?>sense a presence|hear a noise) behind you and turn around to (?>see|find) (?:\w+\b\W*?){1,8} preparing to backstab you\.  You (?>decide to teach (?>him|her|it) a lesson|take the opportunity to launch a pre-emptive attack)\.$" regexp="y" script="StatsSpecialFailNoHitIncoming" name="QuowSpecialBackstabFailInc" sequence="31" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?You notice (?:\w+\b\W*?){1,8} falling over (?>his|her|its) feet while trying to sneak round you and decide to teach (?>him|her|it) a lesson\.$" regexp="y" script="StatsSpecialFailNoHitIncoming" name="QuowSpecialBackstabFail2Inc" sequence="31" group="module_stats">
    </trigger>
    <!-- Backstabs - third party -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) manages to get around (?:(?!you )(?:\w+\b\W*?){1,8})'s defences and launches a vicious attack\.$" regexp="y" script="StatsSpecialSuccessNoHitThird" name="QuowSpecialBackstabSuccessThird" sequence="32" group="module_stats">
    </trigger>
    <!-- Ambushes - third party -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) expertly executes an ambush attack on (?:(?!you )(?:\w+\b\W*?){1,8})\.$" regexp="y" script="StatsSpecialSuccessNoHitThird" name="QuowSpecialAmbushSuccessThird" sequence="32" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) notices (?:(?!you )(?:\w+\b\W*?){1,8}) trying to ambush (?>him|her|it) and turns around to teach (?>him|her|it) a lesson\.$" regexp="y" script="StatsSpecialFailNoHitThird" name="QuowSpecialAmbushFailThird" sequence="32" group="module_stats">
    </trigger>
    <!-- Absconds - third party  -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) suddenly ducks behind (?:(?!you )(?:\w+\b\W*?){1,8}) and heads towards the (?:.+) exit\.$" regexp="y" script="StatsSpecialSuccessNoHitThird" name="QuowSpecialAbscondSuccessThird" sequence="32" group="module_stats">
    </trigger>
    <!-- Incoming feints -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) moves as though about to launch a powerful attack and you prepare to defend yourself\.  Too late, you realise that it is a feint and you are left (?>momentarily )?off balance(?> and exposed)?\.$" regexp="y" script="StatsSpecialSuccessIncoming" name="QuowFeintSuccessIncoming1" sequence="31" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) moves as though about to launch a powerful attack but you realise it is a feint and do not react\.$" regexp="y" script="StatsSpecialFailIncoming" name="QuowFeintFailIncoming1" sequence="31" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?You move as though about to launch a powerful attack on (?:\w+\b\W*?){1,8}\.  (?>He|She|It) sees through your feint and doesn't react\.$" regexp="y" script="StatsSpecialFailOutgoing" name="QuowFeintFailOutgoing1" sequence="31" group="module_stats">
    </trigger>
    <!-- Dodge throwing weapons -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?You(?P<level> barely| quickly| swiftly)(?P<type> dodge) out of the path of the (?:(?:\w+\b\W*?){1,8})\.$" regexp="y" script="StatsMeleeFailIncoming" name="QuowThrowingFailInc1" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8})(?P<level> barely| quickly| swiftly)(?P<type> dodges) out of the (?:(?:\w+\b\W*?){1,8}) path\.$" regexp="y" script="StatsMeleeFailThird" name="QuowThrowingFailThird1" sequence="31" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) (?P<shielding>floating around )you(?> barely| quickly| swiftly) swoops in and blocks (?:\w+\b\W*?){1,8}\.$" regexp="y" script="StatsMeleeFailIncoming" name="QuowThrowingFailInc2" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) (?P<shielding>floating around )(?:(?!you )(?:\w+\b\W*?){1,8})(?> barely| quickly| swiftly) swoops in and blocks (?:\w+\b\W*?){1,8}\.$" regexp="y" script="StatsMeleeFailThird" name="QuowThrowingFailThird2" sequence="31" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) bounces off your (?P<shielding>magical shielding)\.$" regexp="y" script="StatsMeleeFailIncoming" name="QuowThrowingFailInc3" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) bounces off (?:(?!you )(?:\w+\b\W*?){1,8}) (?P<shielding>magical shielding)\.$" regexp="y" script="StatsMeleeFailThird" name="QuowThrowingFailThird3" sequence="31" group="module_stats">
    </trigger>
    <!-- Knockout Dodging -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#1E90FF" match="^(?:> )?(?:\w+\b\W*?){1,8} aims a knock-out blow at the back of your head, but you(?P<type> dodge) it in time\.$" regexp="y" script="StatsMeleeFailIncoming" name="QuowMiscFailInc1" sequence="30" group="module_stats">
    </trigger>
    <!-- You FAIL to prepare a special -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="magenta" match="^(?:> )?You attempt to (?>bash |beat |bob |chop |feint |hack |kick |pierce |punch |riposte |shove |slash |smash |stab |trip |crush |behead |impale |flick |launch a wildswing attack )(?:.+?) but (?>cannot find an opportunity|you move too slowly and lose the initiative)\.$" regexp="y" script="StatsSpecialPrepareFail" name="QuowMeleeSpecialFail1" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="magenta" match="^(?:> )?You lose the moment\.$" regexp="y" script="StatsSpecialPrepareFail" name="QuowMeleeSpecialFail2" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="magenta" match="^(?:> )?You try to (?>trip |shove )(?:\w+\b\W*?){1,8} but fail and stumble(?:| slightly)\.$" regexp="y" script="StatsSpecialPrepareFail" name="QuowMeleeSpecialFail3" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="magenta" match="^(?:> )?You attempt to prepare a special attack but (?:\w+\b\W*?){1,8} feels too unwieldy and you lose the initiative\.$" regexp="y" script="StatsSpecialPrepareFail" name="QuowMeleeSpecialFail4" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="magenta" match="^(?:> )?You attempt to slip behind (?:\w+\b\W*?){1,8}, but (?>he|she|it) spots you and you fail to get away\.$" regexp="y" script="StatsSpecialPrepareFail" name="QuowMeleeSpecialFail5" sequence="30" group="module_stats">
    </trigger>
    <!-- You prepare a special -->
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="darkgreen" match="^(?:> )?You prepare to (?>bash |beat |bob |chop |feint |hack |kick |pierce |punch |riposte |shove |slash |smash |stab |trip |crush |behead |impale |flick |launch a wildswing attack ).+\.$" regexp="y" script="StatsSpecialPrepareSuccess" name="QuowMeleeSpecialPrepare1" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="darkgreen" match="^(?:> )?You begin watching for an opportunity to flick (?:.+?) at (?:\w+\b\W*?){1,8}\.$" regexp="y" script="StatsSpecialPrepareSuccess" name="QuowMeleeSpecialPrepare2" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="darkgreen" match="^(?:> )?You situate yourself for a graceful and quiet exit\.$" regexp="y" script="StatsSpecialPrepareSuccess" name="QuowMeleeSpecialPrepare3" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="darkgreen" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) reaches for you and stumbles\.$" regexp="y" script="StatsSpecialFailIncoming" name="QuowSpecialFailIncCustom1" sequence="30" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#3C4420" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) reaches for (?:(?!you )(?:\w+\b\W*?){1,8}) and stumbles\.$" regexp="y" script="" name="StatsSpecialFailThirdCustom1" sequence="31" group="module_stats">
    </trigger>
    <trigger enabled="y" keep_evaluating="n" omit_from_output="n" custom_colour="17" colour_change_type="1" other_text_colour="#3C4420" match="^(?:> )?(?:(?!You )(?:\w+\b\W*?){1,8}) moves towards (?:(?!you )(?:\w+\b\W*?){1,8}) as though about to launch a powerful attack\.  (?:(?!You )(?:\w+\b\W*?){1,8}) does not react, seeing that it was a feint\.$" regexp="y" script="" name="StatsSpecialFailThirdCustom2" sequence="31" group="module_stats">
    </trigger>
    <!-- Triggers for NPCs, only for admin-edit mode, disabled by default  -->
    <trigger enabled="n" keep_evaluating="n" omit_from_output="n" match="^Holding : (.+)\.$" regexp="y" script="NPCLootParse" name="NPCLoot_Holding" sequence="15" group="module_npcloot">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" omit_from_output="n" match="^Wearing : (.+)\.$" regexp="y" script="NPCLootParse" name="NPCLoot_Wearing" sequence="15" group="module_npcloot">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" omit_from_output="n" match="^Carrying: (.+)\.$" regexp="y" script="NPCLootParse" name="NPCLoot_Carrying" sequence="15" group="module_npcloot">
    </trigger>
    <trigger enabled="n" keep_evaluating="n" omit_from_output="n" match="^You get(?:, with a bit of difficulty,)? (.+) from the corpse of (.+)\.$" regexp="y" script="NPCLootParse" name="NPCLoot_DeathLoot" sequence="15" group="module_npcloot">
    </trigger>
    <!-- Combat Colour Trigger Filter -->
    <trigger enabled="n" keep_evaluating="y" omit_from_output="n" match="*" regexp="n" name="QuowStatOptimizer" sequence="40" send_to="12">
      <send>
    if (GetStyleInfo(GetLinesInBufferCount(), 2, 14) ~= 65535) then
      StopEvaluatingTriggers(false)
    end
      </send>
    </trigger>
  </triggers>
  <!--  Aliases  -->
  <aliases>
    <alias match="help minimap" enabled="y" ignore_case="y" sequence="30" script="DisplayHelpFile">
    </alias>
    <alias match="minimap" enabled="y" ignore_case="y" sequence="30" script="MinimapCommandHandler">
    </alias>
    <alias match="minimap *" enabled="y" ignore_case="y" sequence="30" script="QuowMapCommand">
    </alias>
    <alias match="mm" enabled="n" ignore_case="y" sequence="30" name="QuowShortMM" script="MinimapCommandHandler">
    </alias>
    <!-- Commands for admin-editing only, disabled normally, for mapping NPC's and their items  -->
    <alias match="npc *" enabled="n" ignore_case="y" sequence="30" name="QuowNPCCommand" script="QuowNPCCommand">
    </alias>
    <alias match="item *" enabled="n" ignore_case="y" sequence="30" name="QuowItemCommand" script="QuowItemCommand">
    </alias>
    <alias match="bapp *" enabled="n" ignore_case="y" sequence="30" name="QuowBrowseCommand" script="QuowBrowseCommand">
    </alias>
    <alias match="^weigh (.+) on balance$" enabled="n" regexp="y" ignore_case="y" sequence="30" name="QuowWeighBalance" script="QuowWeighBalance">
    </alias>
    <!--  list and browse are DISABLED aliases only used for admin database editing  -->
    <alias match="list" enabled="n" ignore_case="y" sequence="30" name="QuowShopList" script="HandleShopList">
    </alias>
    <alias match="shopappraise" enabled="n" ignore_case="y" sequence="30" name="QuowAppraiseItems" script="QuowAppraiseItems">
    </alias>
  </aliases>
</muclient>
